import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/next/dist/compiled/@edge-runtime/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    RequestCookies: () => RequestCookies,
    ResponseCookies: () => ResponseCookies,
    parseCookie: () => parseCookie,
    parseSetCookie: () => parseSetCookie,
    stringifyCookie: () => stringifyCookie
  });
  module.exports = __toCommonJS(src_exports);
  function stringifyCookie(c) {
    var _a;
    const attrs = [
      "path" in c && c.path && `Path=${c.path}`,
      "expires" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()}`,
      "maxAge" in c && typeof c.maxAge === "number" && `Max-Age=${c.maxAge}`,
      "domain" in c && c.domain && `Domain=${c.domain}`,
      "secure" in c && c.secure && "Secure",
      "httpOnly" in c && c.httpOnly && "HttpOnly",
      "sameSite" in c && c.sameSite && `SameSite=${c.sameSite}`,
      "partitioned" in c && c.partitioned && "Partitioned",
      "priority" in c && c.priority && `Priority=${c.priority}`
    ].filter(Boolean);
    const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : "")}`;
    return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join("; ")}`;
  }
  function parseCookie(cookie) {
    const map = /* @__PURE__ */ new Map;
    for (const pair of cookie.split(/; */)) {
      if (!pair)
        continue;
      const splitAt = pair.indexOf("=");
      if (splitAt === -1) {
        map.set(pair, "true");
        continue;
      }
      const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];
      try {
        map.set(key, decodeURIComponent(value != null ? value : "true"));
      } catch {}
    }
    return map;
  }
  function parseSetCookie(setCookie) {
    if (!setCookie) {
      return;
    }
    const [[name, value], ...attributes] = parseCookie(setCookie);
    const {
      domain,
      expires,
      httponly,
      maxage,
      path,
      samesite,
      secure,
      partitioned,
      priority
    } = Object.fromEntries(attributes.map(([key, value2]) => [key.toLowerCase(), value2]));
    const cookie = {
      name,
      value: decodeURIComponent(value),
      domain,
      ...expires && { expires: new Date(expires) },
      ...httponly && { httpOnly: true },
      ...typeof maxage === "string" && { maxAge: Number(maxage) },
      path,
      ...samesite && { sameSite: parseSameSite(samesite) },
      ...secure && { secure: true },
      ...priority && { priority: parsePriority(priority) },
      ...partitioned && { partitioned: true }
    };
    return compact(cookie);
  }
  function compact(t) {
    const newT = {};
    for (const key in t) {
      if (t[key]) {
        newT[key] = t[key];
      }
    }
    return newT;
  }
  var SAME_SITE = ["strict", "lax", "none"];
  function parseSameSite(string) {
    string = string.toLowerCase();
    return SAME_SITE.includes(string) ? string : undefined;
  }
  var PRIORITY = ["low", "medium", "high"];
  function parsePriority(string) {
    string = string.toLowerCase();
    return PRIORITY.includes(string) ? string : undefined;
  }
  function splitCookiesString(cookiesString) {
    if (!cookiesString)
      return [];
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
      while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
        pos += 1;
      }
      return pos < cookiesString.length;
    }
    function notSpecialChar() {
      ch = cookiesString.charAt(pos);
      return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while (pos < cookiesString.length) {
      start = pos;
      cookiesSeparatorFound = false;
      while (skipWhitespace()) {
        ch = cookiesString.charAt(pos);
        if (ch === ",") {
          lastComma = pos;
          pos += 1;
          skipWhitespace();
          nextStart = pos;
          while (pos < cookiesString.length && notSpecialChar()) {
            pos += 1;
          }
          if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
            cookiesSeparatorFound = true;
            pos = nextStart;
            cookiesStrings.push(cookiesString.substring(start, lastComma));
            start = pos;
          } else {
            pos = lastComma + 1;
          }
        } else {
          pos += 1;
        }
      }
      if (!cookiesSeparatorFound || pos >= cookiesString.length) {
        cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
    }
    return cookiesStrings;
  }
  var RequestCookies = class {
    constructor(requestHeaders) {
      this._parsed = /* @__PURE__ */ new Map;
      this._headers = requestHeaders;
      const header = requestHeaders.get("cookie");
      if (header) {
        const parsed = parseCookie(header);
        for (const [name, value] of parsed) {
          this._parsed.set(name, { name, value });
        }
      }
    }
    [Symbol.iterator]() {
      return this._parsed[Symbol.iterator]();
    }
    get size() {
      return this._parsed.size;
    }
    get(...args) {
      const name = typeof args[0] === "string" ? args[0] : args[0].name;
      return this._parsed.get(name);
    }
    getAll(...args) {
      var _a;
      const all = Array.from(this._parsed);
      if (!args.length) {
        return all.map(([_, value]) => value);
      }
      const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? undefined : _a.name;
      return all.filter(([n]) => n === name).map(([_, value]) => value);
    }
    has(name) {
      return this._parsed.has(name);
    }
    set(...args) {
      const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;
      const map = this._parsed;
      map.set(name, { name, value });
      this._headers.set("cookie", Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join("; "));
      return this;
    }
    delete(names) {
      const map = this._parsed;
      const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));
      this._headers.set("cookie", Array.from(map).map(([_, value]) => stringifyCookie(value)).join("; "));
      return result;
    }
    clear() {
      this.delete(Array.from(this._parsed.keys()));
      return this;
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
      return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
      return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join("; ");
    }
  };
  var ResponseCookies = class {
    constructor(responseHeaders) {
      this._parsed = /* @__PURE__ */ new Map;
      var _a, _b, _c;
      this._headers = responseHeaders;
      const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? undefined : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
      const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
      for (const cookieString of cookieStrings) {
        const parsed = parseSetCookie(cookieString);
        if (parsed)
          this._parsed.set(parsed.name, parsed);
      }
    }
    get(...args) {
      const key = typeof args[0] === "string" ? args[0] : args[0].name;
      return this._parsed.get(key);
    }
    getAll(...args) {
      var _a;
      const all = Array.from(this._parsed.values());
      if (!args.length) {
        return all;
      }
      const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? undefined : _a.name;
      return all.filter((c) => c.name === key);
    }
    has(name) {
      return this._parsed.has(name);
    }
    set(...args) {
      const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;
      const map = this._parsed;
      map.set(name, normalizeCookie({ name, value, ...cookie }));
      replace(map, this._headers);
      return this;
    }
    delete(...args) {
      const [name, path, domain] = typeof args[0] === "string" ? [args[0]] : [args[0].name, args[0].path, args[0].domain];
      return this.set({ name, path, domain, value: "", expires: /* @__PURE__ */ new Date(0) });
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
      return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
      return [...this._parsed.values()].map(stringifyCookie).join("; ");
    }
  };
  function replace(bag, headers) {
    headers.delete("set-cookie");
    for (const [, value] of bag) {
      const serialized = stringifyCookie(value);
      headers.append("set-cookie", serialized);
    }
  }
  function normalizeCookie(cookie = { name: "", value: "" }) {
    if (typeof cookie.expires === "number") {
      cookie.expires = new Date(cookie.expires);
    }
    if (cookie.maxAge) {
      cookie.expires = new Date(Date.now() + cookie.maxAge * 1000);
    }
    if (cookie.path === null || cookie.path === undefined) {
      cookie.path = "/";
    }
    return cookie;
  }
});

// node_modules/next/dist/server/web/spec-extension/cookies.js
var require_cookies2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    RequestCookies: function() {
      return _cookies.RequestCookies;
    },
    ResponseCookies: function() {
      return _cookies.ResponseCookies;
    },
    stringifyCookie: function() {
      return _cookies.stringifyCookie;
    }
  });
  var _cookies = require_cookies();
});

// node_modules/next/dist/server/web/spec-extension/adapters/reflect.js
var require_reflect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
      return ReflectAdapter;
    }
  });

  class ReflectAdapter {
    static get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
    static set(target, prop, value, receiver) {
      return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
      return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
      return Reflect.deleteProperty(target, prop);
    }
  }
});

// node_modules/next/dist/client/components/async-local-storage.js
var require_async_local_storage = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "createAsyncLocalStorage", {
    enumerable: true,
    get: function() {
      return createAsyncLocalStorage;
    }
  });
  var sharedAsyncLocalStorageNotAvailableError = new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");

  class FakeAsyncLocalStorage {
    disable() {
      throw sharedAsyncLocalStorageNotAvailableError;
    }
    getStore() {
      return;
    }
    run() {
      throw sharedAsyncLocalStorageNotAvailableError;
    }
    exit() {
      throw sharedAsyncLocalStorageNotAvailableError;
    }
    enterWith() {
      throw sharedAsyncLocalStorageNotAvailableError;
    }
  }
  var maybeGlobalAsyncLocalStorage = globalThis.AsyncLocalStorage;
  function createAsyncLocalStorage() {
    if (maybeGlobalAsyncLocalStorage) {
      return new maybeGlobalAsyncLocalStorage;
    }
    return new FakeAsyncLocalStorage;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/static-generation-async-storage-instance.js
var require_static_generation_async_storage_instance = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "staticGenerationAsyncStorage", {
    enumerable: true,
    get: function() {
      return staticGenerationAsyncStorage;
    }
  });
  var _asynclocalstorage = require_async_local_storage();
  var staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/static-generation-async-storage.external.js
var require_static_generation_async_storage_external = __commonJS((exports, module) => {
  "TURBOPACK { transition: next-shared }";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "staticGenerationAsyncStorage", {
    enumerable: true,
    get: function() {
      return _staticgenerationasyncstorageinstance.staticGenerationAsyncStorage;
    }
  });
  var _staticgenerationasyncstorageinstance = require_static_generation_async_storage_instance();
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js
var require_request_cookies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    MutableRequestCookiesAdapter: function() {
      return MutableRequestCookiesAdapter;
    },
    ReadonlyRequestCookiesError: function() {
      return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
      return RequestCookiesAdapter;
    },
    appendMutableCookies: function() {
      return appendMutableCookies;
    },
    getModifiedCookieValues: function() {
      return getModifiedCookieValues;
    }
  });
  var _cookies = require_cookies2();
  var _reflect = require_reflect();
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();

  class ReadonlyRequestCookiesError extends Error {
    constructor() {
      super("Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#cookiessetname-value-options");
    }
    static callable() {
      throw new ReadonlyRequestCookiesError;
    }
  }

  class RequestCookiesAdapter {
    static seal(cookies) {
      return new Proxy(cookies, {
        get(target, prop, receiver) {
          switch (prop) {
            case "clear":
            case "delete":
            case "set":
              return ReadonlyRequestCookiesError.callable;
            default:
              return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
        }
      });
    }
  }
  var SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for("next.mutated.cookies");
  function getModifiedCookieValues(cookies) {
    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
    if (!modified || !Array.isArray(modified) || modified.length === 0) {
      return [];
    }
    return modified;
  }
  function appendMutableCookies(headers, mutableCookies) {
    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
    if (modifiedCookieValues.length === 0) {
      return false;
    }
    const resCookies = new _cookies.ResponseCookies(headers);
    const returnedCookies = resCookies.getAll();
    for (const cookie of modifiedCookieValues) {
      resCookies.set(cookie);
    }
    for (const cookie of returnedCookies) {
      resCookies.set(cookie);
    }
    return true;
  }

  class MutableRequestCookiesAdapter {
    static wrap(cookies, onUpdateCookies) {
      const responseCookies = new _cookies.ResponseCookies(new Headers);
      for (const cookie of cookies.getAll()) {
        responseCookies.set(cookie);
      }
      let modifiedValues = [];
      const modifiedCookies = new Set;
      const updateResponseCookies = () => {
        const staticGenerationAsyncStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
        if (staticGenerationAsyncStore) {
          staticGenerationAsyncStore.pathWasRevalidated = true;
        }
        const allCookies = responseCookies.getAll();
        modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name));
        if (onUpdateCookies) {
          const serializedCookies = [];
          for (const cookie of modifiedValues) {
            const tempCookies = new _cookies.ResponseCookies(new Headers);
            tempCookies.set(cookie);
            serializedCookies.push(tempCookies.toString());
          }
          onUpdateCookies(serializedCookies);
        }
      };
      return new Proxy(responseCookies, {
        get(target, prop, receiver) {
          switch (prop) {
            case SYMBOL_MODIFY_COOKIE_VALUES:
              return modifiedValues;
            case "delete":
              return function(...args) {
                modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                try {
                  target.delete(...args);
                } finally {
                  updateResponseCookies();
                }
              };
            case "set":
              return function(...args) {
                modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                try {
                  return target.set(...args);
                } finally {
                  updateResponseCookies();
                }
              };
            default:
              return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
        }
      });
    }
  }
});

// node_modules/next/dist/server/web/spec-extension/adapters/headers.js
var require_headers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    HeadersAdapter: function() {
      return HeadersAdapter;
    },
    ReadonlyHeadersError: function() {
      return ReadonlyHeadersError;
    }
  });
  var _reflect = require_reflect();

  class ReadonlyHeadersError extends Error {
    constructor() {
      super("Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers");
    }
    static callable() {
      throw new ReadonlyHeadersError;
    }
  }

  class HeadersAdapter extends Headers {
    constructor(headers) {
      super();
      this.headers = new Proxy(headers, {
        get(target, prop, receiver) {
          if (typeof prop === "symbol") {
            return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
          const lowercased = prop.toLowerCase();
          const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
          if (typeof original === "undefined")
            return;
          return _reflect.ReflectAdapter.get(target, original, receiver);
        },
        set(target, prop, value, receiver) {
          if (typeof prop === "symbol") {
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
          }
          const lowercased = prop.toLowerCase();
          const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
          return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
        },
        has(target, prop) {
          if (typeof prop === "symbol")
            return _reflect.ReflectAdapter.has(target, prop);
          const lowercased = prop.toLowerCase();
          const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
          if (typeof original === "undefined")
            return false;
          return _reflect.ReflectAdapter.has(target, original);
        },
        deleteProperty(target, prop) {
          if (typeof prop === "symbol")
            return _reflect.ReflectAdapter.deleteProperty(target, prop);
          const lowercased = prop.toLowerCase();
          const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
          if (typeof original === "undefined")
            return true;
          return _reflect.ReflectAdapter.deleteProperty(target, original);
        }
      });
    }
    static seal(headers) {
      return new Proxy(headers, {
        get(target, prop, receiver) {
          switch (prop) {
            case "append":
            case "delete":
            case "set":
              return ReadonlyHeadersError.callable;
            default:
              return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
        }
      });
    }
    merge(value) {
      if (Array.isArray(value))
        return value.join(", ");
      return value;
    }
    static from(headers) {
      if (headers instanceof Headers)
        return headers;
      return new HeadersAdapter(headers);
    }
    append(name, value) {
      const existing = this.headers[name];
      if (typeof existing === "string") {
        this.headers[name] = [
          existing,
          value
        ];
      } else if (Array.isArray(existing)) {
        existing.push(value);
      } else {
        this.headers[name] = value;
      }
    }
    delete(name) {
      delete this.headers[name];
    }
    get(name) {
      const value = this.headers[name];
      if (typeof value !== "undefined")
        return this.merge(value);
      return null;
    }
    has(name) {
      return typeof this.headers[name] !== "undefined";
    }
    set(name, value) {
      this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
      for (const [name, value] of this.entries()) {
        callbackfn.call(thisArg, value, name, this);
      }
    }
    *entries() {
      for (const key of Object.keys(this.headers)) {
        const name = key.toLowerCase();
        const value = this.get(name);
        yield [
          name,
          value
        ];
      }
    }
    *keys() {
      for (const key of Object.keys(this.headers)) {
        const name = key.toLowerCase();
        yield name;
      }
    }
    *values() {
      for (const key of Object.keys(this.headers)) {
        const value = this.get(key);
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
  }
});

// node_modules/next/dist/client/components/action-async-storage-instance.js
var require_action_async_storage_instance = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "actionAsyncStorage", {
    enumerable: true,
    get: function() {
      return actionAsyncStorage;
    }
  });
  var _asynclocalstorage = require_async_local_storage();
  var actionAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/action-async-storage.external.js
var require_action_async_storage_external = __commonJS((exports, module) => {
  "TURBOPACK { transition: next-shared }";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "actionAsyncStorage", {
    enumerable: true,
    get: function() {
      return _actionasyncstorageinstance.actionAsyncStorage;
    }
  });
  var _actionasyncstorageinstance = require_action_async_storage_instance();
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactVersion = "18.3.1";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentBatchConfig = {
        transition: null
      };
      var ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
      };
      var ReactCurrentOwner = {
        current: null
      };
      var ReactDebugCurrentFrame = {};
      var currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        {
          currentExtraStackFrame = stack;
        }
      }
      {
        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
          {
            currentExtraStackFrame = stack;
          }
        };
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function() {
          var stack = "";
          if (currentExtraStackFrame) {
            stack += currentExtraStackFrame;
          }
          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || "";
          }
          return stack;
        };
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      {
        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      }
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error("Can't call %s on a component that is not yet mounted. " + "This is a no-op, but it might indicate a bug in your application. " + "Instead, assign to `this.state` directly or define a `state = {};` " + "class property with the desired state in the %s component.", callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
          throw new Error("setState(...): takes an object of state variables to update or a " + "function which returns an object of state variables.");
        }
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in " + "componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see " + "https://github.com/facebook/react/issues/3236)."]
        };
        var defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
              return;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {}
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", componentName, config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function createElement(type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self2 = null;
        var source = null;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config);
            }
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          self2 = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config, children) {
        if (element === null || element === undefined) {
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
        var propName;
        var props = assign({}, element.props);
        var key = element.key;
        var ref = element.ref;
        var self2 = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".";
      var SUBSEPARATOR = ":";
      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          "=": "=0",
          ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        if (typeof element === "object" && element !== null && element.key != null) {
          {
            checkKeyStringCoercion(element.key);
          }
          return escape("" + element.key);
        }
        return index.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === "undefined" || type === "boolean") {
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          var _child = children;
          var mappedChild = callback(_child);
          var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            if (childKey != null) {
              escapedChildKey = escapeUserProvidedKey(childKey) + "/";
            }
            mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              {
                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                  checkKeyStringCoercion(mappedChild.key);
                }
              }
              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
            }
            array.push(mappedChild);
          }
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) {
          for (var i = 0;i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === "function") {
            var iterableChildren = children;
            {
              if (iteratorFn === iterableChildren.entries) {
                if (!didWarnAboutMaps) {
                  warn("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(iterableChildren);
            var step;
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getElementKey(child, ii++);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result = [];
        var count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children)) {
          throw new Error("React.Children.only expected to receive a single React element child.");
        }
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error("Rendering <Context.Consumer.Provider> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Provider> instead?");
                }
                return context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
                }
                return context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                if (!hasWarnedAboutDisplayNameOnConsumer) {
                  warn("Setting `displayName` on Context.Consumer has no effect. " + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                  hasWarnedAboutDisplayNameOnConsumer = true;
                }
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      var Uninitialized = -1;
      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result;
          var thenable = ctor();
          thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved;
              resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected;
              rejected._result = error2;
            }
          });
          if (payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          {
            if (moduleObject === undefined) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + `Instead received: %s

Your code should look like: 
  ` + "const MyComponent = lazy(() => imp" + `ort('./MyComponent'))

` + "Did you accidentally put curly braces around the import?", moduleObject);
            }
          }
          {
            if (!("default" in moduleObject)) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + `Instead received: %s

Your code should look like: 
  ` + "const MyComponent = lazy(() => imp" + "ort('./MyComponent'))", moduleObject);
            }
          }
          return moduleObject.default;
        } else {
          throw payload._result;
        }
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        };
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: true,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                propTypes = newPropTypes;
                Object.defineProperty(lazyType, "propTypes", {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error("forwardRef requires a render function but received a `memo` " + "component. Instead of forwardRef(memo(...)), use " + "memo(forwardRef(...)).");
          } else if (typeof render !== "function") {
            error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error("forwardRef render functions do not support propTypes or defaultProps. " + "Did you accidentally pass a React component?");
            }
          }
        }
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!render.name && !render.displayName) {
                render.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            error("memo: The first argument must be a component. Instead " + "received: %s", type === null ? "null" : typeof type);
          }
        }
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === undefined ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!type.name && !type.displayName) {
                type.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        {
          if (dispatcher === null) {
            error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + ` one of the following reasons:
` + `1. You might have mismatching versions of React and the renderer (such as React DOM)
` + `2. You might be breaking the Rules of Hooks
` + `3. You might have more than one copy of React in the same app
` + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;
            if (realContext.Consumer === Context) {
              error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be " + "removed in a future major release. Did you mean to call useContext(Context) instead?");
            } else if (realContext.Provider === Context) {
              error("Calling useContext(Context.Provider) is not supported. " + "Did you mean to call useContext(Context) instead?");
            }
          }
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return `
` + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split(`
`);
            var controlLines = control.stack.split(`
`);
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
          } else {
            setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name) {
            return `

Check the render method of \`` + name + "`.";
          }
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = `

Check the top-level render call using <` + parentName + ">.";
          }
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        {
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0;i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = "null";
          } else if (isArray(type)) {
            typeString = "array";
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          {
            error("React.createElement: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
        }
        var element = createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2;i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in " + "a future major release. Consider using JSX " + "or use React.createElement() directly instead.");
          }
          Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
              warn("Factory.type is deprecated. Access the class directly " + "before passing it to createFactory.");
              Object.defineProperty(this, "type", {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2;i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        {
          ReactCurrentBatchConfig.transition._updatedFibers = new Set;
        }
        try {
          scope();
        } finally {
          ReactCurrentBatchConfig.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. " + "If this is due to a subscription please re-write it to use React provided hooks. " + "Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      var didWarnAboutMessageChannel = false;
      var enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null) {
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              {
                if (didWarnAboutMessageChannel === false) {
                  didWarnAboutMessageChannel = true;
                  if (typeof MessageChannel === "undefined") {
                    error("This browser does not have a MessageChannel implementation, " + "so enqueuing tasks via await act(async () => ...) will fail. " + "Please file an issue at https://github.com/facebook/react/issues " + "if you encounter this warning.");
                  }
                }
              }
              var channel = new MessageChannel;
              channel.port1.onmessage = callback;
              channel.port2.postMessage(undefined);
            };
          }
        }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0;
      var didWarnNoAwaitAct = false;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          if (ReactCurrentActQueue.current === null) {
            ReactCurrentActQueue.current = [];
          }
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
          var result;
          try {
            ReactCurrentActQueue.isBatchingLegacy = true;
            result = callback();
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                flushActQueue(queue);
              }
            }
          } catch (error2) {
            popActScope(prevActScopeDepth);
            throw error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result !== null && typeof result === "object" && typeof result.then === "function") {
            var thenableResult = result;
            var wasAwaited = false;
            var thenable = {
              then: function(resolve, reject) {
                wasAwaited = true;
                thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth);
                  if (actScopeDepth === 0) {
                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                  } else {
                    resolve(returnValue2);
                  }
                }, function(error2) {
                  popActScope(prevActScopeDepth);
                  reject(error2);
                });
              }
            };
            {
              if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                Promise.resolve().then(function() {}).then(function() {
                  if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error("You called act(async () => ...) without await. " + "This could lead to unexpected testing behaviour, " + "interleaving multiple act calls and mixing their " + "scopes. " + "You should - await act(async () => ...);");
                  }
                });
              }
            }
            return thenable;
          } else {
            var returnValue = result;
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              if (_queue !== null) {
                flushActQueue(_queue);
                ReactCurrentActQueue.current = null;
              }
              var _thenable = {
                then: function(resolve, reject) {
                  if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  } else {
                    resolve(returnValue);
                  }
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        {
          if (prevActScopeDepth !== actScopeDepth - 1) {
            error("You seem to have overlapping act() calls, this is not supported. " + "Be sure to await previous act() calls before making a new one. ");
          }
          actScopeDepth = prevActScopeDepth;
        }
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue = ReactCurrentActQueue.current;
          if (queue !== null) {
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                if (queue.length === 0) {
                  ReactCurrentActQueue.current = null;
                  resolve(returnValue);
                } else {
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                }
              });
            } catch (error2) {
              reject(error2);
            }
          } else {
            resolve(returnValue);
          }
        }
      }
      var isFlushing = false;
      function flushActQueue(queue) {
        {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (;i < queue.length; i++) {
                var callback = queue[i];
                do {
                  callback = callback(true);
                } while (callback !== null);
              }
              queue.length = 0;
            } catch (error2) {
              queue = queue.slice(i + 1);
              throw error2;
            } finally {
              isFlushing = false;
            }
          }
        }
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      exports.act = act;
      exports.cloneElement = cloneElement$1;
      exports.createContext = createContext;
      exports.createElement = createElement$1;
      exports.createFactory = createFactory;
      exports.createRef = createRef;
      exports.forwardRef = forwardRef;
      exports.isValidElement = isValidElement;
      exports.lazy = lazy;
      exports.memo = memo;
      exports.startTransition = startTransition;
      exports.unstable_act = act;
      exports.useCallback = useCallback;
      exports.useContext = useContext;
      exports.useDebugValue = useDebugValue;
      exports.useDeferredValue = useDeferredValue;
      exports.useEffect = useEffect;
      exports.useId = useId;
      exports.useImperativeHandle = useImperativeHandle;
      exports.useInsertionEffect = useInsertionEffect;
      exports.useLayoutEffect = useLayoutEffect;
      exports.useMemo = useMemo;
      exports.useReducer = useReducer;
      exports.useRef = useRef;
      exports.useState = useState;
      exports.useSyncExternalStore = useSyncExternalStore;
      exports.useTransition = useTransition;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development(), 1);
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/next/dist/client/components/hooks-server-context.js
var require_hooks_server_context = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    DynamicServerError: function() {
      return DynamicServerError;
    },
    isDynamicServerError: function() {
      return isDynamicServerError;
    }
  });
  var DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";

  class DynamicServerError extends Error {
    constructor(description) {
      super("Dynamic server usage: " + description);
      this.description = description;
      this.digest = DYNAMIC_ERROR_CODE;
    }
  }
  function isDynamicServerError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
      return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/static-generation-bailout.js
var require_static_generation_bailout = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    StaticGenBailoutError: function() {
      return StaticGenBailoutError;
    },
    isStaticGenBailoutError: function() {
      return isStaticGenBailoutError;
    }
  });
  var NEXT_STATIC_GEN_BAILOUT = "NEXT_STATIC_GEN_BAILOUT";

  class StaticGenBailoutError extends Error {
    constructor(...args) {
      super(...args);
      this.code = NEXT_STATIC_GEN_BAILOUT;
    }
  }
  function isStaticGenBailoutError(error) {
    if (typeof error !== "object" || error === null || !("code" in error)) {
      return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/lib/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    getPathname: function() {
      return getPathname;
    },
    isFullStringUrl: function() {
      return isFullStringUrl;
    },
    parseUrl: function() {
      return parseUrl;
    }
  });
  var DUMMY_ORIGIN = "http://n";
  function getUrlWithoutHost(url) {
    return new URL(url, DUMMY_ORIGIN);
  }
  function getPathname(url) {
    return getUrlWithoutHost(url).pathname;
  }
  function isFullStringUrl(url) {
    return /https?:\/\//.test(url);
  }
  function parseUrl(url) {
    let parsed = undefined;
    try {
      parsed = new URL(url, DUMMY_ORIGIN);
    } catch {}
    return parsed;
  }
});

// node_modules/next/dist/server/app-render/dynamic-rendering.js
var require_dynamic_rendering = __commonJS((exports) => {
  var react = __toESM(require_react(), 1);
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    Postpone: function() {
      return Postpone;
    },
    createPostponedAbortSignal: function() {
      return createPostponedAbortSignal;
    },
    createPrerenderState: function() {
      return createPrerenderState;
    },
    formatDynamicAPIAccesses: function() {
      return formatDynamicAPIAccesses;
    },
    markCurrentScopeAsDynamic: function() {
      return markCurrentScopeAsDynamic;
    },
    trackDynamicDataAccessed: function() {
      return trackDynamicDataAccessed;
    },
    trackDynamicFetch: function() {
      return trackDynamicFetch;
    },
    usedDynamicAPIs: function() {
      return usedDynamicAPIs;
    }
  });
  var _react = /* @__PURE__ */ _interop_require_default(react);
  var _hooksservercontext = require_hooks_server_context();
  var _staticgenerationbailout = require_static_generation_bailout();
  var _url = require_url();
  function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var hasPostpone = typeof _react.default.unstable_postpone === "function";
  function createPrerenderState(isDebugSkeleton) {
    return {
      isDebugSkeleton,
      dynamicAccesses: []
    };
  }
  function markCurrentScopeAsDynamic(store, expression) {
    const pathname = (0, _url.getPathname)(store.urlPathname);
    if (store.isUnstableCacheCallback) {
      return;
    } else if (store.dynamicShouldError) {
      throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (store.prerenderState) {
      postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
      store.revalidate = 0;
      if (store.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
        store.dynamicUsageDescription = expression;
        store.dynamicUsageStack = err.stack;
        throw err;
      }
    }
  }
  function trackDynamicDataAccessed(store, expression) {
    const pathname = (0, _url.getPathname)(store.urlPathname);
    if (store.isUnstableCacheCallback) {
      throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
    } else if (store.dynamicShouldError) {
      throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (store.prerenderState) {
      postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
      store.revalidate = 0;
      if (store.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
        store.dynamicUsageDescription = expression;
        store.dynamicUsageStack = err.stack;
        throw err;
      }
    }
  }
  function Postpone({ reason, prerenderState, pathname }) {
    postponeWithTracking(prerenderState, reason, pathname);
  }
  function trackDynamicFetch(store, expression) {
    if (store.prerenderState) {
      postponeWithTracking(store.prerenderState, expression, store.urlPathname);
    }
  }
  function postponeWithTracking(prerenderState, expression, pathname) {
    assertPostpone();
    const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    prerenderState.dynamicAccesses.push({
      stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,
      expression
    });
    _react.default.unstable_postpone(reason);
  }
  function usedDynamicAPIs(prerenderState) {
    return prerenderState.dynamicAccesses.length > 0;
  }
  function formatDynamicAPIAccesses(prerenderState) {
    return prerenderState.dynamicAccesses.filter((access) => typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack }) => {
      stack = stack.split(`
`).slice(4).filter((line) => {
        if (line.includes("node_modules/next/")) {
          return false;
        }
        if (line.includes(" (<anonymous>)")) {
          return false;
        }
        if (line.includes(" (node:")) {
          return false;
        }
        return true;
      }).join(`
`);
      return `Dynamic API Usage Debug - ${expression}:
${stack}`;
    });
  }
  function assertPostpone() {
    if (!hasPostpone) {
      throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
    }
  }
  function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController;
    try {
      _react.default.unstable_postpone(reason);
    } catch (x) {
      controller.abort(x);
    }
    return controller.signal;
  }
});

// node_modules/next/dist/client/components/draft-mode.js
var require_draft_mode = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "DraftMode", {
    enumerable: true,
    get: function() {
      return DraftMode;
    }
  });
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  var _dynamicrendering = require_dynamic_rendering();

  class DraftMode {
    get isEnabled() {
      return this._provider.isEnabled;
    }
    enable() {
      const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
      if (store) {
        (0, _dynamicrendering.trackDynamicDataAccessed)(store, "draftMode().enable()");
      }
      return this._provider.enable();
    }
    disable() {
      const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
      if (store) {
        (0, _dynamicrendering.trackDynamicDataAccessed)(store, "draftMode().disable()");
      }
      return this._provider.disable();
    }
    constructor(provider) {
      this._provider = provider;
    }
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/request-async-storage-instance.js
var require_request_async_storage_instance = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "requestAsyncStorage", {
    enumerable: true,
    get: function() {
      return requestAsyncStorage;
    }
  });
  var _asynclocalstorage = require_async_local_storage();
  var requestAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/request-async-storage.external.js
var require_request_async_storage_external = __commonJS((exports, module) => {
  "TURBOPACK { transition: next-shared }";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    getExpectedRequestStore: function() {
      return getExpectedRequestStore;
    },
    requestAsyncStorage: function() {
      return _requestasyncstorageinstance.requestAsyncStorage;
    }
  });
  var _requestasyncstorageinstance = require_request_async_storage_instance();
  function getExpectedRequestStore(callingExpression) {
    const store = _requestasyncstorageinstance.requestAsyncStorage.getStore();
    if (store)
      return store;
    throw new Error("`" + callingExpression + "` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context");
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/headers.js
var require_headers2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    cookies: function() {
      return cookies;
    },
    draftMode: function() {
      return draftMode;
    },
    headers: function() {
      return headers;
    }
  });
  var _requestcookies = require_request_cookies();
  var _headers = require_headers();
  var _cookies = require_cookies2();
  var _actionasyncstorageexternal = require_action_async_storage_external();
  var _draftmode = require_draft_mode();
  var _dynamicrendering = require_dynamic_rendering();
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  var _requestasyncstorageexternal = require_request_async_storage_external();
  function headers() {
    const callingExpression = "headers";
    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore) {
      if (staticGenerationStore.forceStatic) {
        return _headers.HeadersAdapter.seal(new Headers({}));
      } else {
        (0, _dynamicrendering.trackDynamicDataAccessed)(staticGenerationStore, callingExpression);
      }
    }
    return (0, _requestasyncstorageexternal.getExpectedRequestStore)(callingExpression).headers;
  }
  function cookies() {
    const callingExpression = "cookies";
    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore) {
      if (staticGenerationStore.forceStatic) {
        return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));
      } else {
        (0, _dynamicrendering.trackDynamicDataAccessed)(staticGenerationStore, callingExpression);
      }
    }
    const requestStore = (0, _requestasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    const asyncActionStore = _actionasyncstorageexternal.actionAsyncStorage.getStore();
    if ((asyncActionStore == null ? undefined : asyncActionStore.isAction) || (asyncActionStore == null ? undefined : asyncActionStore.isAppRoute)) {
      return requestStore.mutableCookies;
    }
    return requestStore.cookies;
  }
  function draftMode() {
    const callingExpression = "draftMode";
    const requestStore = (0, _requestasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    return new _draftmode.DraftMode(requestStore.draftMode);
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/@swc/helpers/cjs/_interop_require_default.cjs
var require__interop_require_default = __commonJS((exports) => {
  exports._ = exports._interop_require_default = _interop_require_default;
  function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js
var require_app_router_context_shared_runtime = __commonJS((exports) => {
  var react = __toESM(require_react(), 1);
  "use client";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    AppRouterContext: function() {
      return AppRouterContext;
    },
    GlobalLayoutRouterContext: function() {
      return GlobalLayoutRouterContext;
    },
    LayoutRouterContext: function() {
      return LayoutRouterContext;
    },
    MissingSlotContext: function() {
      return MissingSlotContext;
    },
    TemplateContext: function() {
      return TemplateContext;
    }
  });
  var _interop_require_default = require__interop_require_default();
  var _react = /* @__PURE__ */ _interop_require_default._(react);
  var AppRouterContext = _react.default.createContext(null);
  var LayoutRouterContext = _react.default.createContext(null);
  var GlobalLayoutRouterContext = _react.default.createContext(null);
  var TemplateContext = _react.default.createContext(null);
  if (true) {
    AppRouterContext.displayName = "AppRouterContext";
    LayoutRouterContext.displayName = "LayoutRouterContext";
    GlobalLayoutRouterContext.displayName = "GlobalLayoutRouterContext";
    TemplateContext.displayName = "TemplateContext";
  }
  var MissingSlotContext = _react.default.createContext(new Set);
});

// node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js
var require_hooks_client_context_shared_runtime = __commonJS((exports) => {
  var _react = __toESM(require_react(), 1);
  "use client";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    PathParamsContext: function() {
      return PathParamsContext;
    },
    PathnameContext: function() {
      return PathnameContext;
    },
    SearchParamsContext: function() {
      return SearchParamsContext;
    }
  });
  var SearchParamsContext = (0, _react.createContext)(null);
  var PathnameContext = (0, _react.createContext)(null);
  var PathParamsContext = (0, _react.createContext)(null);
  if (true) {
    SearchParamsContext.displayName = "SearchParamsContext";
    PathnameContext.displayName = "PathnameContext";
    PathParamsContext.displayName = "PathParamsContext";
  }
});

// node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js
var require_get_segment_value = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "getSegmentValue", {
    enumerable: true,
    get: function() {
      return getSegmentValue;
    }
  });
  function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/shared/lib/segment.js
var require_segment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    DEFAULT_SEGMENT_KEY: function() {
      return DEFAULT_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function() {
      return PAGE_SEGMENT_KEY;
    },
    isGroupSegment: function() {
      return isGroupSegment;
    }
  });
  function isGroupSegment(segment) {
    return segment[0] === "(" && segment.endsWith(")");
  }
  var PAGE_SEGMENT_KEY = "__PAGE__";
  var DEFAULT_SEGMENT_KEY = "__DEFAULT__";
});

// node_modules/next/dist/client/components/redirect-status-code.js
var require_redirect_status_code = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "RedirectStatusCode", {
    enumerable: true,
    get: function() {
      return RedirectStatusCode;
    }
  });
  var RedirectStatusCode;
  (function(RedirectStatusCode2) {
    RedirectStatusCode2[RedirectStatusCode2["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode2[RedirectStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode2[RedirectStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  })(RedirectStatusCode || (RedirectStatusCode = {}));
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/redirect.js
var require_redirect = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    RedirectType: function() {
      return RedirectType;
    },
    getRedirectError: function() {
      return getRedirectError;
    },
    getRedirectStatusCodeFromError: function() {
      return getRedirectStatusCodeFromError;
    },
    getRedirectTypeFromError: function() {
      return getRedirectTypeFromError;
    },
    getURLFromRedirectError: function() {
      return getURLFromRedirectError;
    },
    isRedirectError: function() {
      return isRedirectError;
    },
    permanentRedirect: function() {
      return permanentRedirect;
    },
    redirect: function() {
      return redirect;
    }
  });
  var _requestasyncstorageexternal = require_request_async_storage_external();
  var _actionasyncstorageexternal = require_action_async_storage_external();
  var _redirectstatuscode = require_redirect_status_code();
  var REDIRECT_ERROR_CODE = "NEXT_REDIRECT";
  var RedirectType;
  (function(RedirectType2) {
    RedirectType2["push"] = "push";
    RedirectType2["replace"] = "replace";
  })(RedirectType || (RedirectType = {}));
  function getRedirectError(url, type, statusCode) {
    if (statusCode === undefined)
      statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
    const error = new Error(REDIRECT_ERROR_CODE);
    error.digest = REDIRECT_ERROR_CODE + ";" + type + ";" + url + ";" + statusCode + ";";
    const requestStore = _requestasyncstorageexternal.requestAsyncStorage.getStore();
    if (requestStore) {
      error.mutableCookies = requestStore.mutableCookies;
    }
    return error;
  }
  function redirect(url, type) {
    if (type === undefined)
      type = "replace";
    const actionStore = _actionasyncstorageexternal.actionAsyncStorage.getStore();
    throw getRedirectError(url, type, (actionStore == null ? undefined : actionStore.isAction) ? _redirectstatuscode.RedirectStatusCode.SeeOther : _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
  }
  function permanentRedirect(url, type) {
    if (type === undefined)
      type = "replace";
    const actionStore = _actionasyncstorageexternal.actionAsyncStorage.getStore();
    throw getRedirectError(url, type, (actionStore == null ? undefined : actionStore.isAction) ? _redirectstatuscode.RedirectStatusCode.SeeOther : _redirectstatuscode.RedirectStatusCode.PermanentRedirect);
  }
  function isRedirectError(error) {
    if (typeof error !== "object" || error === null || !("digest" in error) || typeof error.digest !== "string") {
      return false;
    }
    const [errorCode, type, destination, status] = error.digest.split(";", 4);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === "replace" || type === "push") && typeof destination === "string" && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;
  }
  function getURLFromRedirectError(error) {
    if (!isRedirectError(error))
      return null;
    return error.digest.split(";", 3)[2];
  }
  function getRedirectTypeFromError(error) {
    if (!isRedirectError(error)) {
      throw new Error("Not a redirect error");
    }
    return error.digest.split(";", 2)[1];
  }
  function getRedirectStatusCodeFromError(error) {
    if (!isRedirectError(error)) {
      throw new Error("Not a redirect error");
    }
    return Number(error.digest.split(";", 4)[3]);
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/not-found.js
var require_not_found = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    isNotFoundError: function() {
      return isNotFoundError;
    },
    notFound: function() {
      return notFound;
    }
  });
  var NOT_FOUND_ERROR_CODE = "NEXT_NOT_FOUND";
  function notFound() {
    const error = new Error(NOT_FOUND_ERROR_CODE);
    error.digest = NOT_FOUND_ERROR_CODE;
    throw error;
  }
  function isNotFoundError(error) {
    if (typeof error !== "object" || error === null || !("digest" in error)) {
      return false;
    }
    return error.digest === NOT_FOUND_ERROR_CODE;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/navigation.react-server.js
var require_navigation_react_server = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    ReadonlyURLSearchParams: function() {
      return ReadonlyURLSearchParams;
    },
    RedirectType: function() {
      return _redirect.RedirectType;
    },
    notFound: function() {
      return _notfound.notFound;
    },
    permanentRedirect: function() {
      return _redirect.permanentRedirect;
    },
    redirect: function() {
      return _redirect.redirect;
    }
  });
  var _redirect = require_redirect();
  var _notfound = require_not_found();

  class ReadonlyURLSearchParamsError extends Error {
    constructor() {
      super("Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams");
    }
  }

  class ReadonlyURLSearchParams extends URLSearchParams {
    append() {
      throw new ReadonlyURLSearchParamsError;
    }
    delete() {
      throw new ReadonlyURLSearchParamsError;
    }
    set() {
      throw new ReadonlyURLSearchParamsError;
    }
    sort() {
      throw new ReadonlyURLSearchParamsError;
    }
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs
var require__interop_require_wildcard = __commonJS((exports) => {
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  exports._ = exports._interop_require_wildcard = _interop_require_wildcard;
  function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule)
      return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function")
      return { default: obj };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj))
      return cache.get(obj);
    var newObj = { __proto__: null };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set))
          Object.defineProperty(newObj, key, desc);
        else
          newObj[key] = obj[key];
      }
    }
    newObj.default = obj;
    if (cache)
      cache.set(obj, newObj);
    return newObj;
  }
});

// node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js
var require_server_inserted_html_shared_runtime = __commonJS((exports) => {
  var react = __toESM(require_react(), 1);
  "use client";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    ServerInsertedHTMLContext: function() {
      return ServerInsertedHTMLContext;
    },
    useServerInsertedHTML: function() {
      return useServerInsertedHTML;
    }
  });
  var _interop_require_wildcard = require__interop_require_wildcard();
  var _react = /* @__PURE__ */ _interop_require_wildcard._(react);
  var ServerInsertedHTMLContext = /* @__PURE__ */ _react.default.createContext(null);
  function useServerInsertedHTML(callback) {
    const addInsertedServerHTMLCallback = (0, _react.useContext)(ServerInsertedHTMLContext);
    if (addInsertedServerHTMLCallback) {
      addInsertedServerHTMLCallback(callback);
    }
  }
});

// node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js
var require_bailout_to_csr = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    BailoutToCSRError: function() {
      return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
      return isBailoutToCSRError;
    }
  });
  var BAILOUT_TO_CSR = "BAILOUT_TO_CLIENT_SIDE_RENDERING";

  class BailoutToCSRError extends Error {
    constructor(reason) {
      super("Bail out to client-side rendering: " + reason);
      this.reason = reason;
      this.digest = BAILOUT_TO_CSR;
    }
  }
  function isBailoutToCSRError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err)) {
      return false;
    }
    return err.digest === BAILOUT_TO_CSR;
  }
});

// node_modules/next/dist/client/components/bailout-to-client-rendering.js
var require_bailout_to_client_rendering = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "bailoutToClientRendering", {
    enumerable: true,
    get: function() {
      return bailoutToClientRendering;
    }
  });
  var _bailouttocsr = require_bailout_to_csr();
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  function bailoutToClientRendering(reason) {
    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? undefined : staticGenerationStore.forceStatic)
      return;
    if (staticGenerationStore == null ? undefined : staticGenerationStore.isStaticGeneration)
      throw new _bailouttocsr.BailoutToCSRError(reason);
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/client/components/navigation.js
var require_navigation = __commonJS((exports, module) => {
  var _react = __toESM(require_react(), 1);
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    ReadonlyURLSearchParams: function() {
      return _navigationreactserver.ReadonlyURLSearchParams;
    },
    RedirectType: function() {
      return _navigationreactserver.RedirectType;
    },
    ServerInsertedHTMLContext: function() {
      return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;
    },
    notFound: function() {
      return _navigationreactserver.notFound;
    },
    permanentRedirect: function() {
      return _navigationreactserver.permanentRedirect;
    },
    redirect: function() {
      return _navigationreactserver.redirect;
    },
    useParams: function() {
      return useParams;
    },
    usePathname: function() {
      return usePathname;
    },
    useRouter: function() {
      return useRouter;
    },
    useSearchParams: function() {
      return useSearchParams;
    },
    useSelectedLayoutSegment: function() {
      return useSelectedLayoutSegment;
    },
    useSelectedLayoutSegments: function() {
      return useSelectedLayoutSegments;
    },
    useServerInsertedHTML: function() {
      return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;
    }
  });
  var _approutercontextsharedruntime = require_app_router_context_shared_runtime();
  var _hooksclientcontextsharedruntime = require_hooks_client_context_shared_runtime();
  var _getsegmentvalue = require_get_segment_value();
  var _segment = require_segment();
  var _navigationreactserver = require_navigation_react_server();
  var _serverinsertedhtmlsharedruntime = require_server_inserted_html_shared_runtime();
  function useSearchParams() {
    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);
    const readonlySearchParams = (0, _react.useMemo)(() => {
      if (!searchParams) {
        return null;
      }
      return new _navigationreactserver.ReadonlyURLSearchParams(searchParams);
    }, [
      searchParams
    ]);
    if (typeof window === "undefined") {
      const { bailoutToClientRendering } = require_bailout_to_client_rendering();
      bailoutToClientRendering("useSearchParams()");
    }
    return readonlySearchParams;
  }
  function usePathname() {
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
  }
  function useRouter() {
    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);
    if (router === null) {
      throw new Error("invariant expected app router to be mounted");
    }
    return router;
  }
  function useParams() {
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);
  }
  function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
    if (first === undefined)
      first = true;
    if (segmentPath === undefined)
      segmentPath = [];
    let node;
    if (first) {
      node = tree[1][parallelRouteKey];
    } else {
      const parallelRoutes = tree[1];
      var _parallelRoutes_children;
      node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node)
      return segmentPath;
    const segment = node[0];
    const segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
    if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {
      return segmentPath;
    }
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
  }
  function useSelectedLayoutSegments(parallelRouteKey) {
    if (parallelRouteKey === undefined)
      parallelRouteKey = "children";
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    if (!context)
      return null;
    return getSelectedLayoutSegmentPath(context.tree, parallelRouteKey);
  }
  function useSelectedLayoutSegment(parallelRouteKey) {
    if (parallelRouteKey === undefined)
      parallelRouteKey = "children";
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {
      return null;
    }
    const selectedLayoutSegment = parallelRouteKey === "children" ? selectedLayoutSegments[0] : selectedLayoutSegments[selectedLayoutSegments.length - 1];
    return selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY ? null : selectedLayoutSegment;
  }
  if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", { value: true });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
  }
});

// node_modules/next/dist/lib/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    ACTION_SUFFIX: function() {
      return ACTION_SUFFIX;
    },
    APP_DIR_ALIAS: function() {
      return APP_DIR_ALIAS;
    },
    CACHE_ONE_YEAR: function() {
      return CACHE_ONE_YEAR;
    },
    DOT_NEXT_ALIAS: function() {
      return DOT_NEXT_ALIAS;
    },
    ESLINT_DEFAULT_DIRS: function() {
      return ESLINT_DEFAULT_DIRS;
    },
    GSP_NO_RETURNED_VALUE: function() {
      return GSP_NO_RETURNED_VALUE;
    },
    GSSP_COMPONENT_MEMBER_ERROR: function() {
      return GSSP_COMPONENT_MEMBER_ERROR;
    },
    GSSP_NO_RETURNED_VALUE: function() {
      return GSSP_NO_RETURNED_VALUE;
    },
    INSTRUMENTATION_HOOK_FILENAME: function() {
      return INSTRUMENTATION_HOOK_FILENAME;
    },
    MIDDLEWARE_FILENAME: function() {
      return MIDDLEWARE_FILENAME;
    },
    MIDDLEWARE_LOCATION_REGEXP: function() {
      return MIDDLEWARE_LOCATION_REGEXP;
    },
    NEXT_BODY_SUFFIX: function() {
      return NEXT_BODY_SUFFIX;
    },
    NEXT_CACHE_IMPLICIT_TAG_ID: function() {
      return NEXT_CACHE_IMPLICIT_TAG_ID;
    },
    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
      return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
    },
    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
      return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
    },
    NEXT_CACHE_SOFT_TAGS_HEADER: function() {
      return NEXT_CACHE_SOFT_TAGS_HEADER;
    },
    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
      return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
    },
    NEXT_CACHE_TAGS_HEADER: function() {
      return NEXT_CACHE_TAGS_HEADER;
    },
    NEXT_CACHE_TAG_MAX_ITEMS: function() {
      return NEXT_CACHE_TAG_MAX_ITEMS;
    },
    NEXT_CACHE_TAG_MAX_LENGTH: function() {
      return NEXT_CACHE_TAG_MAX_LENGTH;
    },
    NEXT_DATA_SUFFIX: function() {
      return NEXT_DATA_SUFFIX;
    },
    NEXT_INTERCEPTION_MARKER_PREFIX: function() {
      return NEXT_INTERCEPTION_MARKER_PREFIX;
    },
    NEXT_META_SUFFIX: function() {
      return NEXT_META_SUFFIX;
    },
    NEXT_QUERY_PARAM_PREFIX: function() {
      return NEXT_QUERY_PARAM_PREFIX;
    },
    NON_STANDARD_NODE_ENV: function() {
      return NON_STANDARD_NODE_ENV;
    },
    PAGES_DIR_ALIAS: function() {
      return PAGES_DIR_ALIAS;
    },
    PRERENDER_REVALIDATE_HEADER: function() {
      return PRERENDER_REVALIDATE_HEADER;
    },
    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
      return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
    },
    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
      return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
    },
    ROOT_DIR_ALIAS: function() {
      return ROOT_DIR_ALIAS;
    },
    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
      return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
    },
    RSC_ACTION_ENCRYPTION_ALIAS: function() {
      return RSC_ACTION_ENCRYPTION_ALIAS;
    },
    RSC_ACTION_PROXY_ALIAS: function() {
      return RSC_ACTION_PROXY_ALIAS;
    },
    RSC_ACTION_VALIDATE_ALIAS: function() {
      return RSC_ACTION_VALIDATE_ALIAS;
    },
    RSC_MOD_REF_PROXY_ALIAS: function() {
      return RSC_MOD_REF_PROXY_ALIAS;
    },
    RSC_PREFETCH_SUFFIX: function() {
      return RSC_PREFETCH_SUFFIX;
    },
    RSC_SUFFIX: function() {
      return RSC_SUFFIX;
    },
    SERVER_PROPS_EXPORT_ERROR: function() {
      return SERVER_PROPS_EXPORT_ERROR;
    },
    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
      return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
    },
    SERVER_PROPS_SSG_CONFLICT: function() {
      return SERVER_PROPS_SSG_CONFLICT;
    },
    SERVER_RUNTIME: function() {
      return SERVER_RUNTIME;
    },
    SSG_FALLBACK_EXPORT_ERROR: function() {
      return SSG_FALLBACK_EXPORT_ERROR;
    },
    SSG_GET_INITIAL_PROPS_CONFLICT: function() {
      return SSG_GET_INITIAL_PROPS_CONFLICT;
    },
    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
      return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
    },
    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
      return UNSTABLE_REVALIDATE_RENAME_ERROR;
    },
    WEBPACK_LAYERS: function() {
      return WEBPACK_LAYERS;
    },
    WEBPACK_RESOURCE_QUERIES: function() {
      return WEBPACK_RESOURCE_QUERIES;
    }
  });
  var NEXT_QUERY_PARAM_PREFIX = "nxtP";
  var NEXT_INTERCEPTION_MARKER_PREFIX = "nxtI";
  var PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
  var PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
  var RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
  var RSC_SUFFIX = ".rsc";
  var ACTION_SUFFIX = ".action";
  var NEXT_DATA_SUFFIX = ".json";
  var NEXT_META_SUFFIX = ".meta";
  var NEXT_BODY_SUFFIX = ".body";
  var NEXT_CACHE_TAGS_HEADER = "x-next-cache-tags";
  var NEXT_CACHE_SOFT_TAGS_HEADER = "x-next-cache-soft-tags";
  var NEXT_CACHE_REVALIDATED_TAGS_HEADER = "x-next-revalidated-tags";
  var NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = "x-next-revalidate-tag-token";
  var NEXT_CACHE_TAG_MAX_ITEMS = 128;
  var NEXT_CACHE_TAG_MAX_LENGTH = 256;
  var NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
  var NEXT_CACHE_IMPLICIT_TAG_ID = "_N_T_";
  var CACHE_ONE_YEAR = 31536000;
  var MIDDLEWARE_FILENAME = "middleware";
  var MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
  var INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
  var PAGES_DIR_ALIAS = "private-next-pages";
  var DOT_NEXT_ALIAS = "private-dot-next";
  var ROOT_DIR_ALIAS = "private-next-root-dir";
  var APP_DIR_ALIAS = "private-next-app-dir";
  var RSC_MOD_REF_PROXY_ALIAS = "private-next-rsc-mod-ref-proxy";
  var RSC_ACTION_VALIDATE_ALIAS = "private-next-rsc-action-validate";
  var RSC_ACTION_PROXY_ALIAS = "private-next-rsc-server-reference";
  var RSC_ACTION_ENCRYPTION_ALIAS = "private-next-rsc-action-encryption";
  var RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
  var PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
  var SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
  var SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
  var SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
  var STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
  var SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
  var GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
  var GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
  var UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\n" + "Please use `revalidate` instead.";
  var GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
  var NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
  var SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
  var ESLINT_DEFAULT_DIRS = [
    "app",
    "pages",
    "components",
    "lib",
    "src"
  ];
  var SERVER_RUNTIME = {
    edge: "edge",
    experimentalEdge: "experimental-edge",
    nodejs: "nodejs"
  };
  var WEBPACK_LAYERS_NAMES = {
    shared: "shared",
    reactServerComponents: "rsc",
    serverSideRendering: "ssr",
    actionBrowser: "action-browser",
    api: "api",
    middleware: "middleware",
    instrument: "instrument",
    edgeAsset: "edge-asset",
    appPagesBrowser: "app-pages-browser",
    appMetadataRoute: "app-metadata-route",
    appRouteHandler: "app-route-handler"
  };
  var WEBPACK_LAYERS = {
    ...WEBPACK_LAYERS_NAMES,
    GROUP: {
      serverOnly: [
        WEBPACK_LAYERS_NAMES.reactServerComponents,
        WEBPACK_LAYERS_NAMES.actionBrowser,
        WEBPACK_LAYERS_NAMES.appMetadataRoute,
        WEBPACK_LAYERS_NAMES.appRouteHandler,
        WEBPACK_LAYERS_NAMES.instrument
      ],
      clientOnly: [
        WEBPACK_LAYERS_NAMES.serverSideRendering,
        WEBPACK_LAYERS_NAMES.appPagesBrowser
      ],
      nonClientServerTarget: [
        WEBPACK_LAYERS_NAMES.middleware,
        WEBPACK_LAYERS_NAMES.api
      ],
      app: [
        WEBPACK_LAYERS_NAMES.reactServerComponents,
        WEBPACK_LAYERS_NAMES.actionBrowser,
        WEBPACK_LAYERS_NAMES.appMetadataRoute,
        WEBPACK_LAYERS_NAMES.appRouteHandler,
        WEBPACK_LAYERS_NAMES.serverSideRendering,
        WEBPACK_LAYERS_NAMES.appPagesBrowser,
        WEBPACK_LAYERS_NAMES.shared,
        WEBPACK_LAYERS_NAMES.instrument
      ]
    }
  };
  var WEBPACK_RESOURCE_QUERIES = {
    edgeSSREntry: "__next_edge_ssr_entry__",
    metadata: "__next_metadata__",
    metadataRoute: "__next_metadata_route__",
    metadataImageMeta: "__next_metadata_image_meta__"
  };
});

// node_modules/next/dist/server/lib/trace/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    AppRenderSpan: function() {
      return AppRenderSpan;
    },
    AppRouteRouteHandlersSpan: function() {
      return AppRouteRouteHandlersSpan;
    },
    BaseServerSpan: function() {
      return BaseServerSpan;
    },
    LoadComponentsSpan: function() {
      return LoadComponentsSpan;
    },
    LogSpanAllowList: function() {
      return LogSpanAllowList;
    },
    MiddlewareSpan: function() {
      return MiddlewareSpan;
    },
    NextNodeServerSpan: function() {
      return NextNodeServerSpan;
    },
    NextServerSpan: function() {
      return NextServerSpan;
    },
    NextVanillaSpanAllowlist: function() {
      return NextVanillaSpanAllowlist;
    },
    NodeSpan: function() {
      return NodeSpan;
    },
    RenderSpan: function() {
      return RenderSpan;
    },
    ResolveMetadataSpan: function() {
      return ResolveMetadataSpan;
    },
    RouterSpan: function() {
      return RouterSpan;
    },
    StartServerSpan: function() {
      return StartServerSpan;
    }
  });
  var BaseServerSpan;
  (function(BaseServerSpan2) {
    BaseServerSpan2["handleRequest"] = "BaseServer.handleRequest";
    BaseServerSpan2["run"] = "BaseServer.run";
    BaseServerSpan2["pipe"] = "BaseServer.pipe";
    BaseServerSpan2["getStaticHTML"] = "BaseServer.getStaticHTML";
    BaseServerSpan2["render"] = "BaseServer.render";
    BaseServerSpan2["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
    BaseServerSpan2["renderToResponse"] = "BaseServer.renderToResponse";
    BaseServerSpan2["renderToHTML"] = "BaseServer.renderToHTML";
    BaseServerSpan2["renderError"] = "BaseServer.renderError";
    BaseServerSpan2["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
    BaseServerSpan2["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
    BaseServerSpan2["render404"] = "BaseServer.render404";
  })(BaseServerSpan || (BaseServerSpan = {}));
  var LoadComponentsSpan;
  (function(LoadComponentsSpan2) {
    LoadComponentsSpan2["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
    LoadComponentsSpan2["loadComponents"] = "LoadComponents.loadComponents";
  })(LoadComponentsSpan || (LoadComponentsSpan = {}));
  var NextServerSpan;
  (function(NextServerSpan2) {
    NextServerSpan2["getRequestHandler"] = "NextServer.getRequestHandler";
    NextServerSpan2["getServer"] = "NextServer.getServer";
    NextServerSpan2["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
    NextServerSpan2["createServer"] = "createServer.createServer";
  })(NextServerSpan || (NextServerSpan = {}));
  var NextNodeServerSpan;
  (function(NextNodeServerSpan2) {
    NextNodeServerSpan2["compression"] = "NextNodeServer.compression";
    NextNodeServerSpan2["getBuildId"] = "NextNodeServer.getBuildId";
    NextNodeServerSpan2["createComponentTree"] = "NextNodeServer.createComponentTree";
    NextNodeServerSpan2["clientComponentLoading"] = "NextNodeServer.clientComponentLoading";
    NextNodeServerSpan2["getLayoutOrPageModule"] = "NextNodeServer.getLayoutOrPageModule";
    NextNodeServerSpan2["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
    NextNodeServerSpan2["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
    NextNodeServerSpan2["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
    NextNodeServerSpan2["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
    NextNodeServerSpan2["sendRenderResult"] = "NextNodeServer.sendRenderResult";
    NextNodeServerSpan2["proxyRequest"] = "NextNodeServer.proxyRequest";
    NextNodeServerSpan2["runApi"] = "NextNodeServer.runApi";
    NextNodeServerSpan2["render"] = "NextNodeServer.render";
    NextNodeServerSpan2["renderHTML"] = "NextNodeServer.renderHTML";
    NextNodeServerSpan2["imageOptimizer"] = "NextNodeServer.imageOptimizer";
    NextNodeServerSpan2["getPagePath"] = "NextNodeServer.getPagePath";
    NextNodeServerSpan2["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
    NextNodeServerSpan2["findPageComponents"] = "NextNodeServer.findPageComponents";
    NextNodeServerSpan2["getFontManifest"] = "NextNodeServer.getFontManifest";
    NextNodeServerSpan2["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
    NextNodeServerSpan2["getRequestHandler"] = "NextNodeServer.getRequestHandler";
    NextNodeServerSpan2["renderToHTML"] = "NextNodeServer.renderToHTML";
    NextNodeServerSpan2["renderError"] = "NextNodeServer.renderError";
    NextNodeServerSpan2["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
    NextNodeServerSpan2["render404"] = "NextNodeServer.render404";
    NextNodeServerSpan2["startResponse"] = "NextNodeServer.startResponse";
    NextNodeServerSpan2["route"] = "route";
    NextNodeServerSpan2["onProxyReq"] = "onProxyReq";
    NextNodeServerSpan2["apiResolver"] = "apiResolver";
    NextNodeServerSpan2["internalFetch"] = "internalFetch";
  })(NextNodeServerSpan || (NextNodeServerSpan = {}));
  var StartServerSpan;
  (function(StartServerSpan2) {
    StartServerSpan2["startServer"] = "startServer.startServer";
  })(StartServerSpan || (StartServerSpan = {}));
  var RenderSpan;
  (function(RenderSpan2) {
    RenderSpan2["getServerSideProps"] = "Render.getServerSideProps";
    RenderSpan2["getStaticProps"] = "Render.getStaticProps";
    RenderSpan2["renderToString"] = "Render.renderToString";
    RenderSpan2["renderDocument"] = "Render.renderDocument";
    RenderSpan2["createBodyResult"] = "Render.createBodyResult";
  })(RenderSpan || (RenderSpan = {}));
  var AppRenderSpan;
  (function(AppRenderSpan2) {
    AppRenderSpan2["renderToString"] = "AppRender.renderToString";
    AppRenderSpan2["renderToReadableStream"] = "AppRender.renderToReadableStream";
    AppRenderSpan2["getBodyResult"] = "AppRender.getBodyResult";
    AppRenderSpan2["fetch"] = "AppRender.fetch";
  })(AppRenderSpan || (AppRenderSpan = {}));
  var RouterSpan;
  (function(RouterSpan2) {
    RouterSpan2["executeRoute"] = "Router.executeRoute";
  })(RouterSpan || (RouterSpan = {}));
  var NodeSpan;
  (function(NodeSpan2) {
    NodeSpan2["runHandler"] = "Node.runHandler";
  })(NodeSpan || (NodeSpan = {}));
  var AppRouteRouteHandlersSpan;
  (function(AppRouteRouteHandlersSpan2) {
    AppRouteRouteHandlersSpan2["runHandler"] = "AppRouteRouteHandlers.runHandler";
  })(AppRouteRouteHandlersSpan || (AppRouteRouteHandlersSpan = {}));
  var ResolveMetadataSpan;
  (function(ResolveMetadataSpan2) {
    ResolveMetadataSpan2["generateMetadata"] = "ResolveMetadata.generateMetadata";
    ResolveMetadataSpan2["generateViewport"] = "ResolveMetadata.generateViewport";
  })(ResolveMetadataSpan || (ResolveMetadataSpan = {}));
  var MiddlewareSpan;
  (function(MiddlewareSpan2) {
    MiddlewareSpan2["execute"] = "Middleware.execute";
  })(MiddlewareSpan || (MiddlewareSpan = {}));
  var NextVanillaSpanAllowlist = [
    "Middleware.execute",
    "BaseServer.handleRequest",
    "Render.getServerSideProps",
    "Render.getStaticProps",
    "AppRender.fetch",
    "AppRender.getBodyResult",
    "Render.renderDocument",
    "Node.runHandler",
    "AppRouteRouteHandlers.runHandler",
    "ResolveMetadata.generateMetadata",
    "ResolveMetadata.generateViewport",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.findPageComponents",
    "NextNodeServer.getLayoutOrPageModule",
    "NextNodeServer.startResponse",
    "NextNodeServer.clientComponentLoading"
  ];
  var LogSpanAllowList = [
    "NextNodeServer.findPageComponents",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.clientComponentLoading"
  ];
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
    var _a;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName](...args);
  }
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {};
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {}
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback) {}
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {}
    removeCallback(_callback) {}
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {}
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {}
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {}
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {}
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/next/dist/compiled/@opentelemetry/api/index.js
var require_api = __commonJS((exports, module) => {
  var __dirname = "/Users/bebejane/Projects/next-dato-utils/node_modules/next/dist/compiled/@opentelemetry/api";
  (() => {
    var e = { 491: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.ContextAPI = undefined;
      const n = r2(223);
      const a = r2(172);
      const o = r2(930);
      const i = "context";
      const c = new n.NoopContextManager;

      class ContextAPI {
        constructor() {}
        static getInstance() {
          if (!this._instance) {
            this._instance = new ContextAPI;
          }
          return this._instance;
        }
        setGlobalContextManager(e3) {
          return (0, a.registerGlobal)(i, e3, o.DiagAPI.instance());
        }
        active() {
          return this._getContextManager().active();
        }
        with(e3, t3, r3, ...n2) {
          return this._getContextManager().with(e3, t3, r3, ...n2);
        }
        bind(e3, t3) {
          return this._getContextManager().bind(e3, t3);
        }
        _getContextManager() {
          return (0, a.getGlobal)(i) || c;
        }
        disable() {
          this._getContextManager().disable();
          (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
        }
      }
      t2.ContextAPI = ContextAPI;
    }, 930: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.DiagAPI = undefined;
      const n = r2(56);
      const a = r2(912);
      const o = r2(957);
      const i = r2(172);
      const c = "diag";

      class DiagAPI {
        constructor() {
          function _logProxy(e4) {
            return function(...t3) {
              const r3 = (0, i.getGlobal)("diag");
              if (!r3)
                return;
              return r3[e4](...t3);
            };
          }
          const e3 = this;
          const setLogger = (t3, r3 = { logLevel: o.DiagLogLevel.INFO }) => {
            var n2, c2, s;
            if (t3 === e3) {
              const t4 = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
              e3.error((n2 = t4.stack) !== null && n2 !== undefined ? n2 : t4.message);
              return false;
            }
            if (typeof r3 === "number") {
              r3 = { logLevel: r3 };
            }
            const u = (0, i.getGlobal)("diag");
            const l = (0, a.createLogLevelDiagLogger)((c2 = r3.logLevel) !== null && c2 !== undefined ? c2 : o.DiagLogLevel.INFO, t3);
            if (u && !r3.suppressOverrideMessage) {
              const e4 = (s = new Error().stack) !== null && s !== undefined ? s : "<failed to generate stacktrace>";
              u.warn(`Current logger will be overwritten from ${e4}`);
              l.warn(`Current logger will overwrite one already registered from ${e4}`);
            }
            return (0, i.registerGlobal)("diag", l, e3, true);
          };
          e3.setLogger = setLogger;
          e3.disable = () => {
            (0, i.unregisterGlobal)(c, e3);
          };
          e3.createComponentLogger = (e4) => new n.DiagComponentLogger(e4);
          e3.verbose = _logProxy("verbose");
          e3.debug = _logProxy("debug");
          e3.info = _logProxy("info");
          e3.warn = _logProxy("warn");
          e3.error = _logProxy("error");
        }
        static instance() {
          if (!this._instance) {
            this._instance = new DiagAPI;
          }
          return this._instance;
        }
      }
      t2.DiagAPI = DiagAPI;
    }, 653: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.MetricsAPI = undefined;
      const n = r2(660);
      const a = r2(172);
      const o = r2(930);
      const i = "metrics";

      class MetricsAPI {
        constructor() {}
        static getInstance() {
          if (!this._instance) {
            this._instance = new MetricsAPI;
          }
          return this._instance;
        }
        setGlobalMeterProvider(e3) {
          return (0, a.registerGlobal)(i, e3, o.DiagAPI.instance());
        }
        getMeterProvider() {
          return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;
        }
        getMeter(e3, t3, r3) {
          return this.getMeterProvider().getMeter(e3, t3, r3);
        }
        disable() {
          (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
        }
      }
      t2.MetricsAPI = MetricsAPI;
    }, 181: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.PropagationAPI = undefined;
      const n = r2(172);
      const a = r2(874);
      const o = r2(194);
      const i = r2(277);
      const c = r2(369);
      const s = r2(930);
      const u = "propagation";
      const l = new a.NoopTextMapPropagator;

      class PropagationAPI {
        constructor() {
          this.createBaggage = c.createBaggage;
          this.getBaggage = i.getBaggage;
          this.getActiveBaggage = i.getActiveBaggage;
          this.setBaggage = i.setBaggage;
          this.deleteBaggage = i.deleteBaggage;
        }
        static getInstance() {
          if (!this._instance) {
            this._instance = new PropagationAPI;
          }
          return this._instance;
        }
        setGlobalPropagator(e3) {
          return (0, n.registerGlobal)(u, e3, s.DiagAPI.instance());
        }
        inject(e3, t3, r3 = o.defaultTextMapSetter) {
          return this._getGlobalPropagator().inject(e3, t3, r3);
        }
        extract(e3, t3, r3 = o.defaultTextMapGetter) {
          return this._getGlobalPropagator().extract(e3, t3, r3);
        }
        fields() {
          return this._getGlobalPropagator().fields();
        }
        disable() {
          (0, n.unregisterGlobal)(u, s.DiagAPI.instance());
        }
        _getGlobalPropagator() {
          return (0, n.getGlobal)(u) || l;
        }
      }
      t2.PropagationAPI = PropagationAPI;
    }, 997: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.TraceAPI = undefined;
      const n = r2(172);
      const a = r2(846);
      const o = r2(139);
      const i = r2(607);
      const c = r2(930);
      const s = "trace";

      class TraceAPI {
        constructor() {
          this._proxyTracerProvider = new a.ProxyTracerProvider;
          this.wrapSpanContext = o.wrapSpanContext;
          this.isSpanContextValid = o.isSpanContextValid;
          this.deleteSpan = i.deleteSpan;
          this.getSpan = i.getSpan;
          this.getActiveSpan = i.getActiveSpan;
          this.getSpanContext = i.getSpanContext;
          this.setSpan = i.setSpan;
          this.setSpanContext = i.setSpanContext;
        }
        static getInstance() {
          if (!this._instance) {
            this._instance = new TraceAPI;
          }
          return this._instance;
        }
        setGlobalTracerProvider(e3) {
          const t3 = (0, n.registerGlobal)(s, this._proxyTracerProvider, c.DiagAPI.instance());
          if (t3) {
            this._proxyTracerProvider.setDelegate(e3);
          }
          return t3;
        }
        getTracerProvider() {
          return (0, n.getGlobal)(s) || this._proxyTracerProvider;
        }
        getTracer(e3, t3) {
          return this.getTracerProvider().getTracer(e3, t3);
        }
        disable() {
          (0, n.unregisterGlobal)(s, c.DiagAPI.instance());
          this._proxyTracerProvider = new a.ProxyTracerProvider;
        }
      }
      t2.TraceAPI = TraceAPI;
    }, 277: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.deleteBaggage = t2.setBaggage = t2.getActiveBaggage = t2.getBaggage = undefined;
      const n = r2(491);
      const a = r2(780);
      const o = (0, a.createContextKey)("OpenTelemetry Baggage Key");
      function getBaggage(e3) {
        return e3.getValue(o) || undefined;
      }
      t2.getBaggage = getBaggage;
      function getActiveBaggage() {
        return getBaggage(n.ContextAPI.getInstance().active());
      }
      t2.getActiveBaggage = getActiveBaggage;
      function setBaggage(e3, t3) {
        return e3.setValue(o, t3);
      }
      t2.setBaggage = setBaggage;
      function deleteBaggage(e3) {
        return e3.deleteValue(o);
      }
      t2.deleteBaggage = deleteBaggage;
    }, 993: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.BaggageImpl = undefined;

      class BaggageImpl {
        constructor(e3) {
          this._entries = e3 ? new Map(e3) : new Map;
        }
        getEntry(e3) {
          const t3 = this._entries.get(e3);
          if (!t3) {
            return;
          }
          return Object.assign({}, t3);
        }
        getAllEntries() {
          return Array.from(this._entries.entries()).map(([e3, t3]) => [e3, t3]);
        }
        setEntry(e3, t3) {
          const r2 = new BaggageImpl(this._entries);
          r2._entries.set(e3, t3);
          return r2;
        }
        removeEntry(e3) {
          const t3 = new BaggageImpl(this._entries);
          t3._entries.delete(e3);
          return t3;
        }
        removeEntries(...e3) {
          const t3 = new BaggageImpl(this._entries);
          for (const r2 of e3) {
            t3._entries.delete(r2);
          }
          return t3;
        }
        clear() {
          return new BaggageImpl;
        }
      }
      t2.BaggageImpl = BaggageImpl;
    }, 830: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.baggageEntryMetadataSymbol = undefined;
      t2.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
    }, 369: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.baggageEntryMetadataFromString = t2.createBaggage = undefined;
      const n = r2(930);
      const a = r2(993);
      const o = r2(830);
      const i = n.DiagAPI.instance();
      function createBaggage(e3 = {}) {
        return new a.BaggageImpl(new Map(Object.entries(e3)));
      }
      t2.createBaggage = createBaggage;
      function baggageEntryMetadataFromString(e3) {
        if (typeof e3 !== "string") {
          i.error(`Cannot create baggage metadata from unknown type: ${typeof e3}`);
          e3 = "";
        }
        return { __TYPE__: o.baggageEntryMetadataSymbol, toString() {
          return e3;
        } };
      }
      t2.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
    }, 67: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.context = undefined;
      const n = r2(491);
      t2.context = n.ContextAPI.getInstance();
    }, 223: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NoopContextManager = undefined;
      const n = r2(780);

      class NoopContextManager {
        active() {
          return n.ROOT_CONTEXT;
        }
        with(e3, t3, r3, ...n2) {
          return t3.call(r3, ...n2);
        }
        bind(e3, t3) {
          return t3;
        }
        enable() {
          return this;
        }
        disable() {
          return this;
        }
      }
      t2.NoopContextManager = NoopContextManager;
    }, 780: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.ROOT_CONTEXT = t2.createContextKey = undefined;
      function createContextKey(e3) {
        return Symbol.for(e3);
      }
      t2.createContextKey = createContextKey;

      class BaseContext {
        constructor(e3) {
          const t3 = this;
          t3._currentContext = e3 ? new Map(e3) : new Map;
          t3.getValue = (e4) => t3._currentContext.get(e4);
          t3.setValue = (e4, r2) => {
            const n = new BaseContext(t3._currentContext);
            n._currentContext.set(e4, r2);
            return n;
          };
          t3.deleteValue = (e4) => {
            const r2 = new BaseContext(t3._currentContext);
            r2._currentContext.delete(e4);
            return r2;
          };
        }
      }
      t2.ROOT_CONTEXT = new BaseContext;
    }, 506: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.diag = undefined;
      const n = r2(930);
      t2.diag = n.DiagAPI.instance();
    }, 56: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.DiagComponentLogger = undefined;
      const n = r2(172);

      class DiagComponentLogger {
        constructor(e3) {
          this._namespace = e3.namespace || "DiagComponentLogger";
        }
        debug(...e3) {
          return logProxy("debug", this._namespace, e3);
        }
        error(...e3) {
          return logProxy("error", this._namespace, e3);
        }
        info(...e3) {
          return logProxy("info", this._namespace, e3);
        }
        warn(...e3) {
          return logProxy("warn", this._namespace, e3);
        }
        verbose(...e3) {
          return logProxy("verbose", this._namespace, e3);
        }
      }
      t2.DiagComponentLogger = DiagComponentLogger;
      function logProxy(e3, t3, r3) {
        const a = (0, n.getGlobal)("diag");
        if (!a) {
          return;
        }
        r3.unshift(t3);
        return a[e3](...r3);
      }
    }, 972: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.DiagConsoleLogger = undefined;
      const r2 = [{ n: "error", c: "error" }, { n: "warn", c: "warn" }, { n: "info", c: "info" }, { n: "debug", c: "debug" }, { n: "verbose", c: "trace" }];

      class DiagConsoleLogger {
        constructor() {
          function _consoleFunc(e3) {
            return function(...t3) {
              if (console) {
                let r3 = console[e3];
                if (typeof r3 !== "function") {
                  r3 = console.log;
                }
                if (typeof r3 === "function") {
                  return r3.apply(console, t3);
                }
              }
            };
          }
          for (let e3 = 0;e3 < r2.length; e3++) {
            this[r2[e3].n] = _consoleFunc(r2[e3].c);
          }
        }
      }
      t2.DiagConsoleLogger = DiagConsoleLogger;
    }, 912: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.createLogLevelDiagLogger = undefined;
      const n = r2(957);
      function createLogLevelDiagLogger(e3, t3) {
        if (e3 < n.DiagLogLevel.NONE) {
          e3 = n.DiagLogLevel.NONE;
        } else if (e3 > n.DiagLogLevel.ALL) {
          e3 = n.DiagLogLevel.ALL;
        }
        t3 = t3 || {};
        function _filterFunc(r3, n2) {
          const a = t3[r3];
          if (typeof a === "function" && e3 >= n2) {
            return a.bind(t3);
          }
          return function() {};
        }
        return { error: _filterFunc("error", n.DiagLogLevel.ERROR), warn: _filterFunc("warn", n.DiagLogLevel.WARN), info: _filterFunc("info", n.DiagLogLevel.INFO), debug: _filterFunc("debug", n.DiagLogLevel.DEBUG), verbose: _filterFunc("verbose", n.DiagLogLevel.VERBOSE) };
      }
      t2.createLogLevelDiagLogger = createLogLevelDiagLogger;
    }, 957: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.DiagLogLevel = undefined;
      var r2;
      (function(e3) {
        e3[e3["NONE"] = 0] = "NONE";
        e3[e3["ERROR"] = 30] = "ERROR";
        e3[e3["WARN"] = 50] = "WARN";
        e3[e3["INFO"] = 60] = "INFO";
        e3[e3["DEBUG"] = 70] = "DEBUG";
        e3[e3["VERBOSE"] = 80] = "VERBOSE";
        e3[e3["ALL"] = 9999] = "ALL";
      })(r2 = t2.DiagLogLevel || (t2.DiagLogLevel = {}));
    }, 172: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.unregisterGlobal = t2.getGlobal = t2.registerGlobal = undefined;
      const n = r2(200);
      const a = r2(521);
      const o = r2(130);
      const i = a.VERSION.split(".")[0];
      const c = Symbol.for(`opentelemetry.js.api.${i}`);
      const s = n._globalThis;
      function registerGlobal(e3, t3, r3, n2 = false) {
        var o2;
        const i2 = s[c] = (o2 = s[c]) !== null && o2 !== undefined ? o2 : { version: a.VERSION };
        if (!n2 && i2[e3]) {
          const t4 = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e3}`);
          r3.error(t4.stack || t4.message);
          return false;
        }
        if (i2.version !== a.VERSION) {
          const t4 = new Error(`@opentelemetry/api: Registration of version v${i2.version} for ${e3} does not match previously registered API v${a.VERSION}`);
          r3.error(t4.stack || t4.message);
          return false;
        }
        i2[e3] = t3;
        r3.debug(`@opentelemetry/api: Registered a global for ${e3} v${a.VERSION}.`);
        return true;
      }
      t2.registerGlobal = registerGlobal;
      function getGlobal(e3) {
        var t3, r3;
        const n2 = (t3 = s[c]) === null || t3 === undefined ? undefined : t3.version;
        if (!n2 || !(0, o.isCompatible)(n2)) {
          return;
        }
        return (r3 = s[c]) === null || r3 === undefined ? undefined : r3[e3];
      }
      t2.getGlobal = getGlobal;
      function unregisterGlobal(e3, t3) {
        t3.debug(`@opentelemetry/api: Unregistering a global for ${e3} v${a.VERSION}.`);
        const r3 = s[c];
        if (r3) {
          delete r3[e3];
        }
      }
      t2.unregisterGlobal = unregisterGlobal;
    }, 130: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.isCompatible = t2._makeCompatibilityCheck = undefined;
      const n = r2(521);
      const a = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
      function _makeCompatibilityCheck(e3) {
        const t3 = new Set([e3]);
        const r3 = new Set;
        const n2 = e3.match(a);
        if (!n2) {
          return () => false;
        }
        const o = { major: +n2[1], minor: +n2[2], patch: +n2[3], prerelease: n2[4] };
        if (o.prerelease != null) {
          return function isExactmatch(t4) {
            return t4 === e3;
          };
        }
        function _reject(e4) {
          r3.add(e4);
          return false;
        }
        function _accept(e4) {
          t3.add(e4);
          return true;
        }
        return function isCompatible(e4) {
          if (t3.has(e4)) {
            return true;
          }
          if (r3.has(e4)) {
            return false;
          }
          const n3 = e4.match(a);
          if (!n3) {
            return _reject(e4);
          }
          const i = { major: +n3[1], minor: +n3[2], patch: +n3[3], prerelease: n3[4] };
          if (i.prerelease != null) {
            return _reject(e4);
          }
          if (o.major !== i.major) {
            return _reject(e4);
          }
          if (o.major === 0) {
            if (o.minor === i.minor && o.patch <= i.patch) {
              return _accept(e4);
            }
            return _reject(e4);
          }
          if (o.minor <= i.minor) {
            return _accept(e4);
          }
          return _reject(e4);
        };
      }
      t2._makeCompatibilityCheck = _makeCompatibilityCheck;
      t2.isCompatible = _makeCompatibilityCheck(n.VERSION);
    }, 886: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.metrics = undefined;
      const n = r2(653);
      t2.metrics = n.MetricsAPI.getInstance();
    }, 901: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.ValueType = undefined;
      var r2;
      (function(e3) {
        e3[e3["INT"] = 0] = "INT";
        e3[e3["DOUBLE"] = 1] = "DOUBLE";
      })(r2 = t2.ValueType || (t2.ValueType = {}));
    }, 102: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.createNoopMeter = t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = t2.NOOP_OBSERVABLE_GAUGE_METRIC = t2.NOOP_OBSERVABLE_COUNTER_METRIC = t2.NOOP_UP_DOWN_COUNTER_METRIC = t2.NOOP_HISTOGRAM_METRIC = t2.NOOP_COUNTER_METRIC = t2.NOOP_METER = t2.NoopObservableUpDownCounterMetric = t2.NoopObservableGaugeMetric = t2.NoopObservableCounterMetric = t2.NoopObservableMetric = t2.NoopHistogramMetric = t2.NoopUpDownCounterMetric = t2.NoopCounterMetric = t2.NoopMetric = t2.NoopMeter = undefined;

      class NoopMeter {
        constructor() {}
        createHistogram(e3, r2) {
          return t2.NOOP_HISTOGRAM_METRIC;
        }
        createCounter(e3, r2) {
          return t2.NOOP_COUNTER_METRIC;
        }
        createUpDownCounter(e3, r2) {
          return t2.NOOP_UP_DOWN_COUNTER_METRIC;
        }
        createObservableGauge(e3, r2) {
          return t2.NOOP_OBSERVABLE_GAUGE_METRIC;
        }
        createObservableCounter(e3, r2) {
          return t2.NOOP_OBSERVABLE_COUNTER_METRIC;
        }
        createObservableUpDownCounter(e3, r2) {
          return t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
        }
        addBatchObservableCallback(e3, t3) {}
        removeBatchObservableCallback(e3) {}
      }
      t2.NoopMeter = NoopMeter;

      class NoopMetric {
      }
      t2.NoopMetric = NoopMetric;

      class NoopCounterMetric extends NoopMetric {
        add(e3, t3) {}
      }
      t2.NoopCounterMetric = NoopCounterMetric;

      class NoopUpDownCounterMetric extends NoopMetric {
        add(e3, t3) {}
      }
      t2.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

      class NoopHistogramMetric extends NoopMetric {
        record(e3, t3) {}
      }
      t2.NoopHistogramMetric = NoopHistogramMetric;

      class NoopObservableMetric {
        addCallback(e3) {}
        removeCallback(e3) {}
      }
      t2.NoopObservableMetric = NoopObservableMetric;

      class NoopObservableCounterMetric extends NoopObservableMetric {
      }
      t2.NoopObservableCounterMetric = NoopObservableCounterMetric;

      class NoopObservableGaugeMetric extends NoopObservableMetric {
      }
      t2.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

      class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
      }
      t2.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
      t2.NOOP_METER = new NoopMeter;
      t2.NOOP_COUNTER_METRIC = new NoopCounterMetric;
      t2.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
      t2.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
      t2.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
      t2.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
      t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
      function createNoopMeter() {
        return t2.NOOP_METER;
      }
      t2.createNoopMeter = createNoopMeter;
    }, 660: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NOOP_METER_PROVIDER = t2.NoopMeterProvider = undefined;
      const n = r2(102);

      class NoopMeterProvider {
        getMeter(e3, t3, r3) {
          return n.NOOP_METER;
        }
      }
      t2.NoopMeterProvider = NoopMeterProvider;
      t2.NOOP_METER_PROVIDER = new NoopMeterProvider;
    }, 200: function(e2, t2, r2) {
      var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
        if (n2 === undefined)
          n2 = r3;
        Object.defineProperty(e3, n2, { enumerable: true, get: function() {
          return t3[r3];
        } });
      } : function(e3, t3, r3, n2) {
        if (n2 === undefined)
          n2 = r3;
        e3[n2] = t3[r3];
      });
      var a = this && this.__exportStar || function(e3, t3) {
        for (var r3 in e3)
          if (r3 !== "default" && !Object.prototype.hasOwnProperty.call(t3, r3))
            n(t3, e3, r3);
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      a(r2(46), t2);
    }, 651: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2._globalThis = undefined;
      t2._globalThis = typeof globalThis === "object" ? globalThis : global;
    }, 46: function(e2, t2, r2) {
      var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
        if (n2 === undefined)
          n2 = r3;
        Object.defineProperty(e3, n2, { enumerable: true, get: function() {
          return t3[r3];
        } });
      } : function(e3, t3, r3, n2) {
        if (n2 === undefined)
          n2 = r3;
        e3[n2] = t3[r3];
      });
      var a = this && this.__exportStar || function(e3, t3) {
        for (var r3 in e3)
          if (r3 !== "default" && !Object.prototype.hasOwnProperty.call(t3, r3))
            n(t3, e3, r3);
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      a(r2(651), t2);
    }, 939: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.propagation = undefined;
      const n = r2(181);
      t2.propagation = n.PropagationAPI.getInstance();
    }, 874: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NoopTextMapPropagator = undefined;

      class NoopTextMapPropagator {
        inject(e3, t3) {}
        extract(e3, t3) {
          return e3;
        }
        fields() {
          return [];
        }
      }
      t2.NoopTextMapPropagator = NoopTextMapPropagator;
    }, 194: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.defaultTextMapSetter = t2.defaultTextMapGetter = undefined;
      t2.defaultTextMapGetter = { get(e3, t3) {
        if (e3 == null) {
          return;
        }
        return e3[t3];
      }, keys(e3) {
        if (e3 == null) {
          return [];
        }
        return Object.keys(e3);
      } };
      t2.defaultTextMapSetter = { set(e3, t3, r2) {
        if (e3 == null) {
          return;
        }
        e3[t3] = r2;
      } };
    }, 845: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.trace = undefined;
      const n = r2(997);
      t2.trace = n.TraceAPI.getInstance();
    }, 403: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NonRecordingSpan = undefined;
      const n = r2(476);

      class NonRecordingSpan {
        constructor(e3 = n.INVALID_SPAN_CONTEXT) {
          this._spanContext = e3;
        }
        spanContext() {
          return this._spanContext;
        }
        setAttribute(e3, t3) {
          return this;
        }
        setAttributes(e3) {
          return this;
        }
        addEvent(e3, t3) {
          return this;
        }
        setStatus(e3) {
          return this;
        }
        updateName(e3) {
          return this;
        }
        end(e3) {}
        isRecording() {
          return false;
        }
        recordException(e3, t3) {}
      }
      t2.NonRecordingSpan = NonRecordingSpan;
    }, 614: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NoopTracer = undefined;
      const n = r2(491);
      const a = r2(607);
      const o = r2(403);
      const i = r2(139);
      const c = n.ContextAPI.getInstance();

      class NoopTracer {
        startSpan(e3, t3, r3 = c.active()) {
          const n2 = Boolean(t3 === null || t3 === undefined ? undefined : t3.root);
          if (n2) {
            return new o.NonRecordingSpan;
          }
          const s = r3 && (0, a.getSpanContext)(r3);
          if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {
            return new o.NonRecordingSpan(s);
          } else {
            return new o.NonRecordingSpan;
          }
        }
        startActiveSpan(e3, t3, r3, n2) {
          let o2;
          let i2;
          let s;
          if (arguments.length < 2) {
            return;
          } else if (arguments.length === 2) {
            s = t3;
          } else if (arguments.length === 3) {
            o2 = t3;
            s = r3;
          } else {
            o2 = t3;
            i2 = r3;
            s = n2;
          }
          const u = i2 !== null && i2 !== undefined ? i2 : c.active();
          const l = this.startSpan(e3, o2, u);
          const g = (0, a.setSpan)(u, l);
          return c.with(g, s, undefined, l);
        }
      }
      t2.NoopTracer = NoopTracer;
      function isSpanContext(e3) {
        return typeof e3 === "object" && typeof e3["spanId"] === "string" && typeof e3["traceId"] === "string" && typeof e3["traceFlags"] === "number";
      }
    }, 124: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.NoopTracerProvider = undefined;
      const n = r2(614);

      class NoopTracerProvider {
        getTracer(e3, t3, r3) {
          return new n.NoopTracer;
        }
      }
      t2.NoopTracerProvider = NoopTracerProvider;
    }, 125: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.ProxyTracer = undefined;
      const n = r2(614);
      const a = new n.NoopTracer;

      class ProxyTracer {
        constructor(e3, t3, r3, n2) {
          this._provider = e3;
          this.name = t3;
          this.version = r3;
          this.options = n2;
        }
        startSpan(e3, t3, r3) {
          return this._getTracer().startSpan(e3, t3, r3);
        }
        startActiveSpan(e3, t3, r3, n2) {
          const a2 = this._getTracer();
          return Reflect.apply(a2.startActiveSpan, a2, arguments);
        }
        _getTracer() {
          if (this._delegate) {
            return this._delegate;
          }
          const e3 = this._provider.getDelegateTracer(this.name, this.version, this.options);
          if (!e3) {
            return a;
          }
          this._delegate = e3;
          return this._delegate;
        }
      }
      t2.ProxyTracer = ProxyTracer;
    }, 846: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.ProxyTracerProvider = undefined;
      const n = r2(125);
      const a = r2(124);
      const o = new a.NoopTracerProvider;

      class ProxyTracerProvider {
        getTracer(e3, t3, r3) {
          var a2;
          return (a2 = this.getDelegateTracer(e3, t3, r3)) !== null && a2 !== undefined ? a2 : new n.ProxyTracer(this, e3, t3, r3);
        }
        getDelegate() {
          var e3;
          return (e3 = this._delegate) !== null && e3 !== undefined ? e3 : o;
        }
        setDelegate(e3) {
          this._delegate = e3;
        }
        getDelegateTracer(e3, t3, r3) {
          var n2;
          return (n2 = this._delegate) === null || n2 === undefined ? undefined : n2.getTracer(e3, t3, r3);
        }
      }
      t2.ProxyTracerProvider = ProxyTracerProvider;
    }, 996: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.SamplingDecision = undefined;
      var r2;
      (function(e3) {
        e3[e3["NOT_RECORD"] = 0] = "NOT_RECORD";
        e3[e3["RECORD"] = 1] = "RECORD";
        e3[e3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
      })(r2 = t2.SamplingDecision || (t2.SamplingDecision = {}));
    }, 607: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.getSpanContext = t2.setSpanContext = t2.deleteSpan = t2.setSpan = t2.getActiveSpan = t2.getSpan = undefined;
      const n = r2(780);
      const a = r2(403);
      const o = r2(491);
      const i = (0, n.createContextKey)("OpenTelemetry Context Key SPAN");
      function getSpan(e3) {
        return e3.getValue(i) || undefined;
      }
      t2.getSpan = getSpan;
      function getActiveSpan() {
        return getSpan(o.ContextAPI.getInstance().active());
      }
      t2.getActiveSpan = getActiveSpan;
      function setSpan(e3, t3) {
        return e3.setValue(i, t3);
      }
      t2.setSpan = setSpan;
      function deleteSpan(e3) {
        return e3.deleteValue(i);
      }
      t2.deleteSpan = deleteSpan;
      function setSpanContext(e3, t3) {
        return setSpan(e3, new a.NonRecordingSpan(t3));
      }
      t2.setSpanContext = setSpanContext;
      function getSpanContext(e3) {
        var t3;
        return (t3 = getSpan(e3)) === null || t3 === undefined ? undefined : t3.spanContext();
      }
      t2.getSpanContext = getSpanContext;
    }, 325: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.TraceStateImpl = undefined;
      const n = r2(564);
      const a = 32;
      const o = 512;
      const i = ",";
      const c = "=";

      class TraceStateImpl {
        constructor(e3) {
          this._internalState = new Map;
          if (e3)
            this._parse(e3);
        }
        set(e3, t3) {
          const r3 = this._clone();
          if (r3._internalState.has(e3)) {
            r3._internalState.delete(e3);
          }
          r3._internalState.set(e3, t3);
          return r3;
        }
        unset(e3) {
          const t3 = this._clone();
          t3._internalState.delete(e3);
          return t3;
        }
        get(e3) {
          return this._internalState.get(e3);
        }
        serialize() {
          return this._keys().reduce((e3, t3) => {
            e3.push(t3 + c + this.get(t3));
            return e3;
          }, []).join(i);
        }
        _parse(e3) {
          if (e3.length > o)
            return;
          this._internalState = e3.split(i).reverse().reduce((e4, t3) => {
            const r3 = t3.trim();
            const a2 = r3.indexOf(c);
            if (a2 !== -1) {
              const o2 = r3.slice(0, a2);
              const i2 = r3.slice(a2 + 1, t3.length);
              if ((0, n.validateKey)(o2) && (0, n.validateValue)(i2)) {
                e4.set(o2, i2);
              } else {}
            }
            return e4;
          }, new Map);
          if (this._internalState.size > a) {
            this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, a));
          }
        }
        _keys() {
          return Array.from(this._internalState.keys()).reverse();
        }
        _clone() {
          const e3 = new TraceStateImpl;
          e3._internalState = new Map(this._internalState);
          return e3;
        }
      }
      t2.TraceStateImpl = TraceStateImpl;
    }, 564: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.validateValue = t2.validateKey = undefined;
      const r2 = "[_0-9a-z-*/]";
      const n = `[a-z]${r2}{0,255}`;
      const a = `[a-z0-9]${r2}{0,240}@[a-z]${r2}{0,13}`;
      const o = new RegExp(`^(?:${n}|${a})$`);
      const i = /^[ -~]{0,255}[!-~]$/;
      const c = /,|=/;
      function validateKey(e3) {
        return o.test(e3);
      }
      t2.validateKey = validateKey;
      function validateValue(e3) {
        return i.test(e3) && !c.test(e3);
      }
      t2.validateValue = validateValue;
    }, 98: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.createTraceState = undefined;
      const n = r2(325);
      function createTraceState(e3) {
        return new n.TraceStateImpl(e3);
      }
      t2.createTraceState = createTraceState;
    }, 476: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.INVALID_SPAN_CONTEXT = t2.INVALID_TRACEID = t2.INVALID_SPANID = undefined;
      const n = r2(475);
      t2.INVALID_SPANID = "0000000000000000";
      t2.INVALID_TRACEID = "00000000000000000000000000000000";
      t2.INVALID_SPAN_CONTEXT = { traceId: t2.INVALID_TRACEID, spanId: t2.INVALID_SPANID, traceFlags: n.TraceFlags.NONE };
    }, 357: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.SpanKind = undefined;
      var r2;
      (function(e3) {
        e3[e3["INTERNAL"] = 0] = "INTERNAL";
        e3[e3["SERVER"] = 1] = "SERVER";
        e3[e3["CLIENT"] = 2] = "CLIENT";
        e3[e3["PRODUCER"] = 3] = "PRODUCER";
        e3[e3["CONSUMER"] = 4] = "CONSUMER";
      })(r2 = t2.SpanKind || (t2.SpanKind = {}));
    }, 139: (e2, t2, r2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.wrapSpanContext = t2.isSpanContextValid = t2.isValidSpanId = t2.isValidTraceId = undefined;
      const n = r2(476);
      const a = r2(403);
      const o = /^([0-9a-f]{32})$/i;
      const i = /^[0-9a-f]{16}$/i;
      function isValidTraceId(e3) {
        return o.test(e3) && e3 !== n.INVALID_TRACEID;
      }
      t2.isValidTraceId = isValidTraceId;
      function isValidSpanId(e3) {
        return i.test(e3) && e3 !== n.INVALID_SPANID;
      }
      t2.isValidSpanId = isValidSpanId;
      function isSpanContextValid(e3) {
        return isValidTraceId(e3.traceId) && isValidSpanId(e3.spanId);
      }
      t2.isSpanContextValid = isSpanContextValid;
      function wrapSpanContext(e3) {
        return new a.NonRecordingSpan(e3);
      }
      t2.wrapSpanContext = wrapSpanContext;
    }, 847: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.SpanStatusCode = undefined;
      var r2;
      (function(e3) {
        e3[e3["UNSET"] = 0] = "UNSET";
        e3[e3["OK"] = 1] = "OK";
        e3[e3["ERROR"] = 2] = "ERROR";
      })(r2 = t2.SpanStatusCode || (t2.SpanStatusCode = {}));
    }, 475: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.TraceFlags = undefined;
      var r2;
      (function(e3) {
        e3[e3["NONE"] = 0] = "NONE";
        e3[e3["SAMPLED"] = 1] = "SAMPLED";
      })(r2 = t2.TraceFlags || (t2.TraceFlags = {}));
    }, 521: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true });
      t2.VERSION = undefined;
      t2.VERSION = "1.6.0";
    } };
    var t = {};
    function __nccwpck_require__(r2) {
      var n = t[r2];
      if (n !== undefined) {
        return n.exports;
      }
      var a = t[r2] = { exports: {} };
      var o = true;
      try {
        e[r2].call(a.exports, a, a.exports, __nccwpck_require__);
        o = false;
      } finally {
        if (o)
          delete t[r2];
      }
      return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined")
      __nccwpck_require__.ab = __dirname + "/";
    var r = {};
    (() => {
      var e2 = r;
      Object.defineProperty(e2, "__esModule", { value: true });
      e2.trace = e2.propagation = e2.metrics = e2.diag = e2.context = e2.INVALID_SPAN_CONTEXT = e2.INVALID_TRACEID = e2.INVALID_SPANID = e2.isValidSpanId = e2.isValidTraceId = e2.isSpanContextValid = e2.createTraceState = e2.TraceFlags = e2.SpanStatusCode = e2.SpanKind = e2.SamplingDecision = e2.ProxyTracerProvider = e2.ProxyTracer = e2.defaultTextMapSetter = e2.defaultTextMapGetter = e2.ValueType = e2.createNoopMeter = e2.DiagLogLevel = e2.DiagConsoleLogger = e2.ROOT_CONTEXT = e2.createContextKey = e2.baggageEntryMetadataFromString = undefined;
      var t2 = __nccwpck_require__(369);
      Object.defineProperty(e2, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
        return t2.baggageEntryMetadataFromString;
      } });
      var n = __nccwpck_require__(780);
      Object.defineProperty(e2, "createContextKey", { enumerable: true, get: function() {
        return n.createContextKey;
      } });
      Object.defineProperty(e2, "ROOT_CONTEXT", { enumerable: true, get: function() {
        return n.ROOT_CONTEXT;
      } });
      var a = __nccwpck_require__(972);
      Object.defineProperty(e2, "DiagConsoleLogger", { enumerable: true, get: function() {
        return a.DiagConsoleLogger;
      } });
      var o = __nccwpck_require__(957);
      Object.defineProperty(e2, "DiagLogLevel", { enumerable: true, get: function() {
        return o.DiagLogLevel;
      } });
      var i = __nccwpck_require__(102);
      Object.defineProperty(e2, "createNoopMeter", { enumerable: true, get: function() {
        return i.createNoopMeter;
      } });
      var c = __nccwpck_require__(901);
      Object.defineProperty(e2, "ValueType", { enumerable: true, get: function() {
        return c.ValueType;
      } });
      var s = __nccwpck_require__(194);
      Object.defineProperty(e2, "defaultTextMapGetter", { enumerable: true, get: function() {
        return s.defaultTextMapGetter;
      } });
      Object.defineProperty(e2, "defaultTextMapSetter", { enumerable: true, get: function() {
        return s.defaultTextMapSetter;
      } });
      var u = __nccwpck_require__(125);
      Object.defineProperty(e2, "ProxyTracer", { enumerable: true, get: function() {
        return u.ProxyTracer;
      } });
      var l = __nccwpck_require__(846);
      Object.defineProperty(e2, "ProxyTracerProvider", { enumerable: true, get: function() {
        return l.ProxyTracerProvider;
      } });
      var g = __nccwpck_require__(996);
      Object.defineProperty(e2, "SamplingDecision", { enumerable: true, get: function() {
        return g.SamplingDecision;
      } });
      var p = __nccwpck_require__(357);
      Object.defineProperty(e2, "SpanKind", { enumerable: true, get: function() {
        return p.SpanKind;
      } });
      var d = __nccwpck_require__(847);
      Object.defineProperty(e2, "SpanStatusCode", { enumerable: true, get: function() {
        return d.SpanStatusCode;
      } });
      var _ = __nccwpck_require__(475);
      Object.defineProperty(e2, "TraceFlags", { enumerable: true, get: function() {
        return _.TraceFlags;
      } });
      var f = __nccwpck_require__(98);
      Object.defineProperty(e2, "createTraceState", { enumerable: true, get: function() {
        return f.createTraceState;
      } });
      var b = __nccwpck_require__(139);
      Object.defineProperty(e2, "isSpanContextValid", { enumerable: true, get: function() {
        return b.isSpanContextValid;
      } });
      Object.defineProperty(e2, "isValidTraceId", { enumerable: true, get: function() {
        return b.isValidTraceId;
      } });
      Object.defineProperty(e2, "isValidSpanId", { enumerable: true, get: function() {
        return b.isValidSpanId;
      } });
      var v = __nccwpck_require__(476);
      Object.defineProperty(e2, "INVALID_SPANID", { enumerable: true, get: function() {
        return v.INVALID_SPANID;
      } });
      Object.defineProperty(e2, "INVALID_TRACEID", { enumerable: true, get: function() {
        return v.INVALID_TRACEID;
      } });
      Object.defineProperty(e2, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
        return v.INVALID_SPAN_CONTEXT;
      } });
      const O = __nccwpck_require__(67);
      Object.defineProperty(e2, "context", { enumerable: true, get: function() {
        return O.context;
      } });
      const P = __nccwpck_require__(506);
      Object.defineProperty(e2, "diag", { enumerable: true, get: function() {
        return P.diag;
      } });
      const N = __nccwpck_require__(886);
      Object.defineProperty(e2, "metrics", { enumerable: true, get: function() {
        return N.metrics;
      } });
      const S = __nccwpck_require__(939);
      Object.defineProperty(e2, "propagation", { enumerable: true, get: function() {
        return S.propagation;
      } });
      const C = __nccwpck_require__(845);
      Object.defineProperty(e2, "trace", { enumerable: true, get: function() {
        return C.trace;
      } });
      e2["default"] = { context: O.context, diag: P.diag, metrics: N.metrics, propagation: S.propagation, trace: C.trace };
    })();
    module.exports = r;
  })();
});

// node_modules/next/dist/server/lib/trace/tracer.js
var require_tracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    SpanKind: function() {
      return SpanKind;
    },
    SpanStatusCode: function() {
      return SpanStatusCode;
    },
    getTracer: function() {
      return getTracer;
    }
  });
  var _constants = require_constants2();
  var api;
  if (process.env.NEXT_RUNTIME === "edge") {
    api = require_src();
  } else {
    try {
      api = require_src();
    } catch (err) {
      api = require_api();
    }
  }
  var { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
  var isPromise = (p) => {
    return p !== null && typeof p === "object" && typeof p.then === "function";
  };
  var closeSpanWithError = (span, error) => {
    if ((error == null ? undefined : error.bubble) === true) {
      span.setAttribute("next.bubble", true);
    } else {
      if (error) {
        span.recordException(error);
      }
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error == null ? undefined : error.message
      });
    }
    span.end();
  };
  var rootSpanAttributesStore = new Map;
  var rootSpanIdKey = api.createContextKey("next.rootSpanId");
  var lastSpanId = 0;
  var getSpanId = () => lastSpanId++;

  class NextTracerImpl {
    getTracerInstance() {
      return trace.getTracer("next.js", "0.0.1");
    }
    getContext() {
      return context;
    }
    getActiveScopeSpan() {
      return trace.getSpan(context == null ? undefined : context.active());
    }
    withPropagatedContext(carrier, fn, getter) {
      const activeContext = context.active();
      if (trace.getSpanContext(activeContext)) {
        return fn();
      }
      const remoteContext = propagation.extract(activeContext, carrier, getter);
      return context.with(remoteContext, fn);
    }
    trace(...args) {
      var _trace_getSpanContext;
      const [type, fnOrOptions, fnOrEmpty] = args;
      const { fn, options } = typeof fnOrOptions === "function" ? {
        fn: fnOrOptions,
        options: {}
      } : {
        fn: fnOrEmpty,
        options: {
          ...fnOrOptions
        }
      };
      const spanName = options.spanName ?? type;
      if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== "1" || options.hideSpan) {
        return fn();
      }
      let spanContext = this.getSpanContext((options == null ? undefined : options.parentSpan) ?? this.getActiveScopeSpan());
      let isRootSpan = false;
      if (!spanContext) {
        spanContext = (context == null ? undefined : context.active()) ?? ROOT_CONTEXT;
        isRootSpan = true;
      } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? undefined : _trace_getSpanContext.isRemote) {
        isRootSpan = true;
      }
      const spanId = getSpanId();
      options.attributes = {
        "next.span_name": spanName,
        "next.span_type": type,
        ...options.attributes
      };
      return context.with(spanContext.setValue(rootSpanIdKey, spanId), () => this.getTracerInstance().startActiveSpan(spanName, options, (span) => {
        const startTime = "performance" in globalThis ? globalThis.performance.now() : undefined;
        const onCleanup = () => {
          rootSpanAttributesStore.delete(spanId);
          if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && _constants.LogSpanAllowList.includes(type || "")) {
            performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split(".").pop() || "").replace(/[A-Z]/g, (match) => "-" + match.toLowerCase())}`, {
              start: startTime,
              end: performance.now()
            });
          }
        };
        if (isRootSpan) {
          rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
        }
        try {
          if (fn.length > 1) {
            return fn(span, (err) => closeSpanWithError(span, err));
          }
          const result = fn(span);
          if (isPromise(result)) {
            return result.then((res) => {
              span.end();
              return res;
            }).catch((err) => {
              closeSpanWithError(span, err);
              throw err;
            }).finally(onCleanup);
          } else {
            span.end();
            onCleanup();
          }
          return result;
        } catch (err) {
          closeSpanWithError(span, err);
          onCleanup();
          throw err;
        }
      }));
    }
    wrap(...args) {
      const tracer = this;
      const [name, options, fn] = args.length === 3 ? args : [
        args[0],
        {},
        args[1]
      ];
      if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== "1") {
        return fn;
      }
      return function() {
        let optionsObj = options;
        if (typeof optionsObj === "function" && typeof fn === "function") {
          optionsObj = optionsObj.apply(this, arguments);
        }
        const lastArgId = arguments.length - 1;
        const cb = arguments[lastArgId];
        if (typeof cb === "function") {
          const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
          return tracer.trace(name, optionsObj, (_span, done) => {
            arguments[lastArgId] = function(err) {
              done == null || done(err);
              return scopeBoundCb.apply(this, arguments);
            };
            return fn.apply(this, arguments);
          });
        } else {
          return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));
        }
      };
    }
    startSpan(...args) {
      const [type, options] = args;
      const spanContext = this.getSpanContext((options == null ? undefined : options.parentSpan) ?? this.getActiveScopeSpan());
      return this.getTracerInstance().startSpan(type, options, spanContext);
    }
    getSpanContext(parentSpan) {
      const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;
      return spanContext;
    }
    getRootSpanAttributes() {
      const spanId = context.active().getValue(rootSpanIdKey);
      return rootSpanAttributesStore.get(spanId);
    }
  }
  var getTracer = (() => {
    const tracer = new NextTracerImpl;
    return () => tracer;
  })();
});

// node_modules/next/dist/lib/picocolors.js
var require_picocolors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    bgBlack: function() {
      return bgBlack;
    },
    bgBlue: function() {
      return bgBlue;
    },
    bgCyan: function() {
      return bgCyan;
    },
    bgGreen: function() {
      return bgGreen;
    },
    bgMagenta: function() {
      return bgMagenta;
    },
    bgRed: function() {
      return bgRed;
    },
    bgWhite: function() {
      return bgWhite;
    },
    bgYellow: function() {
      return bgYellow;
    },
    black: function() {
      return black;
    },
    blue: function() {
      return blue;
    },
    bold: function() {
      return bold;
    },
    cyan: function() {
      return cyan;
    },
    dim: function() {
      return dim;
    },
    gray: function() {
      return gray;
    },
    green: function() {
      return green;
    },
    hidden: function() {
      return hidden;
    },
    inverse: function() {
      return inverse;
    },
    italic: function() {
      return italic;
    },
    magenta: function() {
      return magenta;
    },
    purple: function() {
      return purple;
    },
    red: function() {
      return red;
    },
    reset: function() {
      return reset;
    },
    strikethrough: function() {
      return strikethrough;
    },
    underline: function() {
      return underline;
    },
    white: function() {
      return white;
    },
    yellow: function() {
      return yellow;
    }
  });
  var _globalThis;
  var { env, stdout } = ((_globalThis = globalThis) == null ? undefined : _globalThis.process) ?? {};
  var enabled = env && !env.NO_COLOR && (env.FORCE_COLOR || (stdout == null ? undefined : stdout.isTTY) && !env.CI && env.TERM !== "dumb");
  var replaceClose = (str, close, replace, index) => {
    const start = str.substring(0, index) + replace;
    const end = str.substring(index + close.length);
    const nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
  };
  var formatter = (open, close, replace = open) => {
    if (!enabled)
      return String;
    return (input) => {
      const string = "" + input;
      const index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
  };
  var reset = enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String;
  var bold = formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m");
  var dim = formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m");
  var italic = formatter("\x1B[3m", "\x1B[23m");
  var underline = formatter("\x1B[4m", "\x1B[24m");
  var inverse = formatter("\x1B[7m", "\x1B[27m");
  var hidden = formatter("\x1B[8m", "\x1B[28m");
  var strikethrough = formatter("\x1B[9m", "\x1B[29m");
  var black = formatter("\x1B[30m", "\x1B[39m");
  var red = formatter("\x1B[31m", "\x1B[39m");
  var green = formatter("\x1B[32m", "\x1B[39m");
  var yellow = formatter("\x1B[33m", "\x1B[39m");
  var blue = formatter("\x1B[34m", "\x1B[39m");
  var magenta = formatter("\x1B[35m", "\x1B[39m");
  var purple = formatter("\x1B[38;2;173;127;168m", "\x1B[39m");
  var cyan = formatter("\x1B[36m", "\x1B[39m");
  var white = formatter("\x1B[37m", "\x1B[39m");
  var gray = formatter("\x1B[90m", "\x1B[39m");
  var bgBlack = formatter("\x1B[40m", "\x1B[49m");
  var bgRed = formatter("\x1B[41m", "\x1B[49m");
  var bgGreen = formatter("\x1B[42m", "\x1B[49m");
  var bgYellow = formatter("\x1B[43m", "\x1B[49m");
  var bgBlue = formatter("\x1B[44m", "\x1B[49m");
  var bgMagenta = formatter("\x1B[45m", "\x1B[49m");
  var bgCyan = formatter("\x1B[46m", "\x1B[49m");
  var bgWhite = formatter("\x1B[47m", "\x1B[49m");
});

// node_modules/next/dist/build/output/log.js
var require_log = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    bootstrap: function() {
      return bootstrap;
    },
    error: function() {
      return error;
    },
    event: function() {
      return event;
    },
    info: function() {
      return info;
    },
    prefixes: function() {
      return prefixes;
    },
    ready: function() {
      return ready;
    },
    trace: function() {
      return trace;
    },
    wait: function() {
      return wait;
    },
    warn: function() {
      return warn;
    },
    warnOnce: function() {
      return warnOnce;
    }
  });
  var _picocolors = require_picocolors();
  var prefixes = {
    wait: (0, _picocolors.white)((0, _picocolors.bold)("○")),
    error: (0, _picocolors.red)((0, _picocolors.bold)("⨯")),
    warn: (0, _picocolors.yellow)((0, _picocolors.bold)("⚠")),
    ready: "▲",
    info: (0, _picocolors.white)((0, _picocolors.bold)(" ")),
    event: (0, _picocolors.green)((0, _picocolors.bold)("✓")),
    trace: (0, _picocolors.magenta)((0, _picocolors.bold)("»"))
  };
  var LOGGING_METHOD = {
    log: "log",
    warn: "warn",
    error: "error"
  };
  function prefixedLog(prefixType, ...message) {
    if ((message[0] === "" || message[0] === undefined) && message.length === 1) {
      message.shift();
    }
    const consoleMethod = prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : "log";
    const prefix = prefixes[prefixType];
    if (message.length === 0) {
      console[consoleMethod]("");
    } else {
      console[consoleMethod](" " + prefix, ...message);
    }
  }
  function bootstrap(...message) {
    console.log(" ", ...message);
  }
  function wait(...message) {
    prefixedLog("wait", ...message);
  }
  function error(...message) {
    prefixedLog("error", ...message);
  }
  function warn(...message) {
    prefixedLog("warn", ...message);
  }
  function ready(...message) {
    prefixedLog("ready", ...message);
  }
  function info(...message) {
    prefixedLog("info", ...message);
  }
  function event(...message) {
    prefixedLog("event", ...message);
  }
  function trace(...message) {
    prefixedLog("trace", ...message);
  }
  var warnOnceMessages = new Set;
  function warnOnce(...message) {
    if (!warnOnceMessages.has(message[0])) {
      warnOnceMessages.add(message.join(" "));
      warn(...message);
    }
  }
});

// node_modules/next/dist/server/lib/clone-response.js
var require_clone_response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "cloneResponse", {
    enumerable: true,
    get: function() {
      return cloneResponse;
    }
  });
  function cloneResponse(original) {
    if (!original.body) {
      return [
        original,
        original
      ];
    }
    const [body1, body2] = original.body.tee();
    const cloned1 = new Response(body1, {
      status: original.status,
      statusText: original.statusText,
      headers: original.headers
    });
    Object.defineProperty(cloned1, "url", {
      value: original.url
    });
    const cloned2 = new Response(body2, {
      status: original.status,
      statusText: original.statusText,
      headers: original.headers
    });
    Object.defineProperty(cloned2, "url", {
      value: original.url
    });
    return [
      cloned1,
      cloned2
    ];
  }
});

// node_modules/next/dist/server/lib/dedupe-fetch.js
var require_dedupe_fetch = __commonJS((exports) => {
  var react = __toESM(require_react(), 1);
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "createDedupeFetch", {
    enumerable: true,
    get: function() {
      return createDedupeFetch;
    }
  });
  var _react = /* @__PURE__ */ _interop_require_wildcard(react);
  var _cloneresponse = require_clone_response();
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {
      __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]';
  function generateCacheKey(request) {
    return JSON.stringify([
      request.method,
      Array.from(request.headers.entries()),
      request.mode,
      request.redirect,
      request.credentials,
      request.referrer,
      request.referrerPolicy,
      request.integrity
    ]);
  }
  function createDedupeFetch(originalFetch) {
    const getCacheEntries = _react.cache((url) => []);
    return function dedupeFetch(resource, options) {
      if (options && options.signal) {
        return originalFetch(resource, options);
      }
      let url;
      let cacheKey;
      if (typeof resource === "string" && !options) {
        cacheKey = simpleCacheKey;
        url = resource;
      } else {
        const request = typeof resource === "string" || resource instanceof URL ? new Request(resource, options) : resource;
        if (request.method !== "GET" && request.method !== "HEAD" || request.keepalive) {
          return originalFetch(resource, options);
        }
        cacheKey = generateCacheKey(request);
        url = request.url;
      }
      const cacheEntries = getCacheEntries(url);
      for (let i = 0, j = cacheEntries.length;i < j; i += 1) {
        const [key, promise2] = cacheEntries[i];
        if (key === cacheKey) {
          return promise2.then(() => {
            const response = cacheEntries[i][2];
            if (!response)
              throw new Error("No cached response");
            const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
            cacheEntries[i][2] = cloned2;
            return cloned1;
          });
        }
      }
      const controller = new AbortController;
      const promise = originalFetch(resource, {
        ...options,
        signal: controller.signal
      });
      const entry = [
        cacheKey,
        promise,
        null
      ];
      cacheEntries.push(entry);
      return promise.then((response) => {
        const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);
        entry[2] = cloned2;
        return cloned1;
      });
    };
  }
});

// node_modules/next/dist/server/lib/patch-fetch.js
var require_patch_fetch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    addImplicitTags: function() {
      return addImplicitTags;
    },
    patchFetch: function() {
      return patchFetch;
    },
    validateRevalidate: function() {
      return validateRevalidate;
    },
    validateTags: function() {
      return validateTags;
    }
  });
  var _constants = require_constants2();
  var _tracer = require_tracer();
  var _constants1 = require_constants();
  var _log = /* @__PURE__ */ _interop_require_wildcard(require_log());
  var _dynamicrendering = require_dynamic_rendering();
  var _dedupefetch = require_dedupe_fetch();
  var _cloneresponse = require_clone_response();
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {
      __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var isEdgeRuntime = process.env.NEXT_RUNTIME === "edge";
  function isPatchedFetch(fetch2) {
    return "__nextPatched" in fetch2 && fetch2.__nextPatched === true;
  }
  function validateRevalidate(revalidateVal, pathname) {
    try {
      let normalizedRevalidate = undefined;
      if (revalidateVal === false) {
        normalizedRevalidate = revalidateVal;
      } else if (typeof revalidateVal === "number" && !isNaN(revalidateVal) && revalidateVal > -1) {
        normalizedRevalidate = revalidateVal;
      } else if (typeof revalidateVal !== "undefined") {
        throw new Error(`Invalid revalidate value "${revalidateVal}" on "${pathname}", must be a non-negative number or "false"`);
      }
      return normalizedRevalidate;
    } catch (err) {
      if (err instanceof Error && err.message.includes("Invalid revalidate")) {
        throw err;
      }
      return;
    }
  }
  function validateTags(tags, description) {
    const validTags = [];
    const invalidTags = [];
    for (let i = 0;i < tags.length; i++) {
      const tag = tags[i];
      if (typeof tag !== "string") {
        invalidTags.push({
          tag,
          reason: "invalid type, must be a string"
        });
      } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {
        invalidTags.push({
          tag,
          reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`
        });
      } else {
        validTags.push(tag);
      }
      if (validTags.length > _constants1.NEXT_CACHE_TAG_MAX_ITEMS) {
        console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(", "));
        break;
      }
    }
    if (invalidTags.length > 0) {
      console.warn(`Warning: invalid tags passed to ${description}: `);
      for (const { tag, reason } of invalidTags) {
        console.log(`tag: "${tag}" ${reason}`);
      }
    }
    return validTags;
  }
  var getDerivedTags = (pathname) => {
    const derivedTags = [
      `/layout`
    ];
    if (pathname.startsWith("/")) {
      const pathnameParts = pathname.split("/");
      for (let i = 1;i < pathnameParts.length + 1; i++) {
        let curPathname = pathnameParts.slice(0, i).join("/");
        if (curPathname) {
          if (!curPathname.endsWith("/page") && !curPathname.endsWith("/route")) {
            curPathname = `${curPathname}${!curPathname.endsWith("/") ? "/" : ""}layout`;
          }
          derivedTags.push(curPathname);
        }
      }
    }
    return derivedTags;
  };
  function addImplicitTags(staticGenerationStore) {
    const newTags = [];
    const { pagePath, urlPathname } = staticGenerationStore;
    if (!Array.isArray(staticGenerationStore.tags)) {
      staticGenerationStore.tags = [];
    }
    if (pagePath) {
      const derivedTags = getDerivedTags(pagePath);
      for (let tag of derivedTags) {
        var _staticGenerationStore_tags;
        tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`;
        if (!((_staticGenerationStore_tags = staticGenerationStore.tags) == null ? undefined : _staticGenerationStore_tags.includes(tag))) {
          staticGenerationStore.tags.push(tag);
        }
        newTags.push(tag);
      }
    }
    if (urlPathname) {
      var _staticGenerationStore_tags1;
      const parsedPathname = new URL(urlPathname, "http://n").pathname;
      const tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${parsedPathname}`;
      if (!((_staticGenerationStore_tags1 = staticGenerationStore.tags) == null ? undefined : _staticGenerationStore_tags1.includes(tag))) {
        staticGenerationStore.tags.push(tag);
      }
      newTags.push(tag);
    }
    return newTags;
  }
  function trackFetchMetric(staticGenerationStore, ctx) {
    var _staticGenerationStore_requestEndedState;
    if (!staticGenerationStore || ((_staticGenerationStore_requestEndedState = staticGenerationStore.requestEndedState) == null ? undefined : _staticGenerationStore_requestEndedState.ended) || false) {
      return;
    }
    staticGenerationStore.fetchMetrics ??= [];
    const dedupeFields = [
      "url",
      "status",
      "method"
    ];
    if (staticGenerationStore.fetchMetrics.some((metric) => dedupeFields.every((field) => metric[field] === ctx[field]))) {
      return;
    }
    staticGenerationStore.fetchMetrics.push({
      ...ctx,
      end: Date.now(),
      idx: staticGenerationStore.nextFetchId || 0
    });
    if (staticGenerationStore.fetchMetrics.length > 10) {
      staticGenerationStore.fetchMetrics.sort((a, b) => {
        const aDur = a.end - a.start;
        const bDur = b.end - b.start;
        if (aDur < bDur) {
          return 1;
        } else if (aDur > bDur) {
          return -1;
        }
        return 0;
      });
      staticGenerationStore.fetchMetrics = staticGenerationStore.fetchMetrics.slice(0, 10);
    }
  }
  function createPatchedFetcher(originFetch, { serverHooks: { DynamicServerError }, staticGenerationAsyncStorage }) {
    const patched = async (input, init) => {
      var _init_method, _init_next;
      let url;
      try {
        url = new URL(input instanceof Request ? input.url : input);
        url.username = "";
        url.password = "";
      } catch {
        url = undefined;
      }
      const fetchUrl = (url == null ? undefined : url.href) ?? "";
      const fetchStart = Date.now();
      const method = (init == null ? undefined : (_init_method = init.method) == null ? undefined : _init_method.toUpperCase()) || "GET";
      const isInternal = (init == null ? undefined : (_init_next = init.next) == null ? undefined : _init_next.internal) === true;
      const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === "1";
      return (0, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {
        hideSpan,
        kind: _tracer.SpanKind.CLIENT,
        spanName: [
          "fetch",
          method,
          fetchUrl
        ].filter(Boolean).join(" "),
        attributes: {
          "http.url": fetchUrl,
          "http.method": method,
          "net.peer.name": url == null ? undefined : url.hostname,
          "net.peer.port": (url == null ? undefined : url.port) || undefined
        }
      }, async () => {
        var _getRequestMeta;
        if (isInternal)
          return originFetch(input, init);
        const staticGenerationStore = staticGenerationAsyncStorage.getStore();
        if (!staticGenerationStore || staticGenerationStore.isDraftMode) {
          return originFetch(input, init);
        }
        const isRequestInput = input && typeof input === "object" && typeof input.method === "string";
        const getRequestMeta = (field) => {
          const value = init == null ? undefined : init[field];
          return value || (isRequestInput ? input[field] : null);
        };
        let revalidate = undefined;
        const getNextField = (field) => {
          var _init_next2, _init_next1, _input_next;
          return typeof (init == null ? undefined : (_init_next2 = init.next) == null ? undefined : _init_next2[field]) !== "undefined" ? init == null ? undefined : (_init_next1 = init.next) == null ? undefined : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? undefined : _input_next[field] : undefined;
        };
        let curRevalidate = getNextField("revalidate");
        const tags = validateTags(getNextField("tags") || [], `fetch ${input.toString()}`);
        if (Array.isArray(tags)) {
          if (!staticGenerationStore.tags) {
            staticGenerationStore.tags = [];
          }
          for (const tag of tags) {
            if (!staticGenerationStore.tags.includes(tag)) {
              staticGenerationStore.tags.push(tag);
            }
          }
        }
        const implicitTags = addImplicitTags(staticGenerationStore);
        const fetchCacheMode = staticGenerationStore.fetchCache;
        const isUsingNoStore = !!staticGenerationStore.isUnstableNoStore;
        let _cache = getRequestMeta("cache");
        let cacheReason = "";
        if (typeof _cache === "string" && typeof curRevalidate !== "undefined") {
          if (!(isRequestInput && _cache === "default")) {
            _log.warn(`fetch for ${fetchUrl} on ${staticGenerationStore.urlPathname} specified "cache: ${_cache}" and "revalidate: ${curRevalidate}", only one should be specified.`);
          }
          _cache = undefined;
        }
        if (_cache === "force-cache") {
          curRevalidate = false;
        } else if (_cache === "no-cache" || _cache === "no-store" || fetchCacheMode === "force-no-store" || fetchCacheMode === "only-no-store") {
          curRevalidate = 0;
        }
        if (_cache === "no-cache" || _cache === "no-store") {
          cacheReason = `cache: ${_cache}`;
        }
        revalidate = validateRevalidate(curRevalidate, staticGenerationStore.urlPathname);
        const _headers = getRequestMeta("headers");
        const initHeaders = typeof (_headers == null ? undefined : _headers.get) === "function" ? _headers : new Headers(_headers || {});
        const hasUnCacheableHeader = initHeaders.get("authorization") || initHeaders.get("cookie");
        const isUnCacheableMethod = ![
          "get",
          "head"
        ].includes(((_getRequestMeta = getRequestMeta("method")) == null ? undefined : _getRequestMeta.toLowerCase()) || "get");
        const autoNoCache = (hasUnCacheableHeader || isUnCacheableMethod) && staticGenerationStore.revalidate === 0;
        switch (fetchCacheMode) {
          case "force-no-store": {
            cacheReason = "fetchCache = force-no-store";
            break;
          }
          case "only-no-store": {
            if (_cache === "force-cache" || typeof revalidate !== "undefined" && (revalidate === false || revalidate > 0)) {
              throw new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`);
            }
            cacheReason = "fetchCache = only-no-store";
            break;
          }
          case "only-cache": {
            if (_cache === "no-store") {
              throw new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`);
            }
            break;
          }
          case "force-cache": {
            if (typeof curRevalidate === "undefined" || curRevalidate === 0) {
              cacheReason = "fetchCache = force-cache";
              revalidate = false;
            }
            break;
          }
          default:
        }
        if (typeof revalidate === "undefined") {
          if (fetchCacheMode === "default-cache") {
            revalidate = false;
            cacheReason = "fetchCache = default-cache";
          } else if (autoNoCache) {
            revalidate = 0;
            cacheReason = "auto no cache";
          } else if (fetchCacheMode === "default-no-store") {
            revalidate = 0;
            cacheReason = "fetchCache = default-no-store";
          } else if (isUsingNoStore) {
            revalidate = 0;
            cacheReason = "noStore call";
          } else {
            cacheReason = "auto cache";
            revalidate = typeof staticGenerationStore.revalidate === "boolean" || typeof staticGenerationStore.revalidate === "undefined" ? false : staticGenerationStore.revalidate;
          }
        } else if (!cacheReason) {
          cacheReason = `revalidate: ${revalidate}`;
        }
        if (!(staticGenerationStore.forceStatic && revalidate === 0) && !autoNoCache && (typeof staticGenerationStore.revalidate === "undefined" || typeof revalidate === "number" && (staticGenerationStore.revalidate === false || typeof staticGenerationStore.revalidate === "number" && revalidate < staticGenerationStore.revalidate))) {
          if (revalidate === 0) {
            (0, _dynamicrendering.trackDynamicFetch)(staticGenerationStore, "revalidate: 0");
          }
          staticGenerationStore.revalidate = revalidate;
        }
        const isCacheableRevalidate = typeof revalidate === "number" && revalidate > 0 || revalidate === false;
        let cacheKey;
        if (staticGenerationStore.incrementalCache && isCacheableRevalidate) {
          try {
            cacheKey = await staticGenerationStore.incrementalCache.fetchCacheKey(fetchUrl, isRequestInput ? input : init);
          } catch (err) {
            console.error(`Failed to generate cache key for`, input);
          }
        }
        const fetchIdx = staticGenerationStore.nextFetchId ?? 1;
        staticGenerationStore.nextFetchId = fetchIdx + 1;
        const normalizedRevalidate = typeof revalidate !== "number" ? _constants1.CACHE_ONE_YEAR : revalidate;
        const doOriginalFetch = async (isStale, cacheReasonOverride2) => {
          const requestInputFields = [
            "cache",
            "credentials",
            "headers",
            "integrity",
            "keepalive",
            "method",
            "mode",
            "redirect",
            "referrer",
            "referrerPolicy",
            "window",
            "duplex",
            ...isStale ? [] : [
              "signal"
            ]
          ];
          if (isRequestInput) {
            const reqInput = input;
            const reqOptions = {
              body: reqInput._ogBody || reqInput.body
            };
            for (const field of requestInputFields) {
              reqOptions[field] = reqInput[field];
            }
            input = new Request(reqInput.url, reqOptions);
          } else if (init) {
            const { _ogBody, body, signal, ...otherInput } = init;
            init = {
              ...otherInput,
              body: _ogBody || body,
              signal: isStale ? undefined : signal
            };
          }
          const clonedInit = {
            ...init,
            next: {
              ...init == null ? undefined : init.next,
              fetchType: "origin",
              fetchIdx
            }
          };
          return originFetch(input, clonedInit).then(async (res) => {
            if (!isStale) {
              trackFetchMetric(staticGenerationStore, {
                start: fetchStart,
                url: fetchUrl,
                cacheReason: cacheReasonOverride2 || cacheReason,
                cacheStatus: revalidate === 0 || cacheReasonOverride2 ? "skip" : "miss",
                status: res.status,
                method: clonedInit.method || "GET"
              });
            }
            if (res.status === 200 && staticGenerationStore.incrementalCache && cacheKey && isCacheableRevalidate) {
              const bodyBuffer = Buffer.from(await res.arrayBuffer());
              try {
                await staticGenerationStore.incrementalCache.set(cacheKey, {
                  kind: "FETCH",
                  data: {
                    headers: Object.fromEntries(res.headers.entries()),
                    body: bodyBuffer.toString("base64"),
                    status: res.status,
                    url: res.url
                  },
                  revalidate: normalizedRevalidate
                }, {
                  fetchCache: true,
                  revalidate,
                  fetchUrl,
                  fetchIdx,
                  tags
                });
              } catch (err) {
                console.warn(`Failed to set fetch cache`, input, err);
              }
              const response = new Response(bodyBuffer, {
                headers: new Headers(res.headers),
                status: res.status
              });
              Object.defineProperty(response, "url", {
                value: res.url
              });
              return response;
            }
            return res;
          });
        };
        let handleUnlock = () => Promise.resolve();
        let cacheReasonOverride;
        let isForegroundRevalidate = false;
        if (cacheKey && staticGenerationStore.incrementalCache) {
          handleUnlock = await staticGenerationStore.incrementalCache.lock(cacheKey);
          const entry = staticGenerationStore.isOnDemandRevalidate ? null : await staticGenerationStore.incrementalCache.get(cacheKey, {
            kindHint: "fetch",
            revalidate,
            fetchUrl,
            fetchIdx,
            tags,
            softTags: implicitTags
          });
          if (entry) {
            await handleUnlock();
          } else {
            cacheReasonOverride = "cache-control: no-cache (hard refresh)";
          }
          if ((entry == null ? undefined : entry.value) && entry.value.kind === "FETCH") {
            if (staticGenerationStore.isRevalidate && entry.isStale) {
              isForegroundRevalidate = true;
            } else {
              if (entry.isStale) {
                staticGenerationStore.pendingRevalidates ??= {};
                if (!staticGenerationStore.pendingRevalidates[cacheKey]) {
                  const pendingRevalidate = doOriginalFetch(true).then(async (response2) => ({
                    body: await response2.arrayBuffer(),
                    headers: response2.headers,
                    status: response2.status,
                    statusText: response2.statusText
                  })).finally(() => {
                    staticGenerationStore.pendingRevalidates ??= {};
                    delete staticGenerationStore.pendingRevalidates[cacheKey || ""];
                  });
                  pendingRevalidate.catch(console.error);
                  staticGenerationStore.pendingRevalidates[cacheKey] = pendingRevalidate;
                }
              }
              const resData = entry.value.data;
              trackFetchMetric(staticGenerationStore, {
                start: fetchStart,
                url: fetchUrl,
                cacheReason,
                cacheStatus: "hit",
                status: resData.status || 200,
                method: (init == null ? undefined : init.method) || "GET"
              });
              const response = new Response(Buffer.from(resData.body, "base64"), {
                headers: resData.headers,
                status: resData.status
              });
              Object.defineProperty(response, "url", {
                value: entry.value.data.url
              });
              return response;
            }
          }
        }
        if (staticGenerationStore.isStaticGeneration && init && typeof init === "object") {
          const { cache } = init;
          if (isEdgeRuntime)
            delete init.cache;
          if (!staticGenerationStore.forceStatic && cache === "no-store") {
            const dynamicUsageReason = `no-store fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : ""}`;
            (0, _dynamicrendering.trackDynamicFetch)(staticGenerationStore, dynamicUsageReason);
            staticGenerationStore.revalidate = 0;
            const err = new DynamicServerError(dynamicUsageReason);
            staticGenerationStore.dynamicUsageErr = err;
            staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
            throw err;
          }
          const hasNextConfig = "next" in init;
          const { next = {} } = init;
          if (typeof next.revalidate === "number" && (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && next.revalidate < staticGenerationStore.revalidate)) {
            if (!staticGenerationStore.forceDynamic && !staticGenerationStore.forceStatic && next.revalidate === 0) {
              const dynamicUsageReason = `revalidate: 0 fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : ""}`;
              (0, _dynamicrendering.trackDynamicFetch)(staticGenerationStore, dynamicUsageReason);
              const err = new DynamicServerError(dynamicUsageReason);
              staticGenerationStore.dynamicUsageErr = err;
              staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
              throw err;
            }
            if (!staticGenerationStore.forceStatic || next.revalidate !== 0) {
              staticGenerationStore.revalidate = next.revalidate;
            }
          }
          if (hasNextConfig)
            delete init.next;
        }
        if (cacheKey && isForegroundRevalidate) {
          staticGenerationStore.pendingRevalidates ??= {};
          let pendingRevalidate = staticGenerationStore.pendingRevalidates[cacheKey];
          if (pendingRevalidate) {
            const revalidatedResult = await pendingRevalidate;
            return new Response(revalidatedResult.body, {
              headers: revalidatedResult.headers,
              status: revalidatedResult.status,
              statusText: revalidatedResult.statusText
            });
          }
          const pendingResponse = doOriginalFetch(true, cacheReasonOverride).then(_cloneresponse.cloneResponse);
          pendingRevalidate = pendingResponse.then(async (responses) => {
            const response = responses[0];
            return {
              body: await response.arrayBuffer(),
              headers: response.headers,
              status: response.status,
              statusText: response.statusText
            };
          }).finally(() => {
            if (cacheKey) {
              var _staticGenerationStore_pendingRevalidates;
              if (!((_staticGenerationStore_pendingRevalidates = staticGenerationStore.pendingRevalidates) == null ? undefined : _staticGenerationStore_pendingRevalidates[cacheKey])) {
                return;
              }
              delete staticGenerationStore.pendingRevalidates[cacheKey];
            }
          });
          pendingRevalidate.catch(() => {});
          staticGenerationStore.pendingRevalidates[cacheKey] = pendingRevalidate;
          return pendingResponse.then((responses) => responses[1]);
        } else {
          return doOriginalFetch(false, cacheReasonOverride).finally(handleUnlock);
        }
      });
    };
    patched.__nextPatched = true;
    patched.__nextGetStaticStore = () => staticGenerationAsyncStorage;
    patched._nextOriginalFetch = originFetch;
    return patched;
  }
  function patchFetch(options) {
    if (isPatchedFetch(globalThis.fetch))
      return;
    const original = (0, _dedupefetch.createDedupeFetch)(globalThis.fetch);
    globalThis.fetch = createPatchedFetcher(original, options);
  }
});

// node_modules/next/dist/server/web/spec-extension/unstable-cache.js
var require_unstable_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "unstable_cache", {
    enumerable: true,
    get: function() {
      return unstable_cache;
    }
  });
  var _constants = require_constants();
  var _patchfetch = require_patch_fetch();
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  var noStoreFetchIdx = 0;
  async function cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {
    await incrementalCache.set(cacheKey, {
      kind: "FETCH",
      data: {
        headers: {},
        body: JSON.stringify(result),
        status: 200,
        url: ""
      },
      revalidate: typeof revalidate !== "number" ? _constants.CACHE_ONE_YEAR : revalidate
    }, {
      revalidate,
      fetchCache: true,
      tags,
      fetchIdx,
      fetchUrl
    });
    return;
  }
  function unstable_cache(cb, keyParts, options = {}) {
    if (options.revalidate === 0) {
      throw new Error(`Invariant revalidate: 0 can not be passed to unstable_cache(), must be "false" or "> 0" ${cb.toString()}`);
    }
    const tags = options.tags ? (0, _patchfetch.validateTags)(options.tags, `unstable_cache ${cb.toString()}`) : [];
    (0, _patchfetch.validateRevalidate)(options.revalidate, `unstable_cache ${cb.name || cb.toString()}`);
    const fixedKey = `${cb.toString()}-${Array.isArray(keyParts) && keyParts.join(",")}`;
    const cachedCb = async (...args) => {
      const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
      const maybeIncrementalCache = (store == null ? undefined : store.incrementalCache) || globalThis.__incrementalCache;
      if (!maybeIncrementalCache) {
        throw new Error(`Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`);
      }
      const incrementalCache = maybeIncrementalCache;
      const { pathname, searchParams } = new URL((store == null ? undefined : store.urlPathname) || "/", "http://n");
      const sortedSearchKeys = [
        ...searchParams.keys()
      ].sort((a, b) => {
        return a.localeCompare(b);
      });
      const sortedSearch = sortedSearchKeys.map((key) => `${key}=${searchParams.get(key)}`).join("&");
      const invocationKey = `${fixedKey}-${JSON.stringify(args)}`;
      const cacheKey = await incrementalCache.fetchCacheKey(invocationKey);
      const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? "?" : ""}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`;
      const fetchIdx = (store ? store.nextFetchId : noStoreFetchIdx) ?? 1;
      if (store) {
        store.nextFetchId = fetchIdx + 1;
        if (typeof options.revalidate === "number") {
          if (typeof store.revalidate === "number" && store.revalidate < options.revalidate) {} else {
            store.revalidate = options.revalidate;
          }
        } else if (options.revalidate === false && typeof store.revalidate === "undefined") {
          store.revalidate = options.revalidate;
        }
        if (!store.tags) {
          store.tags = tags.slice();
        } else {
          for (const tag of tags) {
            if (!store.tags.includes(tag)) {
              store.tags.push(tag);
            }
          }
        }
        const implicitTags = (0, _patchfetch.addImplicitTags)(store);
        if (store.fetchCache !== "force-no-store" && !store.isOnDemandRevalidate && !incrementalCache.isOnDemandRevalidate && !store.isDraftMode) {
          const cacheEntry = await incrementalCache.get(cacheKey, {
            kindHint: "fetch",
            revalidate: options.revalidate,
            tags,
            softTags: implicitTags,
            fetchIdx,
            fetchUrl
          });
          if (cacheEntry && cacheEntry.value) {
            if (cacheEntry.value.kind !== "FETCH") {
              console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);
            } else {
              const cachedResponse = cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;
              if (cacheEntry.isStale) {
                if (!store.pendingRevalidates) {
                  store.pendingRevalidates = {};
                }
                store.pendingRevalidates[invocationKey] = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.run({
                  ...store,
                  fetchCache: "force-no-store",
                  isUnstableCacheCallback: true
                }, cb, ...args).then((result2) => {
                  return cacheNewResult(result2, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
                }).catch((err) => console.error(`revalidating cache with key: ${invocationKey}`, err));
              }
              return cachedResponse;
            }
          }
        }
        const result = await _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.run({
          ...store,
          fetchCache: "force-no-store",
          isUnstableCacheCallback: true
        }, cb, ...args);
        if (!store.isDraftMode) {
          cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
        }
        return result;
      } else {
        noStoreFetchIdx += 1;
        if (!incrementalCache.isOnDemandRevalidate) {
          const implicitTags = store && (0, _patchfetch.addImplicitTags)(store);
          const cacheEntry = await incrementalCache.get(cacheKey, {
            kindHint: "fetch",
            revalidate: options.revalidate,
            tags,
            fetchIdx,
            fetchUrl,
            softTags: implicitTags
          });
          if (cacheEntry && cacheEntry.value) {
            if (cacheEntry.value.kind !== "FETCH") {
              console.error(`Invariant invalid cacheEntry returned for ${invocationKey}`);
            } else if (!cacheEntry.isStale) {
              return cacheEntry.value.data.body !== undefined ? JSON.parse(cacheEntry.value.data.body) : undefined;
            }
          }
        }
        const result = await _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.run({
          fetchCache: "force-no-store",
          isUnstableCacheCallback: true,
          urlPathname: "/",
          isStaticGeneration: false,
          prerenderState: null
        }, cb, ...args);
        cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
        return result;
      }
    };
    return cachedCb;
  }
});

// node_modules/next/dist/shared/lib/router/utils/sorted-routes.js
var require_sorted_routes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "getSortedRoutes", {
    enumerable: true,
    get: function() {
      return getSortedRoutes;
    }
  });

  class UrlNode {
    insert(urlPath) {
      this._insert(urlPath.split("/").filter(Boolean), [], false);
    }
    smoosh() {
      return this._smoosh();
    }
    _smoosh(prefix) {
      if (prefix === undefined)
        prefix = "/";
      const childrenPaths = [
        ...this.children.keys()
      ].sort();
      if (this.slugName !== null) {
        childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
      }
      if (this.restSlugName !== null) {
        childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
      }
      if (this.optionalRestSlugName !== null) {
        childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
      }
      const routes = childrenPaths.map((c) => this.children.get(c)._smoosh("" + prefix + c + "/")).reduce((prev, curr) => [
        ...prev,
        ...curr
      ], []);
      if (this.slugName !== null) {
        routes.push(...this.children.get("[]")._smoosh(prefix + "[" + this.slugName + "]/"));
      }
      if (!this.placeholder) {
        const r = prefix === "/" ? "/" : prefix.slice(0, -1);
        if (this.optionalRestSlugName != null) {
          throw new Error('You cannot define a route with the same specificity as a optional catch-all route ("' + r + '" and "' + r + "[[..." + this.optionalRestSlugName + ']]").');
        }
        routes.unshift(r);
      }
      if (this.restSlugName !== null) {
        routes.push(...this.children.get("[...]")._smoosh(prefix + "[..." + this.restSlugName + "]/"));
      }
      if (this.optionalRestSlugName !== null) {
        routes.push(...this.children.get("[[...]]")._smoosh(prefix + "[[..." + this.optionalRestSlugName + "]]/"));
      }
      return routes;
    }
    _insert(urlPaths, slugNames, isCatchAll) {
      if (urlPaths.length === 0) {
        this.placeholder = false;
        return;
      }
      if (isCatchAll) {
        throw new Error("Catch-all must be the last part of the URL.");
      }
      let nextSegment = urlPaths[0];
      if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
        let handleSlug = function(previousSlug, nextSlug) {
          if (previousSlug !== null) {
            if (previousSlug !== nextSlug) {
              throw new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "').");
            }
          }
          slugNames.forEach((slug) => {
            if (slug === nextSlug) {
              throw new Error('You cannot have the same slug name "' + nextSlug + '" repeat within a single dynamic path');
            }
            if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
              throw new Error('You cannot have the slug names "' + slug + '" and "' + nextSlug + '" differ only by non-word symbols within a single dynamic path');
            }
          });
          slugNames.push(nextSlug);
        };
        let segmentName = nextSegment.slice(1, -1);
        let isOptional = false;
        if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
          segmentName = segmentName.slice(1, -1);
          isOptional = true;
        }
        if (segmentName.startsWith("...")) {
          segmentName = segmentName.substring(3);
          isCatchAll = true;
        }
        if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
          throw new Error("Segment names may not start or end with extra brackets ('" + segmentName + "').");
        }
        if (segmentName.startsWith(".")) {
          throw new Error("Segment names may not start with erroneous periods ('" + segmentName + "').");
        }
        if (isCatchAll) {
          if (isOptional) {
            if (this.restSlugName != null) {
              throw new Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + urlPaths[0] + '" ).');
            }
            handleSlug(this.optionalRestSlugName, segmentName);
            this.optionalRestSlugName = segmentName;
            nextSegment = "[[...]]";
          } else {
            if (this.optionalRestSlugName != null) {
              throw new Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + urlPaths[0] + '").');
            }
            handleSlug(this.restSlugName, segmentName);
            this.restSlugName = segmentName;
            nextSegment = "[...]";
          }
        } else {
          if (isOptional) {
            throw new Error('Optional route parameters are not yet supported ("' + urlPaths[0] + '").');
          }
          handleSlug(this.slugName, segmentName);
          this.slugName = segmentName;
          nextSegment = "[]";
        }
      }
      if (!this.children.has(nextSegment)) {
        this.children.set(nextSegment, new UrlNode);
      }
      this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
    }
    constructor() {
      this.placeholder = true;
      this.children = new Map;
      this.slugName = null;
      this.restSlugName = null;
      this.optionalRestSlugName = null;
    }
  }
  function getSortedRoutes(normalizedPages) {
    const root = new UrlNode;
    normalizedPages.forEach((pagePath) => root.insert(pagePath));
    return root.smoosh();
  }
});

// node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js
var require_ensure_leading_slash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ensureLeadingSlash", {
    enumerable: true,
    get: function() {
      return ensureLeadingSlash;
    }
  });
  function ensureLeadingSlash(path) {
    return path.startsWith("/") ? path : "/" + path;
  }
});

// node_modules/next/dist/shared/lib/router/utils/app-paths.js
var require_app_paths = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    normalizeAppPath: function() {
      return normalizeAppPath;
    },
    normalizeRscURL: function() {
      return normalizeRscURL;
    }
  });
  var _ensureleadingslash = require_ensure_leading_slash();
  var _segment = require_segment();
  function normalizeAppPath(route) {
    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split("/").reduce((pathname, segment, index, segments) => {
      if (!segment) {
        return pathname;
      }
      if ((0, _segment.isGroupSegment)(segment)) {
        return pathname;
      }
      if (segment[0] === "@") {
        return pathname;
      }
      if ((segment === "page" || segment === "route") && index === segments.length - 1) {
        return pathname;
      }
      return pathname + "/" + segment;
    }, ""));
  }
  function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, "$1");
  }
});

// node_modules/next/dist/server/future/helpers/interception-routes.js
var require_interception_routes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    INTERCEPTION_ROUTE_MARKERS: function() {
      return INTERCEPTION_ROUTE_MARKERS;
    },
    extractInterceptionRouteInformation: function() {
      return extractInterceptionRouteInformation;
    },
    isInterceptionRouteAppPath: function() {
      return isInterceptionRouteAppPath;
    }
  });
  var _apppaths = require_app_paths();
  var INTERCEPTION_ROUTE_MARKERS = [
    "(..)(..)",
    "(.)",
    "(..)",
    "(...)"
  ];
  function isInterceptionRouteAppPath(path) {
    return path.split("/").find((segment) => INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))) !== undefined;
  }
  function extractInterceptionRouteInformation(path) {
    let interceptingRoute, marker, interceptedRoute;
    for (const segment of path.split("/")) {
      marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
      if (marker) {
        [interceptingRoute, interceptedRoute] = path.split(marker, 2);
        break;
      }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
      throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);
    }
    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute);
    switch (marker) {
      case "(.)":
        if (interceptingRoute === "/") {
          interceptedRoute = `/${interceptedRoute}`;
        } else {
          interceptedRoute = interceptingRoute + "/" + interceptedRoute;
        }
        break;
      case "(..)":
        if (interceptingRoute === "/") {
          throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);
        }
        interceptedRoute = interceptingRoute.split("/").slice(0, -1).concat(interceptedRoute).join("/");
        break;
      case "(...)":
        interceptedRoute = "/" + interceptedRoute;
        break;
      case "(..)(..)":
        const splitInterceptingRoute = interceptingRoute.split("/");
        if (splitInterceptingRoute.length <= 2) {
          throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);
        }
        interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join("/");
        break;
      default:
        throw new Error("Invariant: unexpected marker");
    }
    return {
      interceptingRoute,
      interceptedRoute
    };
  }
});

// node_modules/next/dist/shared/lib/router/utils/is-dynamic.js
var require_is_dynamic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isDynamicRoute", {
    enumerable: true,
    get: function() {
      return isDynamicRoute;
    }
  });
  var _interceptionroutes = require_interception_routes();
  var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
  function isDynamicRoute(route) {
    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
      route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
    }
    return TEST_ROUTE.test(route);
  }
});

// node_modules/next/dist/shared/lib/router/utils/index.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    getSortedRoutes: function() {
      return _sortedroutes.getSortedRoutes;
    },
    isDynamicRoute: function() {
      return _isdynamic.isDynamicRoute;
    }
  });
  var _sortedroutes = require_sorted_routes();
  var _isdynamic = require_is_dynamic();
});

// node_modules/next/dist/server/web/spec-extension/revalidate.js
var require_revalidate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    revalidatePath: function() {
      return revalidatePath;
    },
    revalidateTag: function() {
      return revalidateTag;
    }
  });
  var _dynamicrendering = require_dynamic_rendering();
  var _utils = require_utils3();
  var _constants = require_constants();
  var _url = require_url();
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  function revalidateTag(tag) {
    return revalidate(tag, `revalidateTag ${tag}`);
  }
  function revalidatePath(originalPath, type) {
    if (originalPath.length > _constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {
      console.warn(`Warning: revalidatePath received "${originalPath}" which exceeded max length of ${_constants.NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);
      return;
    }
    let normalizedPath = `${_constants.NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;
    if (type) {
      normalizedPath += `${normalizedPath.endsWith("/") ? "" : "/"}${type}`;
    } else if ((0, _utils.isDynamicRoute)(originalPath)) {
      console.warn(`Warning: a dynamic page path "${originalPath}" was passed to "revalidatePath", but the "type" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);
    }
    return revalidate(normalizedPath, `revalidatePath ${originalPath}`);
  }
  function revalidate(tag, expression) {
    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (!store || !store.incrementalCache) {
      throw new Error(`Invariant: static generation store missing in ${expression}`);
    }
    if (store.isUnstableCacheCallback) {
      throw new Error(`Route ${(0, _url.getPathname)(store.urlPathname)} used "${expression}" inside a function cached with "unstable_cache(...)" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    }
    (0, _dynamicrendering.trackDynamicDataAccessed)(store, expression);
    if (!store.revalidatedTags) {
      store.revalidatedTags = [];
    }
    if (!store.revalidatedTags.includes(tag)) {
      store.revalidatedTags.push(tag);
    }
    store.pathWasRevalidated = true;
  }
});

// node_modules/next/dist/server/web/spec-extension/unstable-no-store.js
var require_unstable_no_store = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "unstable_noStore", {
    enumerable: true,
    get: function() {
      return unstable_noStore;
    }
  });
  var _staticgenerationasyncstorageexternal = require_static_generation_async_storage_external();
  var _dynamicrendering = require_dynamic_rendering();
  function unstable_noStore() {
    const callingExpression = "unstable_noStore()";
    const store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();
    if (!store) {
      return;
    } else if (store.forceStatic) {
      return;
    } else {
      store.isUnstableNoStore = true;
      (0, _dynamicrendering.markCurrentScopeAsDynamic)(store, callingExpression);
    }
  }
});

// node_modules/next/cache.js
var require_cache = __commonJS((exports, module) => {
  var cacheExports = {
    unstable_cache: require_unstable_cache().unstable_cache,
    revalidateTag: require_revalidate().revalidateTag,
    revalidatePath: require_revalidate().revalidatePath,
    unstable_noStore: require_unstable_no_store().unstable_noStore
  };
  module.exports = cacheExports;
  exports.unstable_cache = cacheExports.unstable_cache;
  exports.revalidatePath = cacheExports.revalidatePath;
  exports.revalidateTag = cacheExports.revalidateTag;
  exports.unstable_noStore = cacheExports.unstable_noStore;
});

// node_modules/postmark/dist/client/errors/Errors.js
var require_Errors = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidEmailRequestError = exports.InactiveRecipientsError = exports.ApiInputError = exports.UnknownError = exports.RateLimitExceededError = exports.ServiceUnavailablerError = exports.InternalServerError = exports.InvalidAPIKeyError = exports.HttpError = exports.PostmarkError = undefined;
  var PostmarkError = function(_super) {
    __extends(PostmarkError2, _super);
    function PostmarkError2(message, code, statusCode) {
      if (code === undefined) {
        code = 0;
      }
      if (statusCode === undefined) {
        statusCode = 0;
      }
      var _this = _super.call(this, message) || this;
      _this.statusCode = statusCode;
      _this.code = code;
      Object.setPrototypeOf(_this, PostmarkError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    PostmarkError2.prototype.setUpStackTrace = function() {
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    };
    return PostmarkError2;
  }(Error);
  exports.PostmarkError = PostmarkError;
  var HttpError = function(_super) {
    __extends(HttpError2, _super);
    function HttpError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, HttpError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return HttpError2;
  }(PostmarkError);
  exports.HttpError = HttpError;
  var InvalidAPIKeyError = function(_super) {
    __extends(InvalidAPIKeyError2, _super);
    function InvalidAPIKeyError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, InvalidAPIKeyError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return InvalidAPIKeyError2;
  }(HttpError);
  exports.InvalidAPIKeyError = InvalidAPIKeyError;
  var InternalServerError = function(_super) {
    __extends(InternalServerError2, _super);
    function InternalServerError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, InternalServerError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return InternalServerError2;
  }(HttpError);
  exports.InternalServerError = InternalServerError;
  var ServiceUnavailablerError = function(_super) {
    __extends(ServiceUnavailablerError2, _super);
    function ServiceUnavailablerError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, ServiceUnavailablerError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return ServiceUnavailablerError2;
  }(HttpError);
  exports.ServiceUnavailablerError = ServiceUnavailablerError;
  var RateLimitExceededError = function(_super) {
    __extends(RateLimitExceededError2, _super);
    function RateLimitExceededError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, RateLimitExceededError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return RateLimitExceededError2;
  }(HttpError);
  exports.RateLimitExceededError = RateLimitExceededError;
  var UnknownError = function(_super) {
    __extends(UnknownError2, _super);
    function UnknownError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, UnknownError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return UnknownError2;
  }(HttpError);
  exports.UnknownError = UnknownError;
  var ApiInputError = function(_super) {
    __extends(ApiInputError2, _super);
    function ApiInputError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, ApiInputError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    ApiInputError2.buildSpecificError = function(message, code, statusCode) {
      switch (code) {
        case this.ERROR_CODES.inactiveRecipient:
          return new InactiveRecipientsError(message, code, statusCode);
        case this.ERROR_CODES.invalidEmailRequest:
          return new InvalidEmailRequestError(message, code, statusCode);
        default:
          return new ApiInputError2(message, code, statusCode);
      }
    };
    ApiInputError2.ERROR_CODES = {
      inactiveRecipient: 406,
      invalidEmailRequest: 300
    };
    return ApiInputError2;
  }(HttpError);
  exports.ApiInputError = ApiInputError;
  var InactiveRecipientsError = function(_super) {
    __extends(InactiveRecipientsError2, _super);
    function InactiveRecipientsError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, InactiveRecipientsError2.prototype);
      _this.setUpStackTrace();
      _this.recipients = InactiveRecipientsError2.parseInactiveRecipients(message);
      return _this;
    }
    InactiveRecipientsError2.parseInactiveRecipients = function(message) {
      var result = [];
      this.inactiveRecipientsPatterns.some(function(pattern) {
        var regexResult = message.match(pattern);
        if (regexResult !== null) {
          result = regexResult[1].split(",").map(function(element) {
            return element.trim();
          });
          return result;
        } else {
          result = [];
        }
      });
      return result;
    };
    InactiveRecipientsError2.inactiveRecipientsPatterns = [
      /Found inactive addresses: (.+?)\.? Inactive/,
      /these inactive addresses: (.+?)\.?$/
    ];
    return InactiveRecipientsError2;
  }(ApiInputError);
  exports.InactiveRecipientsError = InactiveRecipientsError;
  var InvalidEmailRequestError = function(_super) {
    __extends(InvalidEmailRequestError2, _super);
    function InvalidEmailRequestError2(message, code, statusCode) {
      var _this = _super.call(this, message, code, statusCode) || this;
      Object.setPrototypeOf(_this, InvalidEmailRequestError2.prototype);
      _this.setUpStackTrace();
      return _this;
    }
    return InvalidEmailRequestError2;
  }(ApiInputError);
  exports.InvalidEmailRequestError = InvalidEmailRequestError;
});

// node_modules/postmark/dist/client/errors/ErrorHandler.js
var require_ErrorHandler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorHandler = undefined;
  var Errors = require_Errors();
  var ErrorHandler = function() {
    function ErrorHandler2() {}
    ErrorHandler2.prototype.buildError = function(errorMessage, code, statusCode) {
      if (code === undefined) {
        code = 0;
      }
      if (statusCode === undefined) {
        statusCode = 0;
      }
      if (statusCode === 0 && code === 0) {
        return new Errors.PostmarkError(errorMessage);
      } else {
        return this.buildErrorByHttpStatusCode(errorMessage, code, statusCode);
      }
    };
    ErrorHandler2.prototype.buildErrorByHttpStatusCode = function(errorMessage, errorCode, errorStatusCode) {
      switch (errorStatusCode) {
        case 401:
          return new Errors.InvalidAPIKeyError(errorMessage, errorCode, errorStatusCode);
        case 404:
          return new Errors.PostmarkError(errorMessage, errorCode, errorStatusCode);
        case 422:
          return Errors.ApiInputError.buildSpecificError(errorMessage, errorCode, errorStatusCode);
        case 429:
          return new Errors.RateLimitExceededError(errorMessage, errorCode, errorStatusCode);
        case 500:
          return new Errors.InternalServerError(errorMessage, errorCode, errorStatusCode);
        case 503:
          return new Errors.ServiceUnavailablerError(errorMessage, errorCode, errorStatusCode);
        default:
          return new Errors.UnknownError(errorMessage, errorCode, errorStatusCode);
      }
    };
    return ErrorHandler2;
  }();
  exports.ErrorHandler = ErrorHandler;
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var util2 = __require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util2.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var util2 = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util2.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
  var defer = require_defer();
  module.exports = async;
  function async(callback) {
    var isAsync2 = false;
    defer(function() {
      isAsync2 = true;
    });
    return function async_callback(err, result) {
      if (isAsync2) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var async = require_async();
  var abort = require_abort();
  module.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var abort = require_abort();
  var async = require_async();
  module.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var $TypeError = require_type();
  var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
  module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag] = value;
      }
    }
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var CombinedStream = require_combined_stream();
  var util2 = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var setToStringTag = require_es_set_tostringtag();
  var populate = require_populate();
  module.exports = FormData2;
  util2.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, "fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug;
  module.exports = function() {
    if (!debug) {
      try {
        debug = require_src2()("follow-redirects");
      } catch (error) {}
      if (typeof debug !== "function") {
        debug = function() {};
      }
    }
    debug.apply(null, arguments);
  };
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
  var url = __require("url");
  var URL2 = url.URL;
  var http = __require("http");
  var https = __require("https");
  var Writable = __require("stream").Writable;
  var assert = __require("assert");
  var debug = require_debug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString(data) && !isBuffer(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString(options.host) && !isString(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  }
  function noop() {}
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isBuffer(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  module.exports = wrap({ http, https });
  module.exports.wrap = wrap;
});

// node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS((exports, module) => {
  /*! Axios v1.8.4 Copyright (c) 2025 Matt Zabriskie and contributors */
  var FormData$1 = require_form_data();
  var crypto = __require("crypto");
  var url = __require("url");
  var proxyFromEnv = require_proxy_from_env();
  var http = __require("http");
  var https = __require("https");
  var util2 = __require("util");
  var followRedirects = require_follow_redirects();
  var zlib = __require("zlib");
  var stream = __require("stream");
  var events = __require("events");
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { default: e };
  }
  var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
  var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
  var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
  var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
  var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
  var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
  var util__default = /* @__PURE__ */ _interopDefaultLegacy(util2);
  var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
  var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
  var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  var { toString } = Object.prototype;
  var { getPrototypeOf } = Object;
  var kindOf = ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(Object.create(null));
  var kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  var typeOfTest = (type) => (thing) => typeof thing === type;
  var { isArray } = Array;
  var isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  var isString = typeOfTest("string");
  var isFunction = typeOfTest("function");
  var isNumber = typeOfTest("number");
  var isObject = (thing) => thing !== null && typeof thing === "object";
  var isBoolean = (thing) => thing === true || thing === false;
  var isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  var isStream = (val) => isObject(val) && isFunction(val.pipe);
  var isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  var isURLSearchParams = kindOfTest("URLSearchParams");
  var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length;i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i = 0;i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  var isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length;i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  var stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  var inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  var endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === undefined || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  var toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i = thing.length;
    if (!isNumber(i))
      return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  var isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  var forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  var matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  var isHTMLForm = kindOfTest("HTMLFormElement");
  var toCamelCase = (str) => {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    });
  };
  var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  var isRegExp = kindOfTest("RegExp");
  var reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  var freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  var toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  var noop = () => {};
  var toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  var toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = undefined;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  var isAsyncFn = kindOfTest("AsyncFunction");
  var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(typeof setImmediate === "function", isFunction(_global.postMessage));
  var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  var utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  var prototype$1 = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (FormData__default["default"] || FormData);
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\x00"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  var prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode;
    if (utils$1.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }

  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  var InterceptorManager$1 = InterceptorManager;
  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var URLSearchParams2 = url__default["default"].URLSearchParams;
  var ALPHA = "abcdefghijklmnopqrstuvwxyz";
  var DIGIT = "0123456789";
  var ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length } = alphabet;
    const randomValues = new Uint32Array(size);
    crypto__default["default"].randomFillSync(randomValues);
    for (let i = 0;i < size; i++) {
      str += alphabet[randomValues[i] % length];
    }
    return str;
  };
  var platform$1 = {
    isNode: true,
    classes: {
      URLSearchParams: URLSearchParams2,
      FormData: FormData__default["default"],
      Blob: typeof Blob !== "undefined" && Blob || null
    },
    ALPHABET,
    generateString,
    protocols: ["http", "https", "file", "data"]
  };
  var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  var _navigator = typeof navigator === "object" && navigator || undefined;
  var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  var hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  var origin = hasBrowserEnv && window.location.href || "http://localhost";
  var utils = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    navigator: _navigator,
    origin
  });
  var platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams, Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__")
        return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": undefined
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults$1 = defaults;
  var ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split(`
`).forEach(function parser(line) {
      i = line.indexOf(":");
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  var $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value))
      return;
    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }

  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isHeaders(header)) {
        for (const [key, value] of header.entries()) {
          setHeader(value, key, rewrite);
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError("Request failed with status code " + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
  }
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  var VERSION = "1.8.4";
  function parseProtocol(url2) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match && match[1] || "";
  }
  var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  function fromDataURI(uri, asBlob, options) {
    const _Blob = options && options.Blob || platform.classes.Blob;
    const protocol = parseProtocol(uri);
    if (asBlob === undefined && _Blob) {
      asBlob = true;
    }
    if (protocol === "data") {
      uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
      const match = DATA_URL_PATTERN.exec(uri);
      if (!match) {
        throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
      }
      const mime = match[1];
      const isBase64 = match[2];
      const body = match[3];
      const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
      if (asBlob) {
        if (!_Blob) {
          throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
        }
        return new _Blob([buffer], { type: mime });
      }
      return buffer;
    }
    throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
  }
  var kInternals = Symbol("internals");

  class AxiosTransformStream extends stream__default["default"].Transform {
    constructor(options) {
      options = utils$1.toFlatObject(options, {
        maxRate: 0,
        chunkSize: 64 * 1024,
        minChunkSize: 100,
        timeWindow: 500,
        ticksRate: 2,
        samplesCount: 15
      }, null, (prop, source) => {
        return !utils$1.isUndefined(source[prop]);
      });
      super({
        readableHighWaterMark: options.chunkSize
      });
      const internals = this[kInternals] = {
        timeWindow: options.timeWindow,
        chunkSize: options.chunkSize,
        maxRate: options.maxRate,
        minChunkSize: options.minChunkSize,
        bytesSeen: 0,
        isCaptured: false,
        notifiedBytesLoaded: 0,
        ts: Date.now(),
        bytes: 0,
        onReadCallback: null
      };
      this.on("newListener", (event) => {
        if (event === "progress") {
          if (!internals.isCaptured) {
            internals.isCaptured = true;
          }
        }
      });
    }
    _read(size) {
      const internals = this[kInternals];
      if (internals.onReadCallback) {
        internals.onReadCallback();
      }
      return super._read(size);
    }
    _transform(chunk, encoding, callback) {
      const internals = this[kInternals];
      const maxRate = internals.maxRate;
      const readableHighWaterMark = this.readableHighWaterMark;
      const timeWindow = internals.timeWindow;
      const divider = 1000 / timeWindow;
      const bytesThreshold = maxRate / divider;
      const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
      const pushChunk = (_chunk, _callback) => {
        const bytes = Buffer.byteLength(_chunk);
        internals.bytesSeen += bytes;
        internals.bytes += bytes;
        internals.isCaptured && this.emit("progress", internals.bytesSeen);
        if (this.push(_chunk)) {
          process.nextTick(_callback);
        } else {
          internals.onReadCallback = () => {
            internals.onReadCallback = null;
            process.nextTick(_callback);
          };
        }
      };
      const transformChunk = (_chunk, _callback) => {
        const chunkSize = Buffer.byteLength(_chunk);
        let chunkRemainder = null;
        let maxChunkSize = readableHighWaterMark;
        let bytesLeft;
        let passed = 0;
        if (maxRate) {
          const now = Date.now();
          if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
            internals.ts = now;
            bytesLeft = bytesThreshold - internals.bytes;
            internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
            passed = 0;
          }
          bytesLeft = bytesThreshold - internals.bytes;
        }
        if (maxRate) {
          if (bytesLeft <= 0) {
            return setTimeout(() => {
              _callback(null, _chunk);
            }, timeWindow - passed);
          }
          if (bytesLeft < maxChunkSize) {
            maxChunkSize = bytesLeft;
          }
        }
        if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
          chunkRemainder = _chunk.subarray(maxChunkSize);
          _chunk = _chunk.subarray(0, maxChunkSize);
        }
        pushChunk(_chunk, chunkRemainder ? () => {
          process.nextTick(_callback, null, chunkRemainder);
        } : _callback);
      };
      transformChunk(chunk, function transformNextChunk(err, _chunk) {
        if (err) {
          return callback(err);
        }
        if (_chunk) {
          transformChunk(_chunk, transformNextChunk);
        } else {
          callback(null);
        }
      });
    }
  }
  var AxiosTransformStream$1 = AxiosTransformStream;
  var { asyncIterator } = Symbol;
  var readBlob = async function* (blob) {
    if (blob.stream) {
      yield* blob.stream();
    } else if (blob.arrayBuffer) {
      yield await blob.arrayBuffer();
    } else if (blob[asyncIterator]) {
      yield* blob[asyncIterator]();
    } else {
      yield blob;
    }
  };
  var readBlob$1 = readBlob;
  var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
  var textEncoder = typeof TextEncoder === "function" ? new TextEncoder : new util__default["default"].TextEncoder;
  var CRLF = `\r
`;
  var CRLF_BYTES = textEncoder.encode(CRLF);
  var CRLF_BYTES_COUNT = 2;

  class FormDataPart {
    constructor(name, value) {
      const { escapeName } = this.constructor;
      const isStringValue = utils$1.isString(value);
      let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
      if (isStringValue) {
        value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
      } else {
        headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
      }
      this.headers = textEncoder.encode(headers + CRLF);
      this.contentLength = isStringValue ? value.byteLength : value.size;
      this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
      this.name = name;
      this.value = value;
    }
    async* encode() {
      yield this.headers;
      const { value } = this;
      if (utils$1.isTypedArray(value)) {
        yield value;
      } else {
        yield* readBlob$1(value);
      }
      yield CRLF_BYTES;
    }
    static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        "\r": "%0D",
        "\n": "%0A",
        '"': "%22"
      })[match]);
    }
  }
  var formDataToStream = (form, headersHandler, options) => {
    const {
      tag = "form-data-boundary",
      size = 25,
      boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
    } = options || {};
    if (!utils$1.isFormData(form)) {
      throw TypeError("FormData instance required");
    }
    if (boundary.length < 1 || boundary.length > 70) {
      throw Error("boundary must be 10-70 characters long");
    }
    const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
    const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
    let contentLength = footerBytes.byteLength;
    const parts = Array.from(form.entries()).map(([name, value]) => {
      const part = new FormDataPart(name, value);
      contentLength += part.size;
      return part;
    });
    contentLength += boundaryBytes.byteLength * parts.length;
    contentLength = utils$1.toFiniteNumber(contentLength);
    const computedHeaders = {
      "Content-Type": `multipart/form-data; boundary=${boundary}`
    };
    if (Number.isFinite(contentLength)) {
      computedHeaders["Content-Length"] = contentLength;
    }
    headersHandler && headersHandler(computedHeaders);
    return stream.Readable.from(async function* () {
      for (const part of parts) {
        yield boundaryBytes;
        yield* part.encode();
      }
      yield footerBytes;
    }());
  };
  var formDataToStream$1 = formDataToStream;

  class ZlibHeaderTransformStream extends stream__default["default"].Transform {
    __transform(chunk, encoding, callback) {
      this.push(chunk);
      callback();
    }
    _transform(chunk, encoding, callback) {
      if (chunk.length !== 0) {
        this._transform = this.__transform;
        if (chunk[0] !== 120) {
          const header = Buffer.alloc(2);
          header[0] = 120;
          header[1] = 156;
          this.push(header, encoding);
        }
      }
      this.__transform(chunk, encoding, callback);
    }
  }
  var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
  var callbackify = (fn, reducer) => {
    return utils$1.isAsyncFn(fn) ? function(...args) {
      const cb = args.pop();
      fn.apply(this, args).then((value) => {
        try {
          reducer ? cb(null, ...reducer(value)) : cb(null, value);
        } catch (err) {
          cb(err);
        }
      }, cb);
    } : fn;
  };
  var callbackify$1 = callbackify;
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1000 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : undefined;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : undefined,
        bytes: progressBytes,
        rate: rate ? rate : undefined,
        estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  var progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  var zlibOptions = {
    flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
    finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
  };
  var brotliOptions = {
    flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
    finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
  };
  var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
  var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
  var isHttps = /https:?/;
  var supportedProtocols = platform.protocols.map((protocol) => {
    return protocol + ":";
  });
  var flushOnFinish = (stream2, [throttled, flush]) => {
    stream2.on("end", flush).on("error", flush);
    return throttled;
  };
  function dispatchBeforeRedirect(options, responseDetails) {
    if (options.beforeRedirects.proxy) {
      options.beforeRedirects.proxy(options);
    }
    if (options.beforeRedirects.config) {
      options.beforeRedirects.config(options, responseDetails);
    }
  }
  function setProxy(options, configProxy, location) {
    let proxy = configProxy;
    if (!proxy && proxy !== false) {
      const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
      if (proxyUrl) {
        proxy = new URL(proxyUrl);
      }
    }
    if (proxy) {
      if (proxy.username) {
        proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
      }
      if (proxy.auth) {
        if (proxy.auth.username || proxy.auth.password) {
          proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
        }
        const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
      const proxyHost = proxy.hostname || proxy.host;
      options.hostname = proxyHost;
      options.host = proxyHost;
      options.port = proxy.port;
      options.path = location;
      if (proxy.protocol) {
        options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
      }
    }
    options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
      setProxy(redirectOptions, configProxy, redirectOptions.href);
    };
  }
  var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
  var wrapAsync = (asyncExecutor) => {
    return new Promise((resolve, reject) => {
      let onDone;
      let isDone;
      const done = (value, isRejected) => {
        if (isDone)
          return;
        isDone = true;
        onDone && onDone(value, isRejected);
      };
      const _resolve = (value) => {
        done(value);
        resolve(value);
      };
      const _reject = (reason) => {
        done(reason, true);
        reject(reason);
      };
      asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
    });
  };
  var resolveFamily = ({ address, family }) => {
    if (!utils$1.isString(address)) {
      throw TypeError("address must be a string");
    }
    return {
      address,
      family: family || (address.indexOf(".") < 0 ? 6 : 4)
    };
  };
  var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
  var httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
    return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
      let { data, lookup, family } = config;
      const { responseType, responseEncoding } = config;
      const method = config.method.toUpperCase();
      let isDone;
      let rejected = false;
      let req;
      if (lookup) {
        const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
        lookup = (hostname, opt, cb) => {
          _lookup(hostname, opt, (err, arg0, arg1) => {
            if (err) {
              return cb(err);
            }
            const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
            opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
          });
        };
      }
      const emitter = new events.EventEmitter;
      const onFinished = () => {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(abort);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", abort);
        }
        emitter.removeAllListeners();
      };
      onDone((value, isRejected) => {
        isDone = true;
        if (isRejected) {
          rejected = true;
          onFinished();
        }
      });
      function abort(reason) {
        emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
      }
      emitter.once("abort", reject);
      if (config.cancelToken || config.signal) {
        config.cancelToken && config.cancelToken.subscribe(abort);
        if (config.signal) {
          config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
        }
      }
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
      const protocol = parsed.protocol || supportedProtocols[0];
      if (protocol === "data:") {
        let convertedData;
        if (method !== "GET") {
          return settle(resolve, reject, {
            status: 405,
            statusText: "method not allowed",
            headers: {},
            config
          });
        }
        try {
          convertedData = fromDataURI(config.url, responseType === "blob", {
            Blob: config.env && config.env.Blob
          });
        } catch (err) {
          throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
        }
        if (responseType === "text") {
          convertedData = convertedData.toString(responseEncoding);
          if (!responseEncoding || responseEncoding === "utf8") {
            convertedData = utils$1.stripBOM(convertedData);
          }
        } else if (responseType === "stream") {
          convertedData = stream__default["default"].Readable.from(convertedData);
        }
        return settle(resolve, reject, {
          data: convertedData,
          status: 200,
          statusText: "OK",
          headers: new AxiosHeaders$1,
          config
        });
      }
      if (supportedProtocols.indexOf(protocol) === -1) {
        return reject(new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_BAD_REQUEST, config));
      }
      const headers = AxiosHeaders$1.from(config.headers).normalize();
      headers.set("User-Agent", "axios/" + VERSION, false);
      const { onUploadProgress, onDownloadProgress } = config;
      const maxRate = config.maxRate;
      let maxUploadRate = undefined;
      let maxDownloadRate = undefined;
      if (utils$1.isSpecCompliantForm(data)) {
        const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
        data = formDataToStream$1(data, (formHeaders) => {
          headers.set(formHeaders);
        }, {
          tag: `axios-${VERSION}-boundary`,
          boundary: userBoundary && userBoundary[1] || undefined
        });
      } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
        headers.set(data.getHeaders());
        if (!headers.hasContentLength()) {
          try {
            const knownLength = await util__default["default"].promisify(data.getLength).call(data);
            Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          } catch (e) {}
        }
      } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
        data.size && headers.setContentType(data.type || "application/octet-stream");
        headers.setContentLength(data.size || 0);
        data = stream__default["default"].Readable.from(readBlob$1(data));
      } else if (data && !utils$1.isStream(data)) {
        if (Buffer.isBuffer(data))
          ;
        else if (utils$1.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils$1.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(new AxiosError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError.ERR_BAD_REQUEST, config));
        }
        headers.setContentLength(data.length, false);
        if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
          return reject(new AxiosError("Request body larger than maxBodyLength limit", AxiosError.ERR_BAD_REQUEST, config));
        }
      }
      const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
      if (utils$1.isArray(maxRate)) {
        maxUploadRate = maxRate[0];
        maxDownloadRate = maxRate[1];
      } else {
        maxUploadRate = maxDownloadRate = maxRate;
      }
      if (data && (onUploadProgress || maxUploadRate)) {
        if (!utils$1.isStream(data)) {
          data = stream__default["default"].Readable.from(data, { objectMode: false });
        }
        data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxUploadRate)
        })], utils$1.noop);
        onUploadProgress && data.on("progress", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
      }
      let auth = undefined;
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        auth = username + ":" + password;
      }
      if (!auth && parsed.username) {
        const urlUsername = parsed.username;
        const urlPassword = parsed.password;
        auth = urlUsername + ":" + urlPassword;
      }
      auth && headers.delete("authorization");
      let path;
      try {
        path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
      } catch (err) {
        const customErr = new Error(err.message);
        customErr.config = config;
        customErr.url = config.url;
        customErr.exists = true;
        return reject(customErr);
      }
      headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
      const options = {
        path,
        method,
        headers: headers.toJSON(),
        agents: { http: config.httpAgent, https: config.httpsAgent },
        auth,
        protocol,
        family,
        beforeRedirect: dispatchBeforeRedirect,
        beforeRedirects: {}
      };
      !utils$1.isUndefined(lookup) && (options.lookup = lookup);
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
        options.port = parsed.port;
        setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      let transport;
      const isHttpsRequest = isHttps.test(options.protocol);
      options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsRequest ? https__default["default"] : http__default["default"];
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        if (config.beforeRedirect) {
          options.beforeRedirects.config = config.beforeRedirect;
        }
        transport = isHttpsRequest ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      } else {
        options.maxBodyLength = Infinity;
      }
      if (config.insecureHTTPParser) {
        options.insecureHTTPParser = config.insecureHTTPParser;
      }
      req = transport.request(options, function handleResponse(res) {
        if (req.destroyed)
          return;
        const streams = [res];
        const responseLength = +res.headers["content-length"];
        if (onDownloadProgress || maxDownloadRate) {
          const transformStream = new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxDownloadRate)
          });
          onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
          streams.push(transformStream);
        }
        let responseStream = res;
        const lastRequest = res.req || req;
        if (config.decompress !== false && res.headers["content-encoding"]) {
          if (method === "HEAD" || res.statusCode === 204) {
            delete res.headers["content-encoding"];
          }
          switch ((res.headers["content-encoding"] || "").toLowerCase()) {
            case "gzip":
            case "x-gzip":
            case "compress":
            case "x-compress":
              streams.push(zlib__default["default"].createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "deflate":
              streams.push(new ZlibHeaderTransformStream$1);
              streams.push(zlib__default["default"].createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "br":
              if (isBrotliSupported) {
                streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                delete res.headers["content-encoding"];
              }
          }
        }
        responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
        const offListeners = stream__default["default"].finished(responseStream, () => {
          offListeners();
          onFinished();
        });
        const response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: new AxiosHeaders$1(res.headers),
          config,
          request: lastRequest
        };
        if (responseType === "stream") {
          response.data = responseStream;
          settle(resolve, reject, response);
        } else {
          const responseBuffer = [];
          let totalResponseBytes = 0;
          responseStream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
              rejected = true;
              responseStream.destroy();
              reject(new AxiosError("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
            }
          });
          responseStream.on("aborted", function handlerStreamAborted() {
            if (rejected) {
              return;
            }
            const err = new AxiosError("stream has been aborted", AxiosError.ERR_BAD_RESPONSE, config, lastRequest);
            responseStream.destroy(err);
            reject(err);
          });
          responseStream.on("error", function handleStreamError(err) {
            if (req.destroyed)
              return;
            reject(AxiosError.from(err, null, config, lastRequest));
          });
          responseStream.on("end", function handleStreamEnd() {
            try {
              let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (responseType !== "arraybuffer") {
                responseData = responseData.toString(responseEncoding);
                if (!responseEncoding || responseEncoding === "utf8") {
                  responseData = utils$1.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              return reject(AxiosError.from(err, null, config, response.request, response));
            }
            settle(resolve, reject, response);
          });
        }
        emitter.once("abort", (err) => {
          if (!responseStream.destroyed) {
            responseStream.emit("error", err);
            responseStream.destroy();
          }
        });
      });
      emitter.once("abort", (err) => {
        reject(err);
        req.destroy(err);
      });
      req.on("error", function handleRequestError(err) {
        reject(AxiosError.from(err, null, config, req));
      });
      req.on("socket", function handleRequestSocket(socket) {
        socket.setKeepAlive(true, 1000 * 60);
      });
      if (config.timeout) {
        const timeout = parseInt(config.timeout, 10);
        if (Number.isNaN(timeout)) {
          reject(new AxiosError("error trying to parse `config.timeout` to int", AxiosError.ERR_BAD_OPTION_VALUE, config, req));
          return;
        }
        req.setTimeout(timeout, function handleRequestTimeout() {
          if (isDone)
            return;
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));
          abort();
        });
      }
      if (utils$1.isStream(data)) {
        let ended = false;
        let errored = false;
        data.on("end", () => {
          ended = true;
        });
        data.once("error", (err) => {
          errored = true;
          req.destroy(err);
        });
        data.on("close", () => {
          if (!ended && !errored) {
            abort(new CanceledError("Request stream has been aborted", config, req));
          }
        });
        data.pipe(req);
      } else {
        req.end(data);
      }
    });
  };
  var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
    url2 = new URL(url2, platform.origin);
    return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
  })(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => true;
  var cookies = platform.hasStandardBrowserEnv ? {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 86400000);
    }
  } : {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };
  var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(undefined, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var resolveConfig = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(undefined);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest;
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      requestData === undefined && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  var composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController;
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals$1 = composeSignals;
  var streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  var readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  var readStream = async function* (stream2) {
    if (stream2[Symbol.asyncIterator]) {
      yield* stream2;
      return;
    }
    const reader = stream2.getReader();
    try {
      for (;; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream2, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  var test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  var supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream,
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  var DEFAULT_CHUNK_SIZE = 64 * 1024;
  var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  var resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response);
  var getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  var resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  var fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url2, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : undefined
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }), options);
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request), {
          cause: err.cause || err
        });
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  });
  var knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {}
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  var renderReason = (reason) => `- ${reason}`;
  var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  var adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0;i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === undefined) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
        let s = length ? reasons.length > 1 ? `since :
` + reasons.map(renderReason).join(`
`) : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(config, config.transformRequest);
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(config, config.transformResponse, response);
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(config, config.transformResponse, reason.response);
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError.ERR_DEPRECATED);
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === undefined || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator = {
    assertOptions,
    validators: validators$1
  };
  var validators = validator.validators;

  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1,
        response: new InterceptorManager$1
      };
    }
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error;
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += `
` + stack;
            }
          } catch (e) {}
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== undefined)
        ;
      else if (this.defaults.allowAbsoluteUrls !== undefined) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);
      headers && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
        delete headers[method];
      });
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), undefined];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios$1 = Axios;

  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController;
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  var CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  var HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  module.exports = axios;
});

// node_modules/postmark/dist/client/models/client/ClientOptions.js
var require_ClientOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientOptions = undefined;
  var ClientOptions;
  (function(ClientOptions2) {
    var Configuration = function() {
      function Configuration2(useHttps, requestHost, timeout) {
        this.useHttps = useHttps;
        this.requestHost = requestHost;
        this.timeout = timeout;
      }
      return Configuration2;
    }();
    ClientOptions2.Configuration = Configuration;
    var HttpMethod;
    (function(HttpMethod2) {
      HttpMethod2["GET"] = "GET";
      HttpMethod2["POST"] = "POST";
      HttpMethod2["DELETE"] = "DELETE";
      HttpMethod2["PUT"] = "PUT";
      HttpMethod2["OPTIONS"] = "OPTIONS";
      HttpMethod2["HEAD"] = "HEAD";
      HttpMethod2["PATCH"] = "PATCH";
    })(HttpMethod = ClientOptions2.HttpMethod || (ClientOptions2.HttpMethod = {}));
    var AuthHeaderNames;
    (function(AuthHeaderNames2) {
      AuthHeaderNames2["SERVER_TOKEN"] = "X-Postmark-Server-Token";
      AuthHeaderNames2["ACCOUNT_TOKEN"] = "X-Postmark-Account-Token";
    })(AuthHeaderNames = ClientOptions2.AuthHeaderNames || (ClientOptions2.AuthHeaderNames = {}));
  })(ClientOptions = exports.ClientOptions || (exports.ClientOptions = {}));
});

// node_modules/postmark/dist/client/models/client/SupportingTypes.js
var require_SupportingTypes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/client/HttpClient.js
var require_HttpClient = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = undefined;
  var HttpClient = function() {
    function HttpClient2(configOptions) {
      this.clientOptions = __assign(__assign({}, HttpClient2.DefaultOptions), configOptions);
      this.initHttpClient(this.clientOptions);
    }
    HttpClient2.prototype.getBaseHttpRequestURL = function() {
      var scheme = this.clientOptions.useHttps ? "https" : "http";
      return "".concat(scheme, "://").concat(this.clientOptions.requestHost);
    };
    HttpClient2.DefaultOptions = {
      useHttps: true,
      requestHost: "api.postmarkapp.com",
      timeout: 180
    };
    return HttpClient2;
  }();
  exports.HttpClient = HttpClient;
});

// node_modules/postmark/dist/client/models/client/Callback.js
var require_Callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/client/DefaultResponse.js
var require_DefaultResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/client/FilteringParameters.js
var require_FilteringParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FilteringParameters = undefined;
  var FilteringParameters = function() {
    function FilteringParameters2(count, offset) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      this.count = count;
      this.offset = offset;
    }
    return FilteringParameters2;
  }();
  exports.FilteringParameters = FilteringParameters;
});

// node_modules/postmark/dist/client/models/bounces/Bounce.js
var require_Bounce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BounceTypeCode = exports.BounceType = undefined;
  var BounceType;
  (function(BounceType2) {
    BounceType2["HardBounce"] = "HardBounce";
    BounceType2["Transient"] = "Transient";
    BounceType2["Unsubscribe"] = "Unsubscribe";
    BounceType2["Subscribe"] = "Subscribe";
    BounceType2["AutoResponder"] = "AutoResponder";
    BounceType2["AddressChange"] = "AddressChange";
    BounceType2["DnsError"] = "DnsError";
    BounceType2["SpamNotification"] = "SpamNotification";
    BounceType2["OpenRelayTest"] = "OpenRelayTest";
    BounceType2["Unknown"] = "Unknown";
    BounceType2["SoftBounce"] = "SoftBounce";
    BounceType2["VirusNotification"] = "VirusNotification";
    BounceType2["ChallengeVerification"] = "ChallengeVerification";
    BounceType2["BadEmailAddress"] = "BadEmailAddress";
    BounceType2["SpamComplaint"] = "SpamComplaint";
    BounceType2["ManuallyDeactivated"] = "ManuallyDeactivated";
    BounceType2["Unconfirmed"] = "Unconfirmed";
    BounceType2["Blocked"] = "Blocked";
    BounceType2["SMTPApiError"] = "SMTPApiError";
    BounceType2["InboundError"] = "InboundError";
    BounceType2["DMARCPolicy"] = "DMARCPolicy";
    BounceType2["TemplateRenderingFailed"] = "TemplateRenderingFailed";
  })(BounceType = exports.BounceType || (exports.BounceType = {}));
  var BounceTypeCode;
  (function(BounceTypeCode2) {
    BounceTypeCode2[BounceTypeCode2["HardBounce"] = 1] = "HardBounce";
    BounceTypeCode2[BounceTypeCode2["Transient"] = 2] = "Transient";
    BounceTypeCode2[BounceTypeCode2["Unsubscribe"] = 16] = "Unsubscribe";
    BounceTypeCode2[BounceTypeCode2["Subscribe"] = 32] = "Subscribe";
    BounceTypeCode2[BounceTypeCode2["AutoResponder"] = 64] = "AutoResponder";
    BounceTypeCode2[BounceTypeCode2["AddressChange"] = 128] = "AddressChange";
    BounceTypeCode2[BounceTypeCode2["DnsError"] = 256] = "DnsError";
    BounceTypeCode2[BounceTypeCode2["SpamNotification"] = 512] = "SpamNotification";
    BounceTypeCode2[BounceTypeCode2["OpenRelayTest"] = 1024] = "OpenRelayTest";
    BounceTypeCode2[BounceTypeCode2["Unknown"] = 2048] = "Unknown";
    BounceTypeCode2[BounceTypeCode2["SoftBounce"] = 4096] = "SoftBounce";
    BounceTypeCode2[BounceTypeCode2["VirusNotification"] = 8192] = "VirusNotification";
    BounceTypeCode2[BounceTypeCode2["ChallengeVerification"] = 16384] = "ChallengeVerification";
    BounceTypeCode2[BounceTypeCode2["BadEmailAddress"] = 1e5] = "BadEmailAddress";
    BounceTypeCode2[BounceTypeCode2["SpamComplaint"] = 100001] = "SpamComplaint";
    BounceTypeCode2[BounceTypeCode2["ManuallyDeactivated"] = 100002] = "ManuallyDeactivated";
    BounceTypeCode2[BounceTypeCode2["Unconfirmed"] = 100003] = "Unconfirmed";
    BounceTypeCode2[BounceTypeCode2["Blocked"] = 100006] = "Blocked";
    BounceTypeCode2[BounceTypeCode2["SMTPApiError"] = 100007] = "SMTPApiError";
    BounceTypeCode2[BounceTypeCode2["InboundError"] = 100008] = "InboundError";
    BounceTypeCode2[BounceTypeCode2["DMARCPolicy"] = 100009] = "DMARCPolicy";
    BounceTypeCode2[BounceTypeCode2["TemplateRenderingFailed"] = 100010] = "TemplateRenderingFailed";
  })(BounceTypeCode = exports.BounceTypeCode || (exports.BounceTypeCode = {}));
});

// node_modules/postmark/dist/client/models/bounces/BounceFilteringParameters.js
var require_BounceFilteringParameters = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BounceFilteringParameters = undefined;
  var FilteringParameters_1 = require_FilteringParameters();
  var BounceFilteringParameters = function(_super) {
    __extends(BounceFilteringParameters2, _super);
    function BounceFilteringParameters2(count, offset, type, inactive, emailFilter, tag, messageID, fromDate, toDate, messageStream) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.type = type;
      _this.inactive = inactive;
      _this.emailFilter = emailFilter;
      _this.tag = tag;
      _this.messageID = messageID;
      _this.fromDate = fromDate;
      _this.toDate = toDate;
      _this.messageStream = messageStream;
      return _this;
    }
    return BounceFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.BounceFilteringParameters = BounceFilteringParameters;
});

// node_modules/postmark/dist/client/models/message/Message.js
var require_Message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Message = undefined;
  var Message = function() {
    function Message2(From, Subject, HtmlBody, TextBody, To, Cc, Bcc, ReplyTo, Tag, TrackOpens, TrackLinks, Headers2, Attachments, Metadata) {
      this.From = From;
      this.To = To;
      this.Cc = Cc;
      this.Bcc = Bcc;
      this.Subject = Subject;
      this.ReplyTo = ReplyTo;
      this.HtmlBody = HtmlBody;
      this.TextBody = TextBody;
      this.Tag = Tag;
      this.TrackOpens = TrackOpens;
      this.TrackLinks = TrackLinks;
      this.Headers = Headers2;
      this.Attachments = Attachments;
      this.Metadata = Metadata;
    }
    return Message2;
  }();
  exports.Message = Message;
});

// node_modules/postmark/dist/client/models/message/SupportingTypes.js
var require_SupportingTypes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Attachment = exports.Header = exports.ServerDeliveryTypes = exports.LinkClickLocation = exports.LinkTrackingOptions = undefined;
  var LinkTrackingOptions;
  (function(LinkTrackingOptions2) {
    LinkTrackingOptions2["TextOnly"] = "TextOnly";
    LinkTrackingOptions2["HtmlOnly"] = "HtmlOnly";
    LinkTrackingOptions2["HtmlAndText"] = "HtmlAndText";
    LinkTrackingOptions2["None"] = "None";
  })(LinkTrackingOptions = exports.LinkTrackingOptions || (exports.LinkTrackingOptions = {}));
  var LinkClickLocation;
  (function(LinkClickLocation2) {
    LinkClickLocation2["HTML"] = "HTML";
    LinkClickLocation2["Text"] = "Text";
  })(LinkClickLocation = exports.LinkClickLocation || (exports.LinkClickLocation = {}));
  var ServerDeliveryTypes;
  (function(ServerDeliveryTypes2) {
    ServerDeliveryTypes2["Live"] = "Live";
    ServerDeliveryTypes2["Sandbox"] = "Sandbox";
  })(ServerDeliveryTypes = exports.ServerDeliveryTypes || (exports.ServerDeliveryTypes = {}));
  var Header = function() {
    function Header2(Name, Value) {
      this.Name = Name;
      this.Value = Value;
    }
    return Header2;
  }();
  exports.Header = Header;
  var Attachment = function() {
    function Attachment2(Name, Content, ContentType, ContentID, ContentLength, Disposition) {
      if (ContentID === undefined) {
        ContentID = null;
      }
      this.Name = Name;
      this.Content = Content;
      this.ContentType = ContentType;
      this.ContentID = ContentID;
      this.ContentLength = ContentLength;
      this.Disposition = Disposition;
    }
    return Attachment2;
  }();
  exports.Attachment = Attachment;
});

// node_modules/postmark/dist/client/models/messages/OutboundMessage.js
var require_OutboundMessage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/messages/OutboundMessageOpen.js
var require_OutboundMessageOpen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/messages/OutboundMessageClick.js
var require_OutboundMessageClick = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/messages/InboundMessage.js
var require_InboundMessage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/messages/MessageFilteringParameters.js
var require_MessageFilteringParameters = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OutboundMessageClicksFilteringParameters = exports.OutboundMessageOpensFilteringParameters = exports.OutboundMessageTrackingFilteringParameters = exports.InboundMessagesFilteringParameters = exports.OutboundMessagesFilteringParameters = exports.InboundMessageStatus = exports.OutboundMessageStatus = undefined;
  var FilteringParameters_1 = require_FilteringParameters();
  var OutboundMessageStatus;
  (function(OutboundMessageStatus2) {
    OutboundMessageStatus2["Queued"] = "queued";
    OutboundMessageStatus2["Sent"] = "sent";
    OutboundMessageStatus2["Processed"] = "processed";
  })(OutboundMessageStatus = exports.OutboundMessageStatus || (exports.OutboundMessageStatus = {}));
  var InboundMessageStatus;
  (function(InboundMessageStatus2) {
    InboundMessageStatus2["Queued"] = "queued";
    InboundMessageStatus2["Sent"] = "sent";
    InboundMessageStatus2["Processed"] = "processed";
    InboundMessageStatus2["Blocked"] = "blocked";
    InboundMessageStatus2["Failed"] = "failed";
    InboundMessageStatus2["Scheduled"] = "scheduled";
  })(InboundMessageStatus = exports.InboundMessageStatus || (exports.InboundMessageStatus = {}));
  var OutboundMessagesFilteringParameters = function(_super) {
    __extends(OutboundMessagesFilteringParameters2, _super);
    function OutboundMessagesFilteringParameters2(count, offset, recipient, fromEmail, tag, status, fromDate, toDate, subject, messageStream) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.recipient = recipient;
      _this.fromEmail = fromEmail;
      _this.tag = tag;
      _this.status = status;
      _this.fromDate = fromDate;
      _this.toDate = toDate;
      _this.subject = subject;
      _this.messageStream = messageStream;
      return _this;
    }
    return OutboundMessagesFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.OutboundMessagesFilteringParameters = OutboundMessagesFilteringParameters;
  var InboundMessagesFilteringParameters = function(_super) {
    __extends(InboundMessagesFilteringParameters2, _super);
    function InboundMessagesFilteringParameters2(count, offset, mailboxHash, recipient, fromEmail, tag, status, fromDate, toDate, subject) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.status = status;
      _this.mailboxHash = mailboxHash;
      _this.recipient = recipient;
      _this.fromEmail = fromEmail;
      _this.tag = tag;
      _this.fromDate = fromDate;
      _this.toDate = toDate;
      _this.subject = subject;
      return _this;
    }
    return InboundMessagesFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.InboundMessagesFilteringParameters = InboundMessagesFilteringParameters;
  var OutboundMessageTrackingFilteringParameters = function(_super) {
    __extends(OutboundMessageTrackingFilteringParameters2, _super);
    function OutboundMessageTrackingFilteringParameters2(count, offset, recipient, tag, client_name, client_company, client_family, os_name, os_family, os_company, platform, country, region, city, messageStream) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.recipient = recipient;
      _this.tag = tag;
      _this.client_name = client_name;
      _this.client_company = client_company;
      _this.client_family = client_family;
      _this.os_name = os_name;
      _this.os_family = os_family;
      _this.os_company = os_company;
      _this.platform = platform;
      _this.country = country;
      _this.region = region;
      _this.city = city;
      _this.messageStream = messageStream;
      return _this;
    }
    return OutboundMessageTrackingFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.OutboundMessageTrackingFilteringParameters = OutboundMessageTrackingFilteringParameters;
  var OutboundMessageOpensFilteringParameters = function(_super) {
    __extends(OutboundMessageOpensFilteringParameters2, _super);
    function OutboundMessageOpensFilteringParameters2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageOpensFilteringParameters2;
  }(OutboundMessageTrackingFilteringParameters);
  exports.OutboundMessageOpensFilteringParameters = OutboundMessageOpensFilteringParameters;
  var OutboundMessageClicksFilteringParameters = function(_super) {
    __extends(OutboundMessageClicksFilteringParameters2, _super);
    function OutboundMessageClicksFilteringParameters2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageClicksFilteringParameters2;
  }(OutboundMessageTrackingFilteringParameters);
  exports.OutboundMessageClicksFilteringParameters = OutboundMessageClicksFilteringParameters;
});

// node_modules/postmark/dist/client/models/templates/Template.js
var require_Template = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateFilteringParameters = exports.TemplatedMessage = exports.TemplatesPushRequest = exports.TemplateTypes = exports.TemplateValidationOptions = exports.CreateTemplateRequest = exports.UpdateTemplateRequest = undefined;
  var FilteringParameters_1 = require_FilteringParameters();
  var UpdateTemplateRequest = function() {
    function UpdateTemplateRequest2(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
      this.Name = Name;
      this.Subject = Subject;
      this.HtmlBody = HtmlBody;
      this.TextBody = TextBody;
      this.Alias = Alias;
      this.LayoutTemplate = LayoutTemplate;
      this.TemplateType = TemplateType;
    }
    return UpdateTemplateRequest2;
  }();
  exports.UpdateTemplateRequest = UpdateTemplateRequest;
  var CreateTemplateRequest = function(_super) {
    __extends(CreateTemplateRequest2, _super);
    function CreateTemplateRequest2(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
      return _super.call(this, Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) || this;
    }
    return CreateTemplateRequest2;
  }(UpdateTemplateRequest);
  exports.CreateTemplateRequest = CreateTemplateRequest;
  var TemplateValidationOptions = function() {
    function TemplateValidationOptions2(Subject, HtmlBody, TextBody, TestRenderModel, TemplateType, LayoutTemplate, InlineCssForHtmlTestRender) {
      this.Subject = Subject;
      this.HtmlBody = HtmlBody;
      this.TextBody = TextBody;
      this.TestRenderModel = TestRenderModel;
      this.TemplateType = TemplateType;
      this.LayoutTemplate = LayoutTemplate;
      this.InlineCssForHtmlTestRender = InlineCssForHtmlTestRender;
    }
    return TemplateValidationOptions2;
  }();
  exports.TemplateValidationOptions = TemplateValidationOptions;
  var TemplateTypes;
  (function(TemplateTypes2) {
    TemplateTypes2["Standard"] = "Standard";
    TemplateTypes2["Layout"] = "Layout";
  })(TemplateTypes = exports.TemplateTypes || (exports.TemplateTypes = {}));
  var TemplatesPushRequest = function() {
    function TemplatesPushRequest2(SourceServerID, DestinationServerID, PerformChanges) {
      this.SourceServerID = SourceServerID;
      this.DestinationServerID = DestinationServerID;
      this.PerformChanges = PerformChanges;
    }
    return TemplatesPushRequest2;
  }();
  exports.TemplatesPushRequest = TemplatesPushRequest;
  var TemplatedMessage = function() {
    function TemplatedMessage2(from, templateIdOrAlias, templateModel, to, cc, bcc, replyTo, tag, trackOpens, trackLinks, headers, attachments) {
      this.From = from;
      this.TemplateModel = templateModel;
      if (typeof templateIdOrAlias === "number") {
        this.TemplateId = templateIdOrAlias;
      } else {
        this.TemplateAlias = templateIdOrAlias;
      }
      this.To = to;
      this.Cc = cc;
      this.Bcc = bcc;
      this.ReplyTo = replyTo;
      this.Tag = tag;
      this.TrackOpens = trackOpens;
      this.TrackLinks = trackLinks;
      this.Headers = headers;
      this.Attachments = attachments;
    }
    return TemplatedMessage2;
  }();
  exports.TemplatedMessage = TemplatedMessage;
  var TemplateFilteringParameters = function(_super) {
    __extends(TemplateFilteringParameters2, _super);
    function TemplateFilteringParameters2(count, offset, templateType, layoutTemplate) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.templateType = templateType;
      _this.layoutTemplate = layoutTemplate;
      return _this;
    }
    return TemplateFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.TemplateFilteringParameters = TemplateFilteringParameters;
});

// node_modules/postmark/dist/client/models/server/Server.js
var require_Server = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateServerRequest = exports.UpdateServerRequest = undefined;
  var UpdateServerRequest = function() {
    function UpdateServerRequest2(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) {
      this.Name = Name;
      this.Color = Color;
      this.SmtpApiActivated = SmtpApiActivated;
      this.RawEmailEnabled = RawEmailEnabled;
      this.InboundHookUrl = InboundHookUrl;
      this.BounceHookUrl = BounceHookUrl;
      this.OpenHookUrl = OpenHookUrl;
      this.DeliveryHookUrl = DeliveryHookUrl;
      this.ClickHookUrl = ClickHookUrl;
      this.PostFirstOpenOnly = PostFirstOpenOnly;
      this.InboundSpamThreshold = InboundSpamThreshold;
      this.InboundDomain = InboundDomain;
      this.TrackOpens = TrackOpens;
      this.TrackLinks = TrackLinks;
      this.IncludeBounceContentInHook = IncludeBounceContentInHook;
      this.EnableSmtpApiErrorHooks = EnableSmtpApiErrorHooks;
    }
    return UpdateServerRequest2;
  }();
  exports.UpdateServerRequest = UpdateServerRequest;
  var CreateServerRequest = function(_super) {
    __extends(CreateServerRequest2, _super);
    function CreateServerRequest2(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain, DeliveryType) {
      var _this = _super.call(this, Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) || this;
      _this.DeliveryType = DeliveryType;
      return _this;
    }
    return CreateServerRequest2;
  }(UpdateServerRequest);
  exports.CreateServerRequest = CreateServerRequest;
});

// node_modules/postmark/dist/client/models/server/Servers.js
var require_Servers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/server/ServerFilteringParameters.js
var require_ServerFilteringParameters = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerFilteringParameters = undefined;
  var FilteringParameters_1 = require_FilteringParameters();
  var ServerFilteringParameters = function(_super) {
    __extends(ServerFilteringParameters2, _super);
    function ServerFilteringParameters2(count, offset, name) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.name = name;
      return _this;
    }
    return ServerFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.ServerFilteringParameters = ServerFilteringParameters;
});

// node_modules/postmark/dist/client/models/domains/Domain.js
var require_Domain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateDomainRequest = exports.CreateDomainRequest = undefined;
  var CreateDomainRequest = function() {
    function CreateDomainRequest2(Name, ReturnPathDomain) {
      this.Name = Name;
      this.ReturnPathDomain = ReturnPathDomain;
    }
    return CreateDomainRequest2;
  }();
  exports.CreateDomainRequest = CreateDomainRequest;
  var UpdateDomainRequest = function() {
    function UpdateDomainRequest2(ReturnPathDomain) {
      this.ReturnPathDomain = ReturnPathDomain;
    }
    return UpdateDomainRequest2;
  }();
  exports.UpdateDomainRequest = UpdateDomainRequest;
});

// node_modules/postmark/dist/client/models/senders/Signature.js
var require_Signature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateSignatureRequest = exports.UpdateSignatureRequest = undefined;
  var UpdateSignatureRequest = function() {
    function UpdateSignatureRequest2(Name, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
      this.Name = Name;
      this.ReplyToEmail = ReplyToEmail;
      this.ReturnPathDomain = ReturnPathDomain;
      this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return UpdateSignatureRequest2;
  }();
  exports.UpdateSignatureRequest = UpdateSignatureRequest;
  var CreateSignatureRequest = function() {
    function CreateSignatureRequest2(Name, FromEmail, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
      this.Name = Name;
      this.ReplyToEmail = ReplyToEmail;
      this.ReturnPathDomain = ReturnPathDomain;
      this.FromEmail = FromEmail;
      this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return CreateSignatureRequest2;
  }();
  exports.CreateSignatureRequest = CreateSignatureRequest;
});

// node_modules/postmark/dist/client/models/suppressions/Suppression.js
var require_Suppression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/stats/Stats.js
var require_Stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/stats/StatsFilteringParameters.js
var require_StatsFilteringParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatisticsFilteringParameters = undefined;
  var StatisticsFilteringParameters = function() {
    function StatisticsFilteringParameters2(tag, fromDate, toDate, messageStream) {
      this.tag = tag;
      this.fromDate = fromDate;
      this.toDate = toDate;
      this.messageStream = messageStream;
    }
    return StatisticsFilteringParameters2;
  }();
  exports.StatisticsFilteringParameters = StatisticsFilteringParameters;
});

// node_modules/postmark/dist/client/models/triggers/InboundRule.js
var require_InboundRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateInboundRuleRequest = undefined;
  var CreateInboundRuleRequest = function() {
    function CreateInboundRuleRequest2(Rule) {
      this.Rule = Rule;
    }
    return CreateInboundRuleRequest2;
  }();
  exports.CreateInboundRuleRequest = CreateInboundRuleRequest;
});

// node_modules/postmark/dist/client/models/webhooks/Webhooks.js
var require_Webhooks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/Webhook.js
var require_Webhook = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateWebhookRequest = exports.UpdateWebhookRequest = undefined;
  var UpdateWebhookRequest = function() {
    function UpdateWebhookRequest2(url, triggers, httpAuth, httpHeaders) {
      this.Url = url;
      this.HttpAuth = httpAuth;
      this.HttpHeaders = httpHeaders;
      this.Triggers = triggers;
    }
    return UpdateWebhookRequest2;
  }();
  exports.UpdateWebhookRequest = UpdateWebhookRequest;
  var CreateWebhookRequest = function(_super) {
    __extends(CreateWebhookRequest2, _super);
    function CreateWebhookRequest2(url, triggers, httpAuth, httpHeaders, messageStream) {
      var _this = _super.call(this, url, triggers, httpAuth, httpHeaders) || this;
      _this.MessageStream = messageStream;
      return _this;
    }
    return CreateWebhookRequest2;
  }(UpdateWebhookRequest);
  exports.CreateWebhookRequest = CreateWebhookRequest;
});

// node_modules/postmark/dist/client/models/webhooks/WebhookFilteringParameters.js
var require_WebhookFilteringParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookFilteringParameters = undefined;
  var WebhookFilteringParameters = function() {
    function WebhookFilteringParameters2(messageStream) {
      this.messageStream = messageStream;
    }
    return WebhookFilteringParameters2;
  }();
  exports.WebhookFilteringParameters = WebhookFilteringParameters;
});

// node_modules/postmark/dist/client/models/webhooks/payload/BounceWebhook.js
var require_BounceWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/DeliveryWebhook.js
var require_DeliveryWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/SpamComplaintWebhook.js
var require_SpamComplaintWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/ClickWebhook.js
var require_ClickWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/OpenWebhook.js
var require_OpenWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/SubscriptionChangeWebhook.js
var require_SubscriptionChangeWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/webhooks/payload/InboundWebhook.js
var require_InboundWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/postmark/dist/client/models/suppressions/SuppressionFilteringParameters.js
var require_SuppressionFilteringParameters = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SuppressionFilteringParameters = exports.SuppressionOrigin = exports.SuppressionReason = undefined;
  var FilteringParameters_1 = require_FilteringParameters();
  var SuppressionReason;
  (function(SuppressionReason2) {
    SuppressionReason2["HardBounce"] = "HardBounce";
    SuppressionReason2["SpamComplaint"] = "SpamComplaint";
    SuppressionReason2["ManualSuppression"] = "ManualSuppression";
  })(SuppressionReason = exports.SuppressionReason || (exports.SuppressionReason = {}));
  var SuppressionOrigin;
  (function(SuppressionOrigin2) {
    SuppressionOrigin2["Recipient"] = "Recipient";
    SuppressionOrigin2["Customer"] = "Customer";
    SuppressionOrigin2["Admin"] = "Admin";
  })(SuppressionOrigin = exports.SuppressionOrigin || (exports.SuppressionOrigin = {}));
  var SuppressionFilteringParameters = function(_super) {
    __extends(SuppressionFilteringParameters2, _super);
    function SuppressionFilteringParameters2(count, offset, suppressionReason, origin, emailAddress, fromDate, toDate) {
      if (count === undefined) {
        count = 100;
      }
      if (offset === undefined) {
        offset = 0;
      }
      var _this = _super.call(this, count, offset) || this;
      _this.suppressionReason = suppressionReason;
      _this.origin = origin;
      _this.emailAddress = emailAddress;
      _this.fromDate = fromDate;
      _this.toDate = toDate;
      return _this;
    }
    return SuppressionFilteringParameters2;
  }(FilteringParameters_1.FilteringParameters);
  exports.SuppressionFilteringParameters = SuppressionFilteringParameters;
});

// node_modules/postmark/dist/client/models/streams/MessageStream.js
var require_MessageStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateMessageStreamRequest = exports.UpdateMessageStreamRequest = exports.UnsubscribeHandlingTypes = undefined;
  var UnsubscribeHandlingTypes;
  (function(UnsubscribeHandlingTypes2) {
    UnsubscribeHandlingTypes2["None"] = "None";
    UnsubscribeHandlingTypes2["Postmark"] = "Postmark";
    UnsubscribeHandlingTypes2["Custom"] = "Custom";
  })(UnsubscribeHandlingTypes = exports.UnsubscribeHandlingTypes || (exports.UnsubscribeHandlingTypes = {}));
  var UpdateMessageStreamRequest = function() {
    function UpdateMessageStreamRequest2(name, description, subscriptionManagementConfiguration) {
      this.Name = name;
      this.Description = description;
      this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return UpdateMessageStreamRequest2;
  }();
  exports.UpdateMessageStreamRequest = UpdateMessageStreamRequest;
  var CreateMessageStreamRequest = function() {
    function CreateMessageStreamRequest2(id, name, messageStreamType, description, subscriptionManagementConfiguration) {
      this.Name = name;
      this.Description = description;
      this.ID = id;
      this.MessageStreamType = messageStreamType;
      this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return CreateMessageStreamRequest2;
  }();
  exports.CreateMessageStreamRequest = CreateMessageStreamRequest;
});

// node_modules/postmark/dist/client/models/streams/MessageStreamsFilteringParameters.js
var require_MessageStreamsFilteringParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStreamsFilteringParameters = undefined;
  var MessageStreamsFilteringParameters = function() {
    function MessageStreamsFilteringParameters2(messageStreamType, includeArchivedStreams) {
      this.messageStreamType = messageStreamType;
      this.includeArchivedStreams = includeArchivedStreams;
    }
    return MessageStreamsFilteringParameters2;
  }();
  exports.MessageStreamsFilteringParameters = MessageStreamsFilteringParameters;
});

// node_modules/postmark/dist/client/models/data_removal/DataRemovals.js
var require_DataRemovals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataRemovalRequest = exports.DataRemovalStatusTypes = undefined;
  var DataRemovalStatusTypes;
  (function(DataRemovalStatusTypes2) {
    DataRemovalStatusTypes2["Pending"] = "Pending";
    DataRemovalStatusTypes2["Done"] = "Done";
  })(DataRemovalStatusTypes = exports.DataRemovalStatusTypes || (exports.DataRemovalStatusTypes = {}));
  var DataRemovalRequest = function() {
    function DataRemovalRequest2(requestedBy, requestedFor, notifyWhenCompleted) {
      this.RequestedBy = requestedBy;
      this.RequestedFor = requestedFor;
      this.NotifyWhenCompleted = notifyWhenCompleted;
    }
    return DataRemovalRequest2;
  }();
  exports.DataRemovalRequest = DataRemovalRequest;
});

// node_modules/postmark/dist/client/models/index.js
var require_models = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ClientOptions(), exports);
  __exportStar(require_SupportingTypes(), exports);
  __exportStar(require_HttpClient(), exports);
  __exportStar(require_Callback(), exports);
  __exportStar(require_DefaultResponse(), exports);
  __exportStar(require_FilteringParameters(), exports);
  __exportStar(require_Bounce(), exports);
  __exportStar(require_BounceFilteringParameters(), exports);
  __exportStar(require_Message(), exports);
  __exportStar(require_SupportingTypes2(), exports);
  __exportStar(require_OutboundMessage(), exports);
  __exportStar(require_OutboundMessageOpen(), exports);
  __exportStar(require_OutboundMessageClick(), exports);
  __exportStar(require_InboundMessage(), exports);
  __exportStar(require_MessageFilteringParameters(), exports);
  __exportStar(require_Template(), exports);
  __exportStar(require_Server(), exports);
  __exportStar(require_Servers(), exports);
  __exportStar(require_ServerFilteringParameters(), exports);
  __exportStar(require_Domain(), exports);
  __exportStar(require_Signature(), exports);
  __exportStar(require_Suppression(), exports);
  __exportStar(require_Stats(), exports);
  __exportStar(require_StatsFilteringParameters(), exports);
  __exportStar(require_InboundRule(), exports);
  __exportStar(require_Webhooks(), exports);
  __exportStar(require_Webhook(), exports);
  __exportStar(require_WebhookFilteringParameters(), exports);
  __exportStar(require_BounceWebhook(), exports);
  __exportStar(require_DeliveryWebhook(), exports);
  __exportStar(require_SpamComplaintWebhook(), exports);
  __exportStar(require_ClickWebhook(), exports);
  __exportStar(require_OpenWebhook(), exports);
  __exportStar(require_SubscriptionChangeWebhook(), exports);
  __exportStar(require_InboundWebhook(), exports);
  __exportStar(require_Suppression(), exports);
  __exportStar(require_SuppressionFilteringParameters(), exports);
  __exportStar(require_MessageStream(), exports);
  __exportStar(require_MessageStreamsFilteringParameters(), exports);
  __exportStar(require_DataRemovals(), exports);
});

// node_modules/postmark/dist/client/errors/index.js
var require_errors = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ErrorHandler(), exports);
  __exportStar(require_Errors(), exports);
});

// node_modules/postmark/dist/client/HttpClient.js
var require_HttpClient2 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AxiosHttpClient = undefined;
  var axios_1 = require_axios();
  var models_1 = require_models();
  var index_1 = require_errors();
  var AxiosHttpClient = function(_super) {
    __extends(AxiosHttpClient2, _super);
    function AxiosHttpClient2(configOptions) {
      var _this = _super.call(this, configOptions) || this;
      _this.errorHandler = new index_1.ErrorHandler;
      return _this;
    }
    AxiosHttpClient2.prototype.initHttpClient = function(configOptions) {
      this.clientOptions = __assign(__assign({}, models_1.HttpClient.DefaultOptions), configOptions);
      var httpClient = axios_1.default.create({
        baseURL: this.getBaseHttpRequestURL(),
        timeout: this.getRequestTimeoutInMilliseconds(),
        responseType: "json",
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        validateStatus: function(status) {
          return status >= 200 && status < 300;
        }
      });
      httpClient.interceptors.response.use(function(response) {
        return response.data;
      });
      this.client = httpClient;
    };
    AxiosHttpClient2.prototype.httpRequest = function(method, path, queryParameters, body, requestHeaders) {
      var _this = this;
      return this.client.request({
        method,
        url: path,
        data: body,
        headers: requestHeaders,
        params: queryParameters
      }).catch(function(errorThrown) {
        return Promise.reject(_this.transformError(errorThrown));
      });
    };
    AxiosHttpClient2.prototype.transformError = function(errorThrown) {
      var response = errorThrown.response;
      if (response !== undefined) {
        var status_1 = this.adjustValue(0, response.status);
        var errorCode = this.adjustValue(0, response.data.ErrorCode);
        var message = this.adjustValue(errorThrown.message, response.data.Message);
        return this.errorHandler.buildError(message, errorCode, status_1);
      } else if (errorThrown.message !== undefined) {
        return this.errorHandler.buildError(errorThrown.message);
      } else {
        return this.errorHandler.buildError(JSON.stringify(errorThrown, Object.getOwnPropertyNames(errorThrown)));
      }
    };
    AxiosHttpClient2.prototype.getRequestTimeoutInMilliseconds = function() {
      return (this.clientOptions.timeout || 60) * 1000;
    };
    AxiosHttpClient2.prototype.adjustValue = function(defaultValue, data) {
      return data === undefined ? defaultValue : data;
    };
    return AxiosHttpClient2;
  }(models_1.HttpClient);
  exports.AxiosHttpClient = AxiosHttpClient;
});

// node_modules/postmark/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "postmark",
    description: "Official Node.js client library for the Postmark HTTP API - https://www.postmarkapp.com",
    license: "MIT",
    tags: [
      "email",
      "utility",
      "postmark",
      "sending",
      "transactional"
    ],
    version: "4.0.5",
    author: "Igor Balos",
    contributors: [
      "Igor Balos",
      "Andrew Theken",
      "Aaron Blum",
      "Aleksey Aleksandrov",
      "Alex Shepard",
      "Antony Jones",
      "Ben Burwell",
      "Ben Williamson",
      "Chris Williams",
      "Jakub Borys",
      "Mark Nguyen",
      "Matt",
      "Matthew Blackshaw",
      "Matthew Conlen",
      "Ryan Kirkman",
      "Scott Anderson",
      "Sebastien Chopin",
      "Theophane RUPIN",
      "codesplicer",
      "francescoRubini",
      "Matthew Reff"
    ],
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    directories: {
      lib: "./dist/index.js"
    },
    scripts: {
      compile: "rm -r -f ./dist && node_modules/.bin/tsc",
      test: "node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/**/*test.ts",
      unittest: "node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/unit/**/*test.ts",
      watchtests: "node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register -R list -w --recursive -G test/**/*test.ts",
      lint: "npx eslint src --ext ts --ignore-pattern 'src/*test*'; exit 0",
      lintfix: "npx eslint src --ext ts --fix --ignore-pattern 'src/test*.ts'; exit 0",
      "compile-docs": "echo 'Generating docs...' && mkdir -p ./docs && rm -r ./docs && node_modules/.bin/typedoc --options typedoc.json && git add -A ./docs && echo 'Generated docs!'"
    },
    homepage: "http://ActiveCampaign.github.io/postmark.js",
    repository: {
      type: "git",
      url: "https://github.com/ActiveCampaign/postmark.js.git"
    },
    bugs: {
      url: "https://github.com/ActiveCampaign/postmark.js/issues"
    },
    precommit: [
      "compile",
      "lint",
      "test",
      "compile-docs"
    ],
    devDependencies: {
      "@types/chai": "^4.3.11",
      "@types/mocha": "^10.0.6",
      "@types/node": "^12.12.6",
      "@types/sinon": "^17.0.2",
      "@typescript-eslint/eslint-plugin": "^5.40.1",
      "@typescript-eslint/parser": "^5.40.1",
      chai: "^4.3.10",
      dotenv: "^16.3.1",
      eslint: "^8.54.0",
      mocha: "^10.2.0",
      "pre-commit": "^1.2.2",
      sinon: "^17.0.1",
      "ts-node": "^10.9.1",
      typedoc: "^0.25.4",
      typescript: "^4.7.4"
    },
    dependencies: {
      axios: "^1.7.4"
    }
  };
});

// node_modules/postmark/dist/client/BaseClient.js
var require_BaseClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ErrorHandler_1 = require_ErrorHandler();
  var HttpClient_1 = require_HttpClient2();
  var packageJson = require_package();
  var CLIENT_VERSION = packageJson.version;
  var BaseClient = function() {
    function BaseClient2(token, authHeader, configOptions) {
      this.errorHandler = new ErrorHandler_1.ErrorHandler;
      this.verifyToken(token);
      this.token = token.trim();
      this.authHeader = authHeader;
      this.clientVersion = CLIENT_VERSION;
      this.httpClient = new HttpClient_1.AxiosHttpClient(configOptions);
    }
    BaseClient2.prototype.setClientOptions = function(configOptions) {
      this.httpClient.initHttpClient(configOptions);
    };
    BaseClient2.prototype.getClientOptions = function() {
      return this.httpClient.clientOptions;
    };
    BaseClient2.prototype.processRequestWithBody = function(method, path, body, callback) {
      return this.processRequest(method, path, {}, body, callback);
    };
    BaseClient2.prototype.processRequestWithoutBody = function(method, path, queryParameters, callback) {
      if (queryParameters === undefined) {
        queryParameters = {};
      }
      return this.processRequest(method, path, queryParameters, null, callback);
    };
    BaseClient2.prototype.processRequest = function(method, path, queryParameters, body, callback) {
      var httpRequest = this.processHttpRequest(method, path, queryParameters, body);
      this.processCallbackRequest(httpRequest, callback);
      return httpRequest;
    };
    BaseClient2.prototype.processHttpRequest = function(method, path, queryParameters, body) {
      return this.httpClient.httpRequest(method, path, queryParameters, body, this.getComposedHttpRequestHeaders()).then(function(response) {
        return response;
      }).catch(function(error) {
        return Promise.reject(error);
      });
    };
    BaseClient2.prototype.processCallbackRequest = function(httpRequest, callback) {
      if (callback) {
        httpRequest.then(function(response) {
          return callback(null, response);
        }).catch(function(error) {
          return callback(error, null);
        });
      }
    };
    BaseClient2.prototype.getComposedHttpRequestHeaders = function() {
      var _a;
      return _a = {}, _a[this.authHeader] = this.token, _a["Accept"] = "application/json", _a["Content-Type"] = "application/json", _a["User-Agent"] = "Postmark.JS - ".concat(this.clientVersion), _a;
    };
    BaseClient2.prototype.verifyToken = function(token) {
      if (!token || token.trim() === "") {
        throw this.errorHandler.buildError("A valid API token must be provided.");
      }
    };
    BaseClient2.prototype.setDefaultPaginationValues = function(filter) {
      filter.count = filter.count || 100;
      filter.offset = filter.offset || 0;
    };
    return BaseClient2;
  }();
  exports.default = BaseClient;
});

// node_modules/postmark/dist/client/AccountClient.js
var require_AccountClient = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var BaseClient_1 = require_BaseClient();
  var models_1 = require_models();
  var models_2 = require_models();
  var AccountClient = function(_super) {
    __extends(AccountClient2, _super);
    function AccountClient2(accountToken, configOptions) {
      return _super.call(this, accountToken, models_1.ClientOptions.AuthHeaderNames.ACCOUNT_TOKEN, configOptions) || this;
    }
    AccountClient2.prototype.getServers = function(filter, callback) {
      if (filter === undefined) {
        filter = new models_2.ServerFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers", filter, callback);
    };
    AccountClient2.prototype.getServer = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers/".concat(id), {}, callback);
    };
    AccountClient2.prototype.createServer = function(options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/servers", options, callback);
    };
    AccountClient2.prototype.editServer = function(id, options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/servers/".concat(id), options, callback);
    };
    AccountClient2.prototype.deleteServer = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/servers/".concat(id), {}, callback);
    };
    AccountClient2.prototype.getDomains = function(filter, callback) {
      if (filter === undefined) {
        filter = new models_1.FilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains", filter, callback);
    };
    AccountClient2.prototype.getDomain = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains/".concat(id), {}, callback);
    };
    AccountClient2.prototype.createDomain = function(options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/domains/", options, callback);
    };
    AccountClient2.prototype.editDomain = function(id, options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id), options, callback);
    };
    AccountClient2.prototype.deleteDomain = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/domains/".concat(id), {}, callback);
    };
    AccountClient2.prototype.verifyDomainDKIM = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyDKIM"), {}, callback);
    };
    AccountClient2.prototype.verifyDomainReturnPath = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyReturnPath"), {}, callback);
    };
    AccountClient2.prototype.verifyDomainSPF = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/domains/".concat(id, "/verifySPF"), {}, callback);
    };
    AccountClient2.prototype.rotateDomainDKIM = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/domains/".concat(id, "/rotateDKIM"), {}, callback);
    };
    AccountClient2.prototype.getSenderSignature = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders/".concat(id), {}, callback);
    };
    AccountClient2.prototype.getSenderSignatures = function(filter, callback) {
      if (filter === undefined) {
        filter = new models_1.FilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders", filter, callback);
    };
    AccountClient2.prototype.createSenderSignature = function(options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/senders/", options, callback);
    };
    AccountClient2.prototype.editSenderSignature = function(id, options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/senders/".concat(id), options, callback);
    };
    AccountClient2.prototype.deleteSenderSignature = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/senders/".concat(id), {}, callback);
    };
    AccountClient2.prototype.resendSenderSignatureConfirmation = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/resend"), {}, callback);
    };
    AccountClient2.prototype.verifySenderSignatureSPF = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/verifySpf"), {}, callback);
    };
    AccountClient2.prototype.requestNewDKIMForSenderSignature = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/requestNewDkim"), {}, callback);
    };
    AccountClient2.prototype.pushTemplates = function(options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/templates/push", options, callback);
    };
    AccountClient2.prototype.requestDataRemoval = function(options, callback) {
      return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/data-removals", options, callback);
    };
    AccountClient2.prototype.getDataRemovalStatus = function(id, callback) {
      return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/data-removals/".concat(id), {}, callback);
    };
    return AccountClient2;
  }(BaseClient_1.default);
  exports.default = AccountClient;
});

// node_modules/postmark/dist/client/ServerClient.js
var require_ServerClient = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var BaseClient_1 = require_BaseClient();
  var index_1 = require_models();
  var index_2 = require_models();
  var ServerClient = function(_super) {
    __extends(ServerClient2, _super);
    function ServerClient2(serverToken, configOptions) {
      return _super.call(this, serverToken, index_1.ClientOptions.AuthHeaderNames.SERVER_TOKEN, configOptions) || this;
    }
    ServerClient2.prototype.sendEmail = function(email, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email", email, callback);
    };
    ServerClient2.prototype.sendEmailBatch = function(emails, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batch", emails, callback);
    };
    ServerClient2.prototype.sendEmailWithTemplate = function(template, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/withTemplate", template, callback);
    };
    ServerClient2.prototype.sendEmailBatchWithTemplates = function(templates, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batchWithTemplates", { Messages: templates }, callback);
    };
    ServerClient2.prototype.getDeliveryStatistics = function(callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/deliveryStats", {}, callback);
    };
    ServerClient2.prototype.getBounces = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.BounceFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces", filter, callback);
    };
    ServerClient2.prototype.getBounce = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id), {}, callback);
    };
    ServerClient2.prototype.getBounceDump = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id, "/dump"), {}, callback);
    };
    ServerClient2.prototype.activateBounce = function(id, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/bounces/".concat(id, "/activate"), {}, callback);
    };
    ServerClient2.prototype.getTemplates = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.TemplateFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates", filter, callback);
    };
    ServerClient2.prototype.getTemplate = function(idOrAlias, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates/".concat(idOrAlias), {}, callback);
    };
    ServerClient2.prototype.deleteTemplate = function(idOrAlias, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/templates/".concat(idOrAlias), {}, callback);
    };
    ServerClient2.prototype.createTemplate = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/", options, callback);
    };
    ServerClient2.prototype.editTemplate = function(idOrAlias, options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/templates/".concat(idOrAlias), options, callback);
    };
    ServerClient2.prototype.validateTemplate = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/validate", options, callback);
    };
    ServerClient2.prototype.getServer = function(callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/server", {}, callback);
    };
    ServerClient2.prototype.editServer = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/server", options, callback);
    };
    ServerClient2.prototype.getOutboundMessages = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.OutboundMessagesFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound", filter, callback);
    };
    ServerClient2.prototype.getOutboundMessageDetails = function(messageId, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId), {}, callback);
    };
    ServerClient2.prototype.getOutboundMessageDump = function(messageId, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId, "/dump"), {}, callback);
    };
    ServerClient2.prototype.getInboundMessages = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.InboundMessagesFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound", filter, callback);
    };
    ServerClient2.prototype.getInboundMessageDetails = function(messageId, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound/".concat(messageId, "/details"), {}, callback);
    };
    ServerClient2.prototype.bypassBlockedInboundMessage = function(messageId, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/bypass"), {}, callback);
    };
    ServerClient2.prototype.retryInboundHookForMessage = function(messageId, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/retry"), {}, callback);
    };
    ServerClient2.prototype.getMessageOpens = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.OutboundMessageOpensFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens", filter, callback);
    };
    ServerClient2.prototype.getMessageOpensForSingleMessage = function(messageId, filter, callback) {
      if (filter === undefined) {
        filter = new index_2.OutboundMessageOpensFilteringParameters(50, 0);
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens/".concat(messageId), filter, callback);
    };
    ServerClient2.prototype.getMessageClicks = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.OutboundMessageClicksFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks", filter, callback);
    };
    ServerClient2.prototype.getMessageClicksForSingleMessage = function(messageId, filter, callback) {
      if (filter === undefined) {
        filter = new index_2.OutboundMessageClicksFilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks/".concat(messageId), filter, callback);
    };
    ServerClient2.prototype.getOutboundOverview = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound", filter, callback);
    };
    ServerClient2.prototype.getSentCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/sends", filter, callback);
    };
    ServerClient2.prototype.getBounceCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/bounces", filter, callback);
    };
    ServerClient2.prototype.getSpamComplaintsCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/spam", filter, callback);
    };
    ServerClient2.prototype.getTrackedEmailCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/tracked", filter, callback);
    };
    ServerClient2.prototype.getEmailOpenCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens", filter, callback);
    };
    ServerClient2.prototype.getEmailOpenPlatformUsage = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/platforms", filter, callback);
    };
    ServerClient2.prototype.getEmailOpenClientUsage = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/emailClients", filter, callback);
    };
    ServerClient2.prototype.getEmailOpenReadTimes = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/readTimes", filter, callback);
    };
    ServerClient2.prototype.getClickCounts = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks", filter, callback);
    };
    ServerClient2.prototype.getClickBrowserUsage = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/browserFamilies", filter, callback);
    };
    ServerClient2.prototype.getClickPlatformUsage = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/platforms", filter, callback);
    };
    ServerClient2.prototype.getClickLocation = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_2.StatisticsFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/location", filter, callback);
    };
    ServerClient2.prototype.createInboundRuleTrigger = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/triggers/inboundRules", options, callback);
    };
    ServerClient2.prototype.deleteInboundRuleTrigger = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/triggers/inboundRules/".concat(id), {}, callback);
    };
    ServerClient2.prototype.getInboundRuleTriggers = function(filter, callback) {
      if (filter === undefined) {
        filter = new index_1.FilteringParameters;
      }
      this.setDefaultPaginationValues(filter);
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/triggers/inboundRules", filter, callback);
    };
    ServerClient2.prototype.getWebhooks = function(filter, callback) {
      if (filter === undefined) {
        filter = {};
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks", filter, callback);
    };
    ServerClient2.prototype.getWebhook = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks/".concat(id), {}, callback);
    };
    ServerClient2.prototype.createWebhook = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/webhooks", options, callback);
    };
    ServerClient2.prototype.editWebhook = function(id, options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/webhooks/".concat(id), options, callback);
    };
    ServerClient2.prototype.deleteWebhook = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/webhooks/".concat(id), {}, callback);
    };
    ServerClient2.prototype.getMessageStreams = function(filter, callback) {
      if (filter === undefined) {
        filter = {};
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams", filter, callback);
    };
    ServerClient2.prototype.getMessageStream = function(id, callback) {
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(id), {}, callback);
    };
    ServerClient2.prototype.editMessageStream = function(id, options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PATCH, "/message-streams/".concat(id), options, callback);
    };
    ServerClient2.prototype.createMessageStream = function(options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams", options, callback);
    };
    ServerClient2.prototype.archiveMessageStream = function(id, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/archive"), {}, callback);
    };
    ServerClient2.prototype.unarchiveMessageStream = function(id, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/unarchive"), {}, callback);
    };
    ServerClient2.prototype.getSuppressions = function(messageStream, filter, callback) {
      if (filter === undefined) {
        filter = new index_2.SuppressionFilteringParameters;
      }
      return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(messageStream, "/suppressions/dump"), filter, callback);
    };
    ServerClient2.prototype.createSuppressions = function(messageStream, options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions"), options, callback);
    };
    ServerClient2.prototype.deleteSuppressions = function(messageStream, options, callback) {
      return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions/delete"), options, callback);
    };
    return ServerClient2;
  }(BaseClient_1.default);
  exports.default = ServerClient;
});

// node_modules/postmark/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Header = exports.Attachment = exports.TemplatedMessage = exports.Message = exports.Errors = exports.Models = exports.AdminClient = exports.AccountClient = exports.Client = exports.ServerClient = undefined;
  var AccountClient_1 = require_AccountClient();
  exports.AccountClient = AccountClient_1.default;
  exports.AdminClient = AccountClient_1.default;
  var ServerClient_1 = require_ServerClient();
  exports.ServerClient = ServerClient_1.default;
  exports.Client = ServerClient_1.default;
  var Models = require_models();
  exports.Models = Models;
  var Errors = require_Errors();
  exports.Errors = Errors;
  var models_1 = require_models();
  Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
    return models_1.Message;
  } });
  var models_2 = require_models();
  Object.defineProperty(exports, "TemplatedMessage", { enumerable: true, get: function() {
    return models_2.TemplatedMessage;
  } });
  var models_3 = require_models();
  Object.defineProperty(exports, "Attachment", { enumerable: true, get: function() {
    return models_3.Attachment;
  } });
  var models_4 = require_models();
  Object.defineProperty(exports, "Header", { enumerable: true, get: function() {
    return models_4.Header;
  } });
});

// node_modules/@datocms/rest-client-utils/dist/cjs/deserialize.js
var require_deserialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializeRawResponseBodyWithItems = exports.deserializeRawItem = exports.deserializeResponseBody = exports.deserializeJsonEntity = undefined;
  function hasData(thing) {
    return typeof thing === "object" && !!thing && "data" in thing;
  }
  function hasIncluded(thing) {
    return typeof thing === "object" && !!thing && "included" in thing;
  }
  function deserializeJsonEntity({ __itemTypeId, id, type, attributes, relationships, meta }) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, __itemTypeId ? { __itemTypeId } : {}), id ? { id } : {}), type ? { type } : {}), attributes || {}), relationships ? Object.fromEntries(Object.entries(relationships).map(([rel, value]) => [
      rel,
      value === null || value === undefined ? undefined : value.data
    ])) : {}), meta ? { meta } : {});
  }
  exports.deserializeJsonEntity = deserializeJsonEntity;
  function deserializeResponseBody(body) {
    if (!hasData(body)) {
      throw new Error("Invalid body!");
    }
    if (Array.isArray(body.data)) {
      return body.data.map(deserializeJsonEntity);
    }
    return deserializeJsonEntity(body.data);
  }
  exports.deserializeResponseBody = deserializeResponseBody;
  function isItemEntity(entity) {
    return Boolean(entity && typeof entity === "object" && "type" in entity && entity.type === "item");
  }
  function processValue(value) {
    if (Array.isArray(value)) {
      return value.map(processValue);
    }
    if (value && typeof value === "object") {
      if (isItemEntity(value)) {
        return deserializeRawItem(value);
      }
      const result = {};
      for (const [key, val] of Object.entries(value)) {
        result[key] = processValue(val);
      }
      return result;
    }
    return value;
  }
  function deserializeRawItem(entity) {
    if (!isItemEntity(entity)) {
      return entity;
    }
    const processedAttributes = entity.attributes ? processValue(entity.attributes) : entity.attributes;
    return Object.assign(Object.assign({}, entity), { attributes: processedAttributes, __itemTypeId: entity.relationships.item_type.data.id });
  }
  exports.deserializeRawItem = deserializeRawItem;
  function deserializeRawResponseBodyWithItems(body) {
    if (!hasData(body)) {
      throw new Error("Invalid body!");
    }
    let data;
    if (Array.isArray(body.data)) {
      data = body.data.map(deserializeRawItem);
    } else {
      data = deserializeRawItem(body.data);
    }
    let included;
    if (hasIncluded(body)) {
      included = body.included.map(deserializeRawItem);
    }
    return Object.assign(Object.assign(Object.assign({}, body), { data }), included ? { included } : {});
  }
  exports.deserializeRawResponseBodyWithItems = deserializeRawResponseBodyWithItems;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApiError = exports.TimeoutError = undefined;
  function isErrorBody(body) {
    if (typeof body !== "object" || body === null || !("data" in body)) {
      return false;
    }
    const bodyWithData = body;
    if (!Array.isArray(bodyWithData.data)) {
      return false;
    }
    const bodyWithDataList = bodyWithData;
    if (bodyWithDataList.data.length === 0) {
      return false;
    }
    const firstEl = bodyWithDataList.data[0];
    if (typeof firstEl !== "object" || firstEl === null || !("id" in firstEl) || !("type" in firstEl) || !("attributes" in firstEl) || firstEl.type !== "api_error") {
      return false;
    }
    return true;
  }

  class TimeoutError extends Error {
    constructor(initObject) {
      super("API Error!");
      Object.setPrototypeOf(this, new.target.prototype);
      if ("captureStackTrace" in Error) {
        Error.captureStackTrace(this, ApiError);
      } else {
        this.stack = new Error().stack;
      }
      this.request = initObject.request;
      this.preCallStack = initObject.preCallStack;
      this.message = `${initObject.request.method} ${initObject.request.url}: Timeout error`;
      if (this.preCallStack) {
        this.stack += `
Caused By:
${this.preCallStack}`;
      }
    }
  }
  exports.TimeoutError = TimeoutError;

  class ApiError extends Error {
    constructor(initObject) {
      super("API Error!");
      Object.setPrototypeOf(this, new.target.prototype);
      if ("captureStackTrace" in Error) {
        Error.captureStackTrace(this, ApiError);
      } else {
        this.stack = new Error().stack;
      }
      this.request = initObject.request;
      this.response = initObject.response;
      this.preCallStack = initObject.preCallStack;
      let message = `${initObject.request.method} ${initObject.request.url}: ${this.response.status} ${this.response.statusText}`;
      if (this.errors.length > 0) {
        message += `

${JSON.stringify(this.errors, null, 2)}`;
      }
      this.message = message;
      if (this.preCallStack) {
        this.stack += `
Caused By:
${this.preCallStack}`;
      }
    }
    get errors() {
      if (!isErrorBody(this.response.body)) {
        return [];
      }
      return this.response.body.data;
    }
    findError(codeOrCodes, filterDetails) {
      const codes = Array.isArray(codeOrCodes) ? codeOrCodes : [codeOrCodes];
      return this.errors.find((error) => codes.includes(error.attributes.code) && (!filterDetails || (typeof filterDetails === "function" ? filterDetails(error.attributes.details) : Object.entries(filterDetails).every(([key, value]) => error.attributes.details[key] === value))));
    }
  }
  exports.ApiError = ApiError;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/makeCancelablePromise.js
var require_makeCancelablePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeCancelablePromise = exports.CanceledPromiseError = undefined;

  class CanceledPromiseError extends Error {
    constructor() {
      super("Promise canceled!");
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.CanceledPromiseError = CanceledPromiseError;
  function makeCancelablePromise(promiseOrAsyncFn, onCancel) {
    let cancel = null;
    const cancelable = new Promise((resolve, reject) => {
      cancel = () => {
        try {
          if (onCancel) {
            onCancel();
          }
          reject(new CanceledPromiseError);
        } catch (e) {
          reject(e);
        }
      };
      const promise = typeof promiseOrAsyncFn === "function" ? promiseOrAsyncFn() : promiseOrAsyncFn;
      promise.then(resolve, reject);
    });
    if (cancel) {
      cancelable.cancel = cancel;
    }
    return cancelable;
  }
  exports.makeCancelablePromise = makeCancelablePromise;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/wait.js
var require_wait = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wait = undefined;
  function wait(time) {
    return new Promise((resolve) => {
      setTimeout(resolve, time);
    });
  }
  exports.wait = wait;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/pollJobResult.js
var require_pollJobResult = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollJobResult = undefined;
  var errors_1 = require_errors2();
  var wait_1 = require_wait();
  function pollJobResult(fetcher) {
    return __awaiter(this, undefined, undefined, function* () {
      let jobResult;
      let retryCount = 0;
      do {
        try {
          retryCount += 1;
          yield (0, wait_1.wait)(retryCount * 1000);
          jobResult = yield fetcher();
        } catch (e) {
          if (!(e instanceof errors_1.ApiError) || e.response.status !== 404) {
            throw e;
          }
        }
      } while (!jobResult);
      return jobResult;
    });
  }
  exports.pollJobResult = pollJobResult;
});

// node_modules/async-scheduler/lib/SchedulableTask.js
var require_SchedulableTask = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TaskCollisionStrategy = undefined;
  var TaskCollisionStrategy;
  (function(TaskCollisionStrategy2) {
    TaskCollisionStrategy2[TaskCollisionStrategy2["DEFAULT"] = 0] = "DEFAULT";
    TaskCollisionStrategy2[TaskCollisionStrategy2["KEEP_THIS"] = 1] = "KEEP_THIS";
    TaskCollisionStrategy2[TaskCollisionStrategy2["KEEP_OTHER"] = 2] = "KEEP_OTHER";
    TaskCollisionStrategy2[TaskCollisionStrategy2["KEEP_BOTH"] = 3] = "KEEP_BOTH";
    TaskCollisionStrategy2[TaskCollisionStrategy2["RESOLVE_THIS"] = 4] = "RESOLVE_THIS";
    TaskCollisionStrategy2[TaskCollisionStrategy2["RESOLVE_OTHER"] = 5] = "RESOLVE_OTHER";
  })(TaskCollisionStrategy = exports.TaskCollisionStrategy || (exports.TaskCollisionStrategy = {}));
});

// node_modules/async-scheduler/lib/SchedulerError.js
var require_SchedulerError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class SchedulerError {
    constructor(code, message) {
      this._code = code;
      this._message = message;
    }
    get code() {
      return this._code;
    }
    get message() {
      return this._message;
    }
  }
  exports.default = SchedulerError;
});

// node_modules/async-scheduler/lib/SchedulerMutexStrategy.js
var require_SchedulerMutexStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mutexEquality = exports.mutexBitwiseAnd = undefined;
  function mutexBitwiseAnd(mutexA, mutexB) {
    return (mutexA & mutexB) !== 0;
  }
  exports.mutexBitwiseAnd = mutexBitwiseAnd;
  function mutexEquality(mutexA, mutexB) {
    return mutexA === mutexB;
  }
  exports.mutexEquality = mutexEquality;
});

// node_modules/async-scheduler/lib/Builder.js
var require_Builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class Builder {
    constructor(task, scheduler) {
      this._meta = undefined;
      this._task = task;
      this._scheduler = scheduler;
    }
    withDescriptor(descriptor) {
      this._descriptor = descriptor;
      return this;
    }
    withMutex(mutex) {
      this._mutex = mutex;
      return this;
    }
    withMeta(meta) {
      this._meta = meta;
      return this;
    }
    runBeforeExecuting(what) {
      this._onPreExecute = what;
      return this;
    }
    handleCollisions(handler) {
      this._onTaskCollision = handler;
      return this;
    }
    execute(priority) {
      return this._scheduler.enqueue({
        priority,
        mutex: this._mutex,
        descriptor: this._descriptor,
        meta: this._meta,
        execute: this._task,
        onPreExecute: this._onPreExecute,
        onTaskCollision: this._onTaskCollision
      });
    }
  }
  exports.default = Builder;
});

// node_modules/async-scheduler/lib/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SchedulableTask_1 = require_SchedulableTask();
  var SchedulerError_1 = __importDefault(require_SchedulerError());
  var SchedulerMutexStrategy_1 = require_SchedulerMutexStrategy();
  var Builder_1 = __importDefault(require_Builder());
  var ExecutionState;
  (function(ExecutionState2) {
    ExecutionState2[ExecutionState2["PENDING"] = 0] = "PENDING";
    ExecutionState2[ExecutionState2["EXECUTING"] = 1] = "EXECUTING";
    ExecutionState2[ExecutionState2["TERMINATED"] = 2] = "TERMINATED";
  })(ExecutionState || (ExecutionState = {}));
  function rejectTask(task, error) {
    for (let listener of task.listeners) {
      listener.reject(error);
    }
  }

  class Scheduler {
    constructor(maxConcurrentTasks, options = {}) {
      this._queue = [];
      this._isExecuting = false;
      this._idleListeners = [];
      this._maxConcurrentTasks = maxConcurrentTasks;
      this._samePriorityMutex = !!options.samePriorityMutex;
      this._mutexStrategy = options.mutexStrategy || SchedulerMutexStrategy_1.mutexEquality;
      if (options.disableLogging) {
        this._errorLog = () => {};
      } else {
        this._errorLog = console.error;
      }
    }
    enqueue(task) {
      return new Promise((resolve, reject) => {
        if (typeof task === "function") {
          task = {
            priority: 0,
            execute: task
          };
        }
        const mutexResult = this._checkMutexes(task, resolve, reject);
        if (mutexResult.task) {
          this._addTask(mutexResult.task);
        } else if (mutexResult.canceled) {
          reject(this.createCanceledError());
        }
      });
    }
    prepare(task) {
      return new Builder_1.default(task, this);
    }
    _addTask(task) {
      this._queue.push(task);
      this._applyPriorities();
      if (!this._isExecuting) {
        this._isExecuting = true;
        setTimeout(this._executeNextTasks.bind(this));
      }
    }
    get executingTasks() {
      return this._queue.reduce((count, task) => task.state === ExecutionState.EXECUTING ? count + 1 : count, 0);
    }
    createCanceledError() {
      return new SchedulerError_1.default(50, "Task has been canceled in favor of another task");
    }
    _findFirstPendingTask() {
      return this._queue.find((task) => task.state === ExecutionState.PENDING);
    }
    _isIdle() {
      return this._queue.length === 0 || !this._queue.find((task) => task.state !== ExecutionState.TERMINATED);
    }
    _removeTaskAt(index) {
      this._queue.splice(index, 1);
    }
    _executeTask(task) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          if (task.task.onPreExecute) {
            task.task.onPreExecute();
          }
          return yield task.task.execute();
        } catch (error) {
          throw error;
        } finally {
          task.state = ExecutionState.TERMINATED;
          let index = this._queue.indexOf(task);
          this._removeTaskAt(index);
          this._executeNextTasks();
        }
      });
    }
    _executeNextTasks() {
      let executing = this.executingTasks;
      if (executing >= this._maxConcurrentTasks) {
        return;
      }
      let launchable = this._maxConcurrentTasks - executing;
      for (let i = 0;i < launchable; i++) {
        const task = this._findFirstPendingTask();
        if (!task) {
          if (this._isIdle()) {
            this._switchToIdle();
          }
          return;
        }
        task.state = ExecutionState.EXECUTING;
        this._executeTask(task).then((result) => {
          for (const { resolve } of task.listeners) {
            try {
              resolve(result);
            } catch (e) {
              this._errorLog("An error occurred while resolving listener", e);
            }
          }
        }).catch((error) => {
          for (const { reject } of task.listeners) {
            try {
              reject(error);
            } catch (e) {
              this._errorLog("An error occurred while rejecting listener", e);
            }
          }
        });
      }
    }
    _switchToIdle() {
      this._isExecuting = false;
      const idleListeners = this._idleListeners;
      this._idleListeners = [];
      for (const { resolve } of idleListeners) {
        try {
          resolve();
        } catch (e) {}
      }
    }
    waitForIdle() {
      if (!this._isExecuting) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        this._idleListeners.push({ resolve, reject });
      });
    }
    _applyPriorities() {
      this._queue.sort((a, b) => b.task.priority - a.task.priority);
    }
    _checkMutexes(newTask, resolve, reject) {
      for (let i = 0;i < this._queue.length; i++) {
        let taskA = this._queue[i];
        if (taskA.state === ExecutionState.TERMINATED) {
          continue;
        }
        if (this._samePriorityMutex && taskA.task.priority != newTask.priority) {
          continue;
        }
        if (!taskA.task.mutex || !newTask.mutex || !this._mutexStrategy(taskA.task.mutex, newTask.mutex)) {
          continue;
        }
        let strategyA;
        let strategyB;
        if (taskA.task.onTaskCollision) {
          strategyA = taskA.task.onTaskCollision(newTask);
          if (strategyA === SchedulableTask_1.TaskCollisionStrategy.KEEP_OTHER && taskA.state !== ExecutionState.EXECUTING) {
            this._removeTaskAt(i--);
            rejectTask(taskA, this.createCanceledError());
            continue;
          } else if (strategyA === SchedulableTask_1.TaskCollisionStrategy.KEEP_THIS) {
            return { canceled: true };
          } else if (strategyA === SchedulableTask_1.TaskCollisionStrategy.RESOLVE_OTHER) {
            this._removeTaskAt(i--);
            return {
              canceled: false,
              task: {
                task: newTask,
                state: ExecutionState.PENDING,
                listeners: [
                  {
                    resolve,
                    reject
                  },
                  ...taskA.listeners
                ]
              }
            };
          } else if (strategyA === SchedulableTask_1.TaskCollisionStrategy.RESOLVE_THIS) {
            taskA.listeners = [
              ...taskA.listeners,
              {
                resolve,
                reject
              }
            ];
            return { canceled: false };
          }
        }
        if (newTask.onTaskCollision) {
          strategyB = newTask.onTaskCollision(taskA.task);
          if (strategyB === SchedulableTask_1.TaskCollisionStrategy.KEEP_OTHER) {
            return { canceled: true };
          } else if (strategyB === SchedulableTask_1.TaskCollisionStrategy.KEEP_THIS) {
            this._removeTaskAt(i--);
            rejectTask(taskA, this.createCanceledError());
            continue;
          } else if (strategyB === SchedulableTask_1.TaskCollisionStrategy.RESOLVE_OTHER) {
            taskA.listeners = [
              ...taskA.listeners,
              {
                resolve,
                reject
              }
            ];
            return { canceled: false };
          } else if (strategyB === SchedulableTask_1.TaskCollisionStrategy.RESOLVE_THIS) {
            this._removeTaskAt(i--);
            return {
              canceled: false,
              task: {
                task: newTask,
                state: ExecutionState.PENDING,
                listeners: [
                  {
                    resolve,
                    reject
                  },
                  ...taskA.listeners
                ]
              }
            };
          }
        }
        if (strategyA === SchedulableTask_1.TaskCollisionStrategy.KEEP_BOTH && strategyB === SchedulableTask_1.TaskCollisionStrategy.KEEP_BOTH) {
          continue;
        }
        return { canceled: true };
      }
      return {
        canceled: false,
        task: {
          task: newTask,
          state: ExecutionState.PENDING,
          listeners: [
            {
              resolve,
              reject
            }
          ]
        }
      };
    }
  }
  exports.default = Scheduler;
});

// node_modules/async-scheduler/lib/index.js
var require_lib = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mutexEquality = exports.mutexBitwiseAnd = exports.SchedulerError = exports.TaskCollisionStrategy = exports.Scheduler = undefined;
  var Scheduler_1 = __importDefault(require_Scheduler());
  exports.Scheduler = Scheduler_1.default;
  var SchedulableTask_1 = require_SchedulableTask();
  Object.defineProperty(exports, "TaskCollisionStrategy", { enumerable: true, get: function() {
    return SchedulableTask_1.TaskCollisionStrategy;
  } });
  var SchedulerError_1 = __importDefault(require_SchedulerError());
  exports.SchedulerError = SchedulerError_1.default;
  var SchedulerMutexStrategy_1 = require_SchedulerMutexStrategy();
  Object.defineProperty(exports, "mutexBitwiseAnd", { enumerable: true, get: function() {
    return SchedulerMutexStrategy_1.mutexBitwiseAnd;
  } });
  Object.defineProperty(exports, "mutexEquality", { enumerable: true, get: function() {
    return SchedulerMutexStrategy_1.mutexEquality;
  } });
});

// node_modules/@datocms/rest-client-utils/dist/cjs/rawPageIterator.js
var require_rawPageIterator = __commonJS((exports) => {
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.warnOnPageQueryParam = exports.rawPageIterator = undefined;
  var async_scheduler_1 = require_lib();
  var deserialize_1 = require_deserialize();
  function rawPageIterator(pagination, callPerformer, iteratorOptions, deserializeRawRequestBodyWithItems) {
    return __asyncGenerator(this, arguments, function* rawPageIterator_1() {
      const perPage = (iteratorOptions === null || iteratorOptions === undefined ? undefined : iteratorOptions.perPage) || pagination.defaultLimit;
      if (perPage > pagination.maxLimit) {
        throw new Error(`perPage option cannot exceed maximum value of ${pagination.maxLimit}`);
      }
      const concurrency = (iteratorOptions === null || iteratorOptions === undefined ? undefined : iteratorOptions.concurrency) || 1;
      if (concurrency > 10) {
        throw new Error("concurrency option cannot exceed maximum value of 10");
      }
      const firstResponse = yield __await(callPerformer({ limit: perPage, offset: 0 }));
      for (const item of firstResponse.data) {
        yield yield __await(item);
      }
      const totalCount = firstResponse.meta.total_count;
      const limiter = new async_scheduler_1.Scheduler(concurrency);
      const promises = [];
      for (let offset = perPage;offset < totalCount; offset += perPage) {
        promises.push(limiter.enqueue(() => callPerformer({ limit: perPage, offset })));
      }
      while (promises.length > 0) {
        const response = yield __await(promises.shift());
        for (const item of response.data) {
          yield yield __await(deserializeRawRequestBodyWithItems ? (0, deserialize_1.deserializeRawItem)(item) : item);
        }
      }
    });
  }
  exports.rawPageIterator = rawPageIterator;
  function warnOnPageQueryParam(queryParams) {
    if (queryParams && "page" in queryParams) {
      console.warn("Passing a `page` query param on paged iterators has no effect: use the `perPage` option instead.");
    }
  }
  exports.warnOnPageQueryParam = warnOnPageQueryParam;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/buildNormalizedParams.js
var require_buildNormalizedParams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildNormalizedParams = undefined;
  var ARRAY_INDEX = "__ARRAY_INDEX__";
  function buildKey(path) {
    return path.reduce((result, chunk, index) => index === 0 ? chunk : chunk === ARRAY_INDEX ? `${result}[]` : `${result}[${chunk}]`, "");
  }
  function serializeValue(value) {
    if (typeof value === "number" || typeof value === "string") {
      return value.toString();
    }
    if (value === true) {
      return "true";
    }
    if (value === false) {
      return "false";
    }
    throw `Don't know how to serialize param value ${JSON.stringify(value)}`;
  }
  function buildNormalizedParams(value, path = []) {
    const result = [];
    if (typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
      result.push([buildKey(path), serializeValue(value)]);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        for (const innerValue of value) {
          for (const param of buildNormalizedParams(innerValue, [
            ...path,
            ARRAY_INDEX
          ])) {
            result.push(param);
          }
        }
      } else if (value) {
        for (const [key, innerValue] of Object.entries(value)) {
          for (const param of buildNormalizedParams(innerValue, [...path, key])) {
            result.push(param);
          }
        }
      }
    }
    return result;
  }
  exports.buildNormalizedParams = buildNormalizedParams;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/request.js
var require_request = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.request = exports.getFetchFn = exports.LogLevel = undefined;
  var buildNormalizedParams_1 = require_buildNormalizedParams();
  var errors_1 = require_errors2();
  var makeCancelablePromise_1 = require_makeCancelablePromise();
  var wait_1 = require_wait();
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  var MAX_RETRY_COUNT_ON_TIMEOUT_ERROR = 5;
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["NONE"] = 0] = "NONE";
    LogLevel2[LogLevel2["BASIC"] = 1] = "BASIC";
    LogLevel2[LogLevel2["BODY"] = 2] = "BODY";
    LogLevel2[LogLevel2["BODY_AND_HEADERS"] = 3] = "BODY_AND_HEADERS";
  })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
  function headersToObject(headers) {
    const result = {};
    headers.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  function buildApiErrorInitObject(method, url, requestHeaders, requestBody, response, responseBody, preCallStack) {
    return {
      request: {
        url,
        method,
        headers: requestHeaders,
        body: requestBody
      },
      response: {
        status: response.status,
        statusText: response.statusText,
        headers: headersToObject(response.headers),
        body: responseBody
      },
      preCallStack
    };
  }
  function buildTimeoutErrorInitObject(method, url, requestHeaders, requestBody, preCallStack) {
    return {
      request: {
        url,
        method,
        headers: requestHeaders,
        body: requestBody
      },
      preCallStack
    };
  }
  function buildApiErrorInitObjectFromJobResult(method, url, requestHeaders, requestBody, responseStatus, responseBody, preCallStack) {
    return {
      request: {
        url,
        method,
        headers: requestHeaders,
        body: requestBody
      },
      response: {
        status: responseStatus,
        statusText: "N/A",
        headers: {},
        body: responseBody
      },
      preCallStack
    };
  }
  function isErrorWithCode(error) {
    return typeof error === "object" && !!error && "code" in error;
  }
  function lowercaseKeys(obj) {
    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k.toLowerCase(), v]));
  }
  var requestCount = 1;
  function getFetchFn(customFetchFn) {
    const fetchFn = customFetchFn || (typeof fetch === "undefined" ? undefined : fetch) || (typeof globalThis === "undefined" ? undefined : globalThis.fetch);
    if (typeof fetchFn === "undefined") {
      throw new Error("fetch() is not available: either polyfill it globally, or provide it as fetchFn option.");
    }
    return fetchFn;
  }
  exports.getFetchFn = getFetchFn;
  function request(options) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const requestId = requestCount;
      requestCount += 1;
      const fetchFn = getFetchFn(options.fetchFn);
      const preCallStack = options.preCallStack;
      const userAgent = options.userAgent || "@datocms/rest-client-utils";
      const retryCount = options.retryCount || 1;
      const logLevel = options.logLevel || LogLevel.NONE;
      const autoRetry = "autoRetry" in options ? options.autoRetry : true;
      const log = options.logFn || (() => true);
      const headers = Object.assign({ "content-type": "application/json", accept: "application/json", authorization: `Bearer ${options.apiToken}`, "user-agent": userAgent }, options.extraHeaders ? lowercaseKeys(options.extraHeaders) : {});
      if (isBrowser) {
        delete headers["user-agent"];
      }
      const baseUrl = options.baseUrl.replace(/\/$/, "");
      const body = options.body ? JSON.stringify(options.body, null, 2) : undefined;
      const queryString = options.queryParams && Object.keys(options.queryParams).length > 0 ? `?${new URLSearchParams((0, buildNormalizedParams_1.buildNormalizedParams)(options.queryParams)).toString()}` : "";
      const url = `${baseUrl}${options.url}${queryString}`;
      if (logLevel >= LogLevel.BASIC) {
        log(`[${requestId}] ${options.method} ${url}`);
        if (logLevel >= LogLevel.BODY_AND_HEADERS) {
          for (const [key, value] of Object.entries(headers || {})) {
            log(`[${requestId}] ${key}: ${value}`);
          }
        }
        if (logLevel >= LogLevel.BODY && body) {
          log(`[${requestId}] ${body}`);
        }
      }
      try {
        const requestPromise = (0, makeCancelablePromise_1.makeCancelablePromise)(fetchFn(url, {
          method: options.method,
          headers,
          body
        }));
        const timeoutId = setTimeout(() => {
          requestPromise.cancel();
        }, options.requestTimeout || 30000);
        const response = yield requestPromise;
        clearTimeout(timeoutId);
        const responseContentType = response.headers.get("Content-Type");
        const invalidContentType = responseContentType && !responseContentType.includes("application/json");
        if (response.status === 429 || invalidContentType) {
          if (!autoRetry || invalidContentType && options.method !== "GET") {
            throw new errors_1.ApiError(buildApiErrorInitObject(options.method, url, headers, options.body, response, undefined, preCallStack));
          }
          const waitTimeInSecs = response.headers.has("X-RateLimit-Reset") ? Number.parseInt(response.headers.get("X-RateLimit-Reset"), 10) : retryCount;
          if (logLevel >= LogLevel.BASIC) {
            if (response.status === 429) {
              log(`[${requestId}] Rate limit exceeded, wait ${waitTimeInSecs} seconds then retry...`);
            } else {
              log(`[${requestId}] Invalid response content type "${responseContentType}" (status ${response.status}). Wait ${waitTimeInSecs} seconds then retry...`);
            }
          }
          yield (0, wait_1.wait)(waitTimeInSecs * 1000);
          return request(Object.assign(Object.assign({}, options), { retryCount: retryCount + 1 }));
        }
        if (logLevel >= LogLevel.BASIC) {
          log(`[${requestId}] Status: ${response.status} (${response.statusText})`);
          if (logLevel >= LogLevel.BODY_AND_HEADERS) {
            for (const key of [
              "x-api-version",
              "x-environment",
              "x-queue-time",
              "x-ratelimit-remaining",
              "x-request-id",
              "cf-ray"
            ]) {
              const value = response.headers.get(key);
              if (value) {
                log(`[${requestId}] ${key}: ${value}`);
              }
            }
          }
        }
        let responseBody = response.status === 204 ? undefined : yield response.json();
        if (logLevel >= LogLevel.BODY && responseBody) {
          log(`[${requestId}] ${JSON.stringify(responseBody, null, 2)}`);
        }
        if (response.status === 202) {
          const jobResult = yield options.fetchJobResult(responseBody.data.id);
          if (jobResult.status < 200 || jobResult.status >= 300) {
            throw new errors_1.ApiError(buildApiErrorInitObjectFromJobResult(options.method, url, headers, options.body, jobResult.status, jobResult.payload, preCallStack));
          }
          responseBody = jobResult.payload;
        }
        if (response.status >= 200 && response.status < 300) {
          return responseBody;
        }
        const error = new errors_1.ApiError(buildApiErrorInitObject(options.method, url, headers, options.body, response, responseBody, preCallStack));
        const transientErrorCode = (_a = error.errors.find((e) => e.attributes.transient)) === null || _a === undefined ? undefined : _a.attributes.code;
        if (autoRetry && transientErrorCode) {
          if (logLevel >= LogLevel.BASIC) {
            log(`[${requestId}] ${transientErrorCode}, wait ${retryCount} seconds then retry...`);
          }
          yield (0, wait_1.wait)(retryCount * 1000);
          return request(Object.assign(Object.assign({}, options), { retryCount: retryCount + 1 }));
        }
        throw error;
      } catch (error) {
        if (error instanceof makeCancelablePromise_1.CanceledPromiseError || isErrorWithCode(error) && error.code.includes("ETIMEDOUT")) {
          if (autoRetry && retryCount < MAX_RETRY_COUNT_ON_TIMEOUT_ERROR) {
            if (logLevel >= LogLevel.BASIC) {
              log(`[${requestId}] Timeout error, wait ${retryCount} seconds then retry...`);
            }
            yield (0, wait_1.wait)(retryCount * 1000);
            return request(Object.assign(Object.assign({}, options), { retryCount: retryCount + 1 }));
          }
          throw new errors_1.TimeoutError(buildTimeoutErrorInitObject(options.method, url, headers, options.body, preCallStack));
        }
        throw error;
      }
    });
  }
  exports.request = request;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/serialize.js
var require_serialize = __commonJS((exports) => {
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializeRawRequestBodyWithItems = exports.serializeRawItem = exports.serializeRequestBody = undefined;
  function isRel(object) {
    return typeof object === "object" && !!object && "id" in object && "type" in object;
  }
  function isRelArray(object) {
    return Array.isArray(object) && object.every(isRel);
  }
  function serializeRequestBody(body, options) {
    if (typeof body !== "object" || !body) {
      throw new Error("Invalid body!");
    }
    if (Array.isArray(body)) {
      return {
        data: body.map((entity) => {
          var _a2;
          return (_a2 = serializeRequestBody(entity, options)) === null || _a2 === undefined ? undefined : _a2.data;
        })
      };
    }
    const _a = body, { id, type: typeInBody, meta } = _a, otherProperties = __rest(_a, ["id", "type", "meta"]);
    const attributes = {};
    const relationships = {};
    if (options.attributes === "*") {
      for (const [key, value] of Object.entries(otherProperties)) {
        if (options.relationships.includes(key)) {
          if (isRel(value)) {
            const { id: id2, type } = value;
            relationships[key] = { data: { id: id2, type } };
          } else if (isRelArray(value)) {
            relationships[key] = {
              data: value.map(({ id: id2, type }) => ({ id: id2, type }))
            };
          } else {
            relationships[key] = {
              data: null
            };
          }
        } else {
          attributes[key] = value;
        }
      }
    } else if (options.relationships === "*") {
      for (const [key, value] of Object.entries(otherProperties)) {
        if (options.attributes.includes(key)) {
          attributes[key] = value;
        } else {
          if (isRel(value)) {
            const { id: id2, type } = value;
            relationships[key] = { data: { id: id2, type } };
          } else if (isRelArray(value)) {
            relationships[key] = {
              data: value.map(({ id: id2, type }) => ({ id: id2, type }))
            };
          } else {
            relationships[key] = {
              data: null
            };
          }
        }
      }
    } else {
      for (const [key, value] of Object.entries(otherProperties)) {
        if (options.attributes.includes(key)) {
          attributes[key] = value;
        } else if (options.relationships.includes(key)) {
          if (isRel(value)) {
            const { id: id2, type } = value;
            relationships[key] = { data: { id: id2, type } };
          } else if (isRelArray(value)) {
            relationships[key] = {
              data: value.map(({ id: id2, type }) => ({ id: id2, type }))
            };
          } else {
            relationships[key] = {
              data: null
            };
          }
        }
      }
      if (options.attributes.includes("type")) {
        attributes.type = typeInBody;
      }
    }
    return {
      data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, id || options.id ? { id: id || options.id } : {}), { type: options.type }), Object.keys(attributes).length > 0 ? { attributes } : {}), Object.keys(relationships).length > 0 ? { relationships } : {}), meta ? { meta } : {})
    };
  }
  exports.serializeRequestBody = serializeRequestBody;
  function processValueForSerialization(value) {
    if (Array.isArray(value)) {
      return value.map(processValueForSerialization);
    }
    if (value && typeof value === "object") {
      const result = {};
      for (const [key, val] of Object.entries(value)) {
        if (key !== "__itemTypeId") {
          result[key] = processValueForSerialization(val);
        }
      }
      return result;
    }
    return value;
  }
  function serializeRawItem(item) {
    if (!item || typeof item !== "object") {
      return item;
    }
    const { __itemTypeId } = item, rest = __rest(item, ["__itemTypeId"]);
    const processedItem = {};
    for (const [key, value] of Object.entries(rest)) {
      processedItem[key] = processValueForSerialization(value);
    }
    return processedItem;
  }
  exports.serializeRawItem = serializeRawItem;
  function serializeRawRequestBodyWithItems(body) {
    if (!body || !("data" in body)) {
      return body;
    }
    if (Array.isArray(body.data)) {
      return Object.assign(Object.assign({}, body), { data: body.data.map(serializeRawItem) });
    }
    return Object.assign(Object.assign({}, body), { data: serializeRawItem(body.data) });
  }
  exports.serializeRawRequestBodyWithItems = serializeRawRequestBodyWithItems;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/toId.js
var require_toId = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toId = undefined;
  function toId(thing) {
    return typeof thing === "string" ? thing : thing.id;
  }
  exports.toId = toId;
});

// node_modules/@datocms/rest-client-utils/dist/cjs/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/rest-client-utils/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deserialize(), exports);
  __exportStar(require_errors2(), exports);
  __exportStar(require_makeCancelablePromise(), exports);
  __exportStar(require_pollJobResult(), exports);
  __exportStar(require_rawPageIterator(), exports);
  __exportStar(require_request(), exports);
  __exportStar(require_serialize(), exports);
  __exportStar(require_toId(), exports);
  __exportStar(require_types2(), exports);
  __exportStar(require_wait(), exports);
});

// node_modules/@datocms/cma-client/dist/cjs/BaseResource.js
var require_BaseResource = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class BaseResource {
    constructor(client) {
      this.client = client;
    }
  }
  exports.default = BaseResource;
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Role.js
var require_Role = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Role extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "role",
        attributes: [
          "name",
          "can_edit_favicon",
          "can_edit_site",
          "can_edit_schema",
          "can_manage_menu",
          "can_edit_environment",
          "can_promote_environments",
          "environments_access",
          "can_manage_users",
          "can_manage_shared_filters",
          "can_manage_upload_collections",
          "can_manage_build_triggers",
          "can_manage_webhooks",
          "can_manage_environments",
          "can_manage_sso",
          "can_access_audit_log",
          "can_manage_workflows",
          "can_manage_access_tokens",
          "can_perform_site_search",
          "can_access_build_events_log",
          "positive_item_type_permissions",
          "negative_item_type_permissions",
          "positive_upload_permissions",
          "negative_upload_permissions",
          "positive_build_trigger_permissions",
          "negative_build_trigger_permissions"
        ],
        relationships: ["inherits_permissions_from"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/roles",
        body
      });
    }
    update(roleId, body) {
      return this.rawUpdate(Utils.toId(roleId), Utils.serializeRequestBody(body, {
        id: Utils.toId(roleId),
        type: "role",
        attributes: [
          "name",
          "can_edit_favicon",
          "can_edit_site",
          "can_edit_schema",
          "can_manage_menu",
          "can_edit_environment",
          "can_promote_environments",
          "environments_access",
          "can_manage_users",
          "can_manage_shared_filters",
          "can_manage_upload_collections",
          "can_manage_build_triggers",
          "can_manage_webhooks",
          "can_manage_environments",
          "can_manage_sso",
          "can_access_audit_log",
          "can_manage_workflows",
          "can_manage_access_tokens",
          "can_perform_site_search",
          "can_access_build_events_log",
          "positive_item_type_permissions",
          "negative_item_type_permissions",
          "positive_upload_permissions",
          "negative_upload_permissions",
          "positive_build_trigger_permissions",
          "negative_build_trigger_permissions"
        ],
        relationships: ["inherits_permissions_from"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(roleId, body) {
      return this.client.request({
        method: "PUT",
        url: `/roles/${roleId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/roles"
      });
    }
    find(roleId) {
      return this.rawFind(Utils.toId(roleId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(roleId) {
      return this.client.request({
        method: "GET",
        url: `/roles/${roleId}`
      });
    }
    destroy(roleId) {
      return this.rawDestroy(Utils.toId(roleId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(roleId) {
      return this.client.request({
        method: "DELETE",
        url: `/roles/${roleId}`
      });
    }
    duplicate(roleId) {
      return this.rawDuplicate(Utils.toId(roleId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDuplicate(roleId) {
      return this.client.request({
        method: "POST",
        url: `/roles/${roleId}/duplicate`
      });
    }
  }
  exports.default = Role;
  Role.TYPE = "role";
});

// node_modules/@datocms/cma-client/dist/cjs/resources/Role.js
var require_Role2 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Role_1 = __importDefault(require_Role());
  function sameValue(a, b) {
    if ((a === undefined || a === null) && (b === undefined || b === null)) {
      return true;
    }
    return a === b;
  }
  function sameRule(obj1, obj2) {
    for (const key in obj1) {
      if (!sameValue(obj1[key], obj2[key]))
        return false;
    }
    for (const key in obj2) {
      if (!sameValue(obj1[key], obj2[key]))
        return false;
    }
    return true;
  }
  function applyChanges(currentRules, changes, currentEnvironmentId, context) {
    if (!changes) {
      return currentRules;
    }
    const { add: rulesToAdd, remove: rulesToRemove } = changes;
    return [
      ...rulesToRemove ? rulesToRemove.reduce((filteredRules, ruleToRemove) => {
        const ruleToRemoveWithEnvironmentId = Object.assign(Object.assign({}, ruleToRemove), { environment: currentEnvironmentId });
        const foundRule = filteredRules.find((rule) => sameRule(rule, ruleToRemoveWithEnvironmentId));
        if (!foundRule) {
          throw new Error(`Cannot find rule ${JSON.stringify(ruleToRemoveWithEnvironmentId)} to remove in ${context}!`);
        }
        return filteredRules.filter((rule) => rule !== foundRule);
      }, currentRules) : currentRules,
      ...rulesToAdd ? rulesToAdd.map((change) => Object.assign({ environment: currentEnvironmentId }, change)) : []
    ];
  }

  class RoleResource extends Role_1.default {
    updateCurrentEnvironmentPermissions(roleId, changes) {
      return __awaiter(this, undefined, undefined, function* () {
        const currentEnvironmentId = this.client.config.environment || (yield this.client.environments.list()).find((environment) => environment.meta.primary).id;
        const role = yield this.find(roleId);
        const updateItemTypePermissions = Boolean(changes.positive_item_type_permissions || changes.negative_item_type_permissions);
        const updateUploadPermissions = Boolean(changes.positive_upload_permissions || changes.negative_upload_permissions);
        const body = Object.assign(Object.assign({}, updateItemTypePermissions ? {
          positive_item_type_permissions: applyChanges(role.positive_item_type_permissions, changes.positive_item_type_permissions, currentEnvironmentId, "positive_item_type_permissions"),
          negative_item_type_permissions: applyChanges(role.negative_item_type_permissions, changes.negative_item_type_permissions, currentEnvironmentId, "negative_item_type_permissions")
        } : {}), updateUploadPermissions ? {
          positive_upload_permissions: applyChanges(role.positive_upload_permissions, changes.positive_upload_permissions, currentEnvironmentId, "positive_upload_permissions"),
          negative_upload_permissions: applyChanges(role.negative_upload_permissions, changes.negative_upload_permissions, currentEnvironmentId, "negative_upload_permissions")
        } : {});
        return this.update(roleId, body);
      });
    }
  }
  exports.default = RoleResource;
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/User.js
var require_User = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class User extends BaseResource_1.default {
    update(userId, body) {
      return this.rawUpdate(Utils.toId(userId), Utils.serializeRequestBody(body, {
        id: Utils.toId(userId),
        type: "user",
        attributes: ["is_active"],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(userId, body) {
      return this.client.request({
        method: "PUT",
        url: `/users/${userId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/users"
      });
    }
    find(userId, queryParams) {
      return this.rawFind(Utils.toId(userId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(userId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/users/${userId}`,
        queryParams
      });
    }
    findMe(queryParams) {
      return this.rawFindMe(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFindMe(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/users/me",
        queryParams
      });
    }
    destroy(userId, queryParams) {
      return this.rawDestroy(Utils.toId(userId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(userId, queryParams) {
      return this.client.request({
        method: "DELETE",
        url: `/users/${userId}`,
        queryParams
      });
    }
  }
  exports.default = User;
  User.TYPE = "user";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SsoUser.js
var require_SsoUser = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SsoUser extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/sso-users"
      });
    }
    find(userId) {
      return this.rawFind(Utils.toId(userId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(userId) {
      return this.client.request({
        method: "GET",
        url: `/sso-users/${userId}`
      });
    }
    copyUsers() {
      return this.rawCopyUsers().then((body) => Utils.deserializeResponseBody(body));
    }
    rawCopyUsers() {
      return this.client.request({
        method: "POST",
        url: "/sso-users/copy-users"
      });
    }
    destroy(userId, queryParams) {
      return this.rawDestroy(Utils.toId(userId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(userId, queryParams) {
      return this.client.request({
        method: "DELETE",
        url: `/sso-users/${userId}`,
        queryParams
      });
    }
  }
  exports.default = SsoUser;
  SsoUser.TYPE = "sso_user";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/AuditLogEvent.js
var require_AuditLogEvent = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class AuditLogEvent extends BaseResource_1.default {
    query(body) {
      return this.rawQuery(Utils.serializeRequestBody(body, {
        type: "audit_log_query",
        attributes: ["filter", "next_token", "detailed_log"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawQuery(body) {
      return this.client.request({
        method: "POST",
        url: "/audit-log-events/query",
        body
      });
    }
  }
  exports.default = AuditLogEvent;
  AuditLogEvent.TYPE = "audit_log_event";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/MenuItem.js
var require_MenuItem = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class MenuItem extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "menu_item",
        attributes: ["label", "external_url", "position", "open_in_new_tab"],
        relationships: ["item_type", "item_type_filter", "parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/menu-items",
        body
      });
    }
    update(menuItemId, body) {
      return this.rawUpdate(Utils.toId(menuItemId), Utils.serializeRequestBody(body, {
        id: Utils.toId(menuItemId),
        type: "menu_item",
        attributes: ["label", "external_url", "position", "open_in_new_tab"],
        relationships: ["item_type", "item_type_filter", "parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(menuItemId, body) {
      return this.client.request({
        method: "PUT",
        url: `/menu-items/${menuItemId}`,
        body
      });
    }
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/menu-items",
        queryParams
      });
    }
    find(menuItemId) {
      return this.rawFind(Utils.toId(menuItemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(menuItemId) {
      return this.client.request({
        method: "GET",
        url: `/menu-items/${menuItemId}`
      });
    }
    destroy(menuItemId) {
      return this.rawDestroy(Utils.toId(menuItemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(menuItemId) {
      return this.client.request({
        method: "DELETE",
        url: `/menu-items/${menuItemId}`
      });
    }
    reorder(body) {
      return this.rawReorder(Utils.serializeRequestBody(body, {
        type: "menu_item",
        attributes: ["position"],
        relationships: ["parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawReorder(body) {
      return this.client.request({
        method: "POST",
        url: "/menu-items/reorder",
        body
      });
    }
  }
  exports.default = MenuItem;
  MenuItem.TYPE = "menu_item";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SchemaMenuItem.js
var require_SchemaMenuItem = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SchemaMenuItem extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "schema_menu_item",
        attributes: ["label", "position", "kind"],
        relationships: ["item_type", "parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/schema-menu-items",
        body
      });
    }
    update(schemaMenuItemId, body) {
      return this.rawUpdate(Utils.toId(schemaMenuItemId), Utils.serializeRequestBody(body, {
        id: Utils.toId(schemaMenuItemId),
        type: "schema_menu_item",
        attributes: ["label", "position", "kind"],
        relationships: ["item_type", "parent", "children"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(schemaMenuItemId, body) {
      return this.client.request({
        method: "PUT",
        url: `/schema-menu-items/${schemaMenuItemId}`,
        body
      });
    }
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/schema-menu-items",
        queryParams
      });
    }
    find(schemaMenuItemId) {
      return this.rawFind(Utils.toId(schemaMenuItemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(schemaMenuItemId) {
      return this.client.request({
        method: "GET",
        url: `/schema-menu-items/${schemaMenuItemId}`
      });
    }
    destroy(schemaMenuItemId) {
      return this.rawDestroy(Utils.toId(schemaMenuItemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(schemaMenuItemId) {
      return this.client.request({
        method: "DELETE",
        url: `/schema-menu-items/${schemaMenuItemId}`
      });
    }
    reorder(body) {
      return this.rawReorder(Utils.serializeRequestBody(body, {
        type: "schema_menu_item",
        attributes: ["position"],
        relationships: ["parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawReorder(body) {
      return this.client.request({
        method: "POST",
        url: "/schema-menu-items/reorder",
        body
      });
    }
  }
  exports.default = SchemaMenuItem;
  SchemaMenuItem.TYPE = "schema_menu_item";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadCollection.js
var require_UploadCollection = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadCollection extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "upload_collection",
        attributes: ["label", "position"],
        relationships: ["parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/upload-collections",
        body
      });
    }
    update(uploadCollectionId, body) {
      return this.rawUpdate(Utils.toId(uploadCollectionId), Utils.serializeRequestBody(body, {
        id: Utils.toId(uploadCollectionId),
        type: "upload_collection",
        attributes: ["label", "position"],
        relationships: ["parent", "children"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(uploadCollectionId, body) {
      return this.client.request({
        method: "PUT",
        url: `/upload-collections/${uploadCollectionId}`,
        body
      });
    }
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/upload-collections",
        queryParams
      });
    }
    find(uploadCollectionId) {
      return this.rawFind(Utils.toId(uploadCollectionId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(uploadCollectionId) {
      return this.client.request({
        method: "GET",
        url: `/upload-collections/${uploadCollectionId}`
      });
    }
    destroy(uploadCollectionId) {
      return this.rawDestroy(Utils.toId(uploadCollectionId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(uploadCollectionId) {
      return this.client.request({
        method: "DELETE",
        url: `/upload-collections/${uploadCollectionId}`
      });
    }
    reorder(body) {
      return this.rawReorder(Utils.serializeRequestBody(body, {
        type: "upload_collection",
        attributes: ["position"],
        relationships: ["parent"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawReorder(body) {
      return this.client.request({
        method: "POST",
        url: "/upload-collections/reorder",
        body
      });
    }
  }
  exports.default = UploadCollection;
  UploadCollection.TYPE = "upload_collection";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/ItemType.js
var require_ItemType = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class ItemType extends BaseResource_1.default {
    create(body, queryParams) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "item_type",
        attributes: [
          "name",
          "api_key",
          "singleton",
          "all_locales_required",
          "sortable",
          "modular_block",
          "draft_mode_active",
          "draft_saving_active",
          "tree",
          "ordering_direction",
          "ordering_meta",
          "collection_appeareance",
          "collection_appearance",
          "hint",
          "inverse_relationships_enabled"
        ],
        relationships: [
          "ordering_field",
          "presentation_title_field",
          "presentation_image_field",
          "title_field",
          "image_preview_field",
          "excerpt_field",
          "workflow"
        ]
      }), queryParams).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body, queryParams) {
      return this.client.request({
        method: "POST",
        url: "/item-types",
        body,
        queryParams
      });
    }
    update(itemTypeId, body) {
      return this.rawUpdate(Utils.toId(itemTypeId), Utils.serializeRequestBody(body, {
        id: Utils.toId(itemTypeId),
        type: "item_type",
        attributes: [
          "name",
          "api_key",
          "collection_appeareance",
          "collection_appearance",
          "singleton",
          "all_locales_required",
          "sortable",
          "modular_block",
          "draft_mode_active",
          "draft_saving_active",
          "tree",
          "ordering_direction",
          "ordering_meta",
          "has_singleton_item",
          "hint",
          "inverse_relationships_enabled"
        ],
        relationships: [
          "ordering_field",
          "presentation_title_field",
          "presentation_image_field",
          "title_field",
          "image_preview_field",
          "excerpt_field",
          "workflow"
        ]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(itemTypeId, body) {
      return this.client.request({
        method: "PUT",
        url: `/item-types/${itemTypeId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/item-types"
      });
    }
    find(itemTypeId) {
      return this.rawFind(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(itemTypeId) {
      return this.client.request({
        method: "GET",
        url: `/item-types/${itemTypeId}`
      });
    }
    duplicate(itemTypeId) {
      return this.rawDuplicate(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDuplicate(itemTypeId) {
      return this.client.request({
        method: "POST",
        url: `/item-types/${itemTypeId}/duplicate`
      });
    }
    destroy(itemTypeId, queryParams) {
      return this.rawDestroy(Utils.toId(itemTypeId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(itemTypeId, queryParams) {
      return this.client.request({
        method: "DELETE",
        url: `/item-types/${itemTypeId}`,
        queryParams
      });
    }
    rawReorderFieldsAndFieldsets(itemTypeId, body) {
      return this.client.request({
        method: "POST",
        url: `/item-types/${itemTypeId}/reorder-fields-and-fieldsets`,
        body
      });
    }
  }
  exports.default = ItemType;
  ItemType.TYPE = "item_type";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Field.js
var require_Field = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Field extends BaseResource_1.default {
    create(itemTypeId, body) {
      return this.rawCreate(Utils.toId(itemTypeId), Utils.serializeRequestBody(body, {
        type: "field",
        attributes: [
          "label",
          "field_type",
          "api_key",
          "localized",
          "validators",
          "appeareance",
          "appearance",
          "position",
          "hint",
          "default_value",
          "deep_filtering_enabled"
        ],
        relationships: ["fieldset"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(itemTypeId, body) {
      return this.client.request({
        method: "POST",
        url: `/item-types/${itemTypeId}/fields`,
        body
      });
    }
    update(fieldId, body) {
      return this.rawUpdate(Utils.toId(fieldId), Utils.serializeRequestBody(body, {
        id: Utils.toId(fieldId),
        type: "field",
        attributes: [
          "default_value",
          "label",
          "api_key",
          "localized",
          "validators",
          "appeareance",
          "appearance",
          "position",
          "field_type",
          "hint",
          "deep_filtering_enabled"
        ],
        relationships: ["fieldset"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(fieldId, body) {
      return this.client.request({
        method: "PUT",
        url: `/fields/${fieldId}`,
        body
      });
    }
    list(itemTypeId) {
      return this.rawList(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(itemTypeId) {
      return this.client.request({
        method: "GET",
        url: `/item-types/${itemTypeId}/fields`
      });
    }
    referencing(itemTypeId) {
      return this.rawReferencing(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawReferencing(itemTypeId) {
      return this.client.request({
        method: "GET",
        url: `/item-types/${itemTypeId}/fields/referencing`
      });
    }
    related(itemTypeId) {
      return this.rawRelated(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawRelated(itemTypeId) {
      return this.client.request({
        method: "GET",
        url: `/item-types/${itemTypeId}/fields/related`
      });
    }
    find(fieldId) {
      return this.rawFind(Utils.toId(fieldId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(fieldId) {
      return this.client.request({
        method: "GET",
        url: `/fields/${fieldId}`
      });
    }
    destroy(fieldId) {
      return this.rawDestroy(Utils.toId(fieldId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(fieldId) {
      return this.client.request({
        method: "DELETE",
        url: `/fields/${fieldId}`
      });
    }
    duplicate(fieldId) {
      return this.rawDuplicate(Utils.toId(fieldId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDuplicate(fieldId) {
      return this.client.request({
        method: "POST",
        url: `/fields/${fieldId}/duplicate`
      });
    }
  }
  exports.default = Field;
  Field.TYPE = "field";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Fieldset.js
var require_Fieldset = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Fieldset extends BaseResource_1.default {
    create(itemTypeId, body) {
      return this.rawCreate(Utils.toId(itemTypeId), Utils.serializeRequestBody(body, {
        type: "fieldset",
        attributes: [
          "title",
          "hint",
          "position",
          "collapsible",
          "start_collapsed"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(itemTypeId, body) {
      return this.client.request({
        method: "POST",
        url: `/item-types/${itemTypeId}/fieldsets`,
        body
      });
    }
    update(fieldsetId, body) {
      return this.rawUpdate(Utils.toId(fieldsetId), Utils.serializeRequestBody(body, {
        id: Utils.toId(fieldsetId),
        type: "fieldset",
        attributes: [
          "title",
          "hint",
          "position",
          "collapsible",
          "start_collapsed"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(fieldsetId, body) {
      return this.client.request({
        method: "PUT",
        url: `/fieldsets/${fieldsetId}`,
        body
      });
    }
    list(itemTypeId) {
      return this.rawList(Utils.toId(itemTypeId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(itemTypeId) {
      return this.client.request({
        method: "GET",
        url: `/item-types/${itemTypeId}/fieldsets`
      });
    }
    find(fieldsetId) {
      return this.rawFind(Utils.toId(fieldsetId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(fieldsetId) {
      return this.client.request({
        method: "GET",
        url: `/fieldsets/${fieldsetId}`
      });
    }
    destroy(fieldsetId) {
      return this.rawDestroy(Utils.toId(fieldsetId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(fieldsetId) {
      return this.client.request({
        method: "DELETE",
        url: `/fieldsets/${fieldsetId}`
      });
    }
  }
  exports.default = Fieldset;
  Fieldset.TYPE = "fieldset";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Session.js
var require_Session = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Session extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "email_credentials",
        attributes: ["email", "password", "otp_code"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/sessions",
        body
      });
    }
  }
  exports.default = Session;
  Session.TYPE = "session";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/AccessToken.js
var require_AccessToken = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class AccessToken extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "access_token",
        attributes: [
          "name",
          "can_access_cda",
          "can_access_cda_preview",
          "can_access_cma"
        ],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/access_tokens",
        body
      });
    }
    update(accessTokenId, body) {
      return this.rawUpdate(Utils.toId(accessTokenId), Utils.serializeRequestBody(body, {
        id: Utils.toId(accessTokenId),
        type: "access_token",
        attributes: [
          "name",
          "can_access_cda",
          "can_access_cda_preview",
          "can_access_cma"
        ],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(accessTokenId, body) {
      return this.client.request({
        method: "PUT",
        url: `/access_tokens/${accessTokenId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/access_tokens"
      });
    }
    find(accessTokenId) {
      return this.rawFind(Utils.toId(accessTokenId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(accessTokenId) {
      return this.client.request({
        method: "GET",
        url: `/access_tokens/${accessTokenId}`
      });
    }
    regenerateToken(accessTokenId) {
      return this.rawRegenerateToken(Utils.toId(accessTokenId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawRegenerateToken(accessTokenId) {
      return this.client.request({
        method: "POST",
        url: `/access_tokens/${accessTokenId}/regenerate_token`
      });
    }
    destroy(accessTokenId, queryParams) {
      return this.rawDestroy(Utils.toId(accessTokenId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(accessTokenId, queryParams) {
      return this.client.request({
        method: "DELETE",
        url: `/access_tokens/${accessTokenId}`,
        queryParams
      });
    }
  }
  exports.default = AccessToken;
  AccessToken.TYPE = "access_token";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Plugin.js
var require_Plugin = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Plugin extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "plugin",
        attributes: [
          "package_name",
          "name",
          "description",
          "url",
          "permissions",
          "plugin_type",
          "field_types",
          "parameter_definitions",
          "package_version"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/plugins",
        body
      });
    }
    update(pluginId, body) {
      return this.rawUpdate(Utils.toId(pluginId), Utils.serializeRequestBody(body, {
        id: Utils.toId(pluginId),
        type: "plugin",
        attributes: [
          "name",
          "description",
          "url",
          "parameters",
          "package_version",
          "permissions"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(pluginId, body) {
      return this.client.request({
        method: "PUT",
        url: `/plugins/${pluginId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/plugins"
      });
    }
    find(pluginId) {
      return this.rawFind(Utils.toId(pluginId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(pluginId) {
      return this.client.request({
        method: "GET",
        url: `/plugins/${pluginId}`
      });
    }
    destroy(pluginId) {
      return this.rawDestroy(Utils.toId(pluginId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(pluginId) {
      return this.client.request({
        method: "DELETE",
        url: `/plugins/${pluginId}`
      });
    }
    fields(pluginId) {
      return this.rawFields(Utils.toId(pluginId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFields(pluginId) {
      return this.client.request({
        method: "GET",
        url: `/plugins/${pluginId}/fields`
      });
    }
  }
  exports.default = Plugin;
  Plugin.TYPE = "plugin";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/JobResult.js
var require_JobResult = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class JobResult extends BaseResource_1.default {
    find(jobResultId) {
      return this.rawFind(Utils.toId(jobResultId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(jobResultId) {
      return this.client.request({
        method: "GET",
        url: `/job-results/${jobResultId}`
      });
    }
  }
  exports.default = JobResult;
  JobResult.TYPE = "job_result";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SubscriptionLimit.js
var require_SubscriptionLimit = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SubscriptionLimit extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/subscription-limits"
      });
    }
    find(subscriptionLimitId) {
      return this.rawFind(Utils.toId(subscriptionLimitId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(subscriptionLimitId) {
      return this.client.request({
        method: "GET",
        url: `/subscription-limits/${subscriptionLimitId}`
      });
    }
  }
  exports.default = SubscriptionLimit;
  SubscriptionLimit.TYPE = "subscription_limit";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SubscriptionFeature.js
var require_SubscriptionFeature = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SubscriptionFeature extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/subscription-features"
      });
    }
  }
  exports.default = SubscriptionFeature;
  SubscriptionFeature.TYPE = "subscription_feature";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/BuildEvent.js
var require_BuildEvent = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class BuildEvent extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/build-events",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 30,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
    find(buildEventId) {
      return this.rawFind(Utils.toId(buildEventId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(buildEventId) {
      return this.client.request({
        method: "GET",
        url: `/build-events/${buildEventId}`
      });
    }
  }
  exports.default = BuildEvent;
  BuildEvent.TYPE = "build_event";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Item.js
var require_Item = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Item extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/items",
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 30,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions, true);
    }
    validateExisting(itemId, body) {
      return this.rawValidateExisting(Utils.toId(itemId), Utils.serializeRequestBody(body, {
        id: Utils.toId(itemId),
        type: "item",
        attributes: "*",
        relationships: ["item_type", "creator"]
      }));
    }
    rawValidateExisting(itemId, body) {
      return this.client.request({
        method: "POST",
        url: `/items/${itemId}/validate`,
        body: Utils.serializeRawRequestBodyWithItems(body)
      });
    }
    validateNew(body) {
      return this.rawValidateNew(Utils.serializeRequestBody(body, {
        type: "item",
        attributes: "*",
        relationships: ["item_type", "creator"]
      }));
    }
    rawValidateNew(body) {
      return this.client.request({
        method: "POST",
        url: "/items/validate",
        body: Utils.serializeRawRequestBodyWithItems(body)
      });
    }
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "item",
        attributes: "*",
        relationships: ["item_type", "creator"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/items",
        body: Utils.serializeRawRequestBodyWithItems(body)
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    duplicate(itemId) {
      return this.rawDuplicate(Utils.toId(itemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDuplicate(itemId) {
      return this.client.request({
        method: "POST",
        url: `/items/${itemId}/duplicate`
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    update(itemId, body) {
      return this.rawUpdate(Utils.toId(itemId), Utils.serializeRequestBody(body, {
        id: Utils.toId(itemId),
        type: "item",
        attributes: "*",
        relationships: ["item_type", "creator"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(itemId, body) {
      return this.client.request({
        method: "PUT",
        url: `/items/${itemId}`,
        body: Utils.serializeRawRequestBodyWithItems(body)
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    references(itemId, queryParams) {
      return this.rawReferences(Utils.toId(itemId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawReferences(itemId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/items/${itemId}/references`,
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    find(itemId, queryParams) {
      return this.rawFind(Utils.toId(itemId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(itemId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/items/${itemId}`,
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    currentVsPublishedState(itemId) {
      return this.rawCurrentVsPublishedState(Utils.toId(itemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawCurrentVsPublishedState(itemId) {
      return this.client.request({
        method: "GET",
        url: `/items/${itemId}/current-vs-published-state`
      });
    }
    destroy(itemId) {
      return this.rawDestroy(Utils.toId(itemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(itemId) {
      return this.client.request({
        method: "DELETE",
        url: `/items/${itemId}`
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    publish(itemId, body, queryParams) {
      return this.rawPublish(Utils.toId(itemId), body ? Utils.serializeRequestBody(body, {
        type: "selective_publish_operation",
        attributes: ["content_in_locales", "non_localized_content"],
        relationships: []
      }) : null, queryParams).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawPublish(itemId, body, queryParams) {
      return this.client.request({
        method: "PUT",
        url: `/items/${itemId}/publish`,
        body,
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    unpublish(itemId, body, queryParams) {
      return this.rawUnpublish(Utils.toId(itemId), body ? Utils.serializeRequestBody(body, {
        type: "selective_unpublish_operation",
        attributes: ["content_in_locales"],
        relationships: []
      }) : null, queryParams).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUnpublish(itemId, body, queryParams) {
      return this.client.request({
        method: "PUT",
        url: `/items/${itemId}/unpublish`,
        body,
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    bulkPublish(body) {
      return this.rawBulkPublish(Utils.serializeRequestBody(body, {
        type: "item_bulk_publish_operation",
        attributes: [],
        relationships: ["items"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkPublish(body) {
      return this.client.request({
        method: "POST",
        url: "/items/bulk/publish",
        body
      });
    }
    bulkUnpublish(body) {
      return this.rawBulkUnpublish(Utils.serializeRequestBody(body, {
        type: "item_bulk_unpublish_operation",
        attributes: [],
        relationships: ["items"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkUnpublish(body) {
      return this.client.request({
        method: "POST",
        url: "/items/bulk/unpublish",
        body
      });
    }
    bulkDestroy(body) {
      return this.rawBulkDestroy(Utils.serializeRequestBody(body, {
        type: "item_bulk_destroy_operation",
        attributes: [],
        relationships: ["items"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkDestroy(body) {
      return this.client.request({
        method: "POST",
        url: "/items/bulk/destroy",
        body
      });
    }
    bulkMoveToStage(body) {
      return this.rawBulkMoveToStage(Utils.serializeRequestBody(body, {
        type: "item_bulk_move_to_stage_operation",
        attributes: ["stage"],
        relationships: ["items"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkMoveToStage(body) {
      return this.client.request({
        method: "POST",
        url: "/items/bulk/move-to-stage",
        body
      });
    }
  }
  exports.default = Item;
  Item.TYPE = "item";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/ItemVersion.js
var require_ItemVersion = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class ItemVersion extends BaseResource_1.default {
    restore(itemVersionId) {
      return this.rawRestore(Utils.toId(itemVersionId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawRestore(itemVersionId) {
      return this.client.request({
        method: "POST",
        url: `/versions/${itemVersionId}/restore`
      });
    }
    list(itemId, queryParams) {
      return this.rawList(Utils.toId(itemId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(itemId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/items/${itemId}/versions`,
        queryParams
      });
    }
    listPagedIterator(itemId, queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(Utils.toId(itemId), queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(itemId, queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 15,
        maxLimit: 50
      }, (page) => this.rawList(itemId, Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
    find(itemVersionId, queryParams) {
      return this.rawFind(Utils.toId(itemVersionId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(itemVersionId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/versions/${itemVersionId}`,
        queryParams
      });
    }
  }
  exports.default = ItemVersion;
  ItemVersion.TYPE = "item_version";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Upload.js
var require_Upload = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Upload extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "upload",
        attributes: [
          "path",
          "copyright",
          "author",
          "notes",
          "default_field_metadata",
          "tags"
        ],
        relationships: ["upload_collection"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/uploads",
        body
      });
    }
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/uploads",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 30,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
    find(uploadId) {
      return this.rawFind(Utils.toId(uploadId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(uploadId) {
      return this.client.request({
        method: "GET",
        url: `/uploads/${uploadId}`
      });
    }
    destroy(uploadId) {
      return this.rawDestroy(Utils.toId(uploadId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(uploadId) {
      return this.client.request({
        method: "DELETE",
        url: `/uploads/${uploadId}`
      });
    }
    update(uploadId, body) {
      return this.rawUpdate(Utils.toId(uploadId), Utils.serializeRequestBody(body, {
        id: Utils.toId(uploadId),
        type: "upload",
        attributes: [
          "path",
          "basename",
          "copyright",
          "author",
          "notes",
          "tags",
          "default_field_metadata"
        ],
        relationships: ["creator", "upload_collection"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(uploadId, body) {
      return this.client.request({
        method: "PUT",
        url: `/uploads/${uploadId}`,
        body
      });
    }
    references(uploadId, queryParams) {
      return this.rawReferences(Utils.toId(uploadId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawReferences(uploadId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/uploads/${uploadId}/references`,
        queryParams
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
    bulkTag(body) {
      return this.rawBulkTag(Utils.serializeRequestBody(body, {
        type: "upload_bulk_tag_operation",
        attributes: ["tags"],
        relationships: ["uploads"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkTag(body) {
      return this.client.request({
        method: "POST",
        url: "/uploads/bulk/tag",
        body
      });
    }
    bulkSetUploadCollection(body) {
      return this.rawBulkSetUploadCollection(Utils.serializeRequestBody(body, {
        type: "upload_bulk_set_upload_collection_operation",
        attributes: [],
        relationships: ["upload_collection", "uploads"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkSetUploadCollection(body) {
      return this.client.request({
        method: "POST",
        url: "/uploads/bulk/set-upload-collection",
        body
      });
    }
    bulkDestroy(body) {
      return this.rawBulkDestroy(Utils.serializeRequestBody(body, {
        type: "upload_bulk_destroy_operation",
        attributes: [],
        relationships: ["uploads"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawBulkDestroy(body) {
      return this.client.request({
        method: "POST",
        url: "/uploads/bulk/destroy",
        body
      });
    }
  }
  exports.default = Upload;
  Upload.TYPE = "upload";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadRequest.js
var require_UploadRequest = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadRequest extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "upload_request",
        attributes: ["filename"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/upload-requests",
        body
      });
    }
  }
  exports.default = UploadRequest;
  UploadRequest.TYPE = "upload_request";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadTrack.js
var require_UploadTrack = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadTrack extends BaseResource_1.default {
    create(uploadId, body) {
      return this.rawCreate(Utils.toId(uploadId), Utils.serializeRequestBody(body, {
        type: "upload_track",
        attributes: [
          "url_or_upload_request_id",
          "type",
          "name",
          "language_code",
          "closed_captions"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(uploadId, body) {
      return this.client.request({
        method: "POST",
        url: `/uploads/${uploadId}/tracks`,
        body
      });
    }
    list(uploadId) {
      return this.rawList(Utils.toId(uploadId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(uploadId) {
      return this.client.request({
        method: "GET",
        url: `/uploads/${uploadId}/tracks`
      });
    }
    destroy(uploadId, uploadTrackId) {
      return this.rawDestroy(Utils.toId(uploadId), Utils.toId(uploadTrackId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(uploadId, uploadTrackId) {
      return this.client.request({
        method: "DELETE",
        url: `/uploads/${uploadId}/tracks/${uploadTrackId}`
      });
    }
    generateSubtitles(uploadId, body) {
      return this.rawGenerateSubtitles(Utils.toId(uploadId), Utils.serializeRequestBody(body, {
        type: "upload_track",
        attributes: ["name", "language_code"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawGenerateSubtitles(uploadId, body) {
      return this.client.request({
        method: "POST",
        url: `/uploads/${uploadId}/tracks/generate-subtitles`,
        body
      });
    }
  }
  exports.default = UploadTrack;
  UploadTrack.TYPE = "upload_track";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/ScheduledPublication.js
var require_ScheduledPublication = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class ScheduledPublication extends BaseResource_1.default {
    create(itemId, body) {
      return this.rawCreate(Utils.toId(itemId), Utils.serializeRequestBody(body, {
        type: "scheduled_publication",
        attributes: ["publication_scheduled_at", "selective_publication"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(itemId, body) {
      return this.client.request({
        method: "POST",
        url: `/items/${itemId}/scheduled-publication`,
        body
      });
    }
    destroy(itemId) {
      return this.rawDestroy(Utils.toId(itemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(itemId) {
      return this.client.request({
        method: "DELETE",
        url: `/items/${itemId}/scheduled-publication`
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
  }
  exports.default = ScheduledPublication;
  ScheduledPublication.TYPE = "scheduled_publication";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/ScheduledUnpublishing.js
var require_ScheduledUnpublishing = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class ScheduledUnpublishing extends BaseResource_1.default {
    create(itemId, body) {
      return this.rawCreate(Utils.toId(itemId), Utils.serializeRequestBody(body, {
        type: "scheduled_unpublishing",
        attributes: ["unpublishing_scheduled_at", "content_in_locales"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(itemId, body) {
      return this.client.request({
        method: "POST",
        url: `/items/${itemId}/scheduled-unpublishing`,
        body
      });
    }
    destroy(itemId) {
      return this.rawDestroy(Utils.toId(itemId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(itemId) {
      return this.client.request({
        method: "DELETE",
        url: `/items/${itemId}/scheduled-unpublishing`
      }).then(Utils.deserializeRawResponseBodyWithItems);
    }
  }
  exports.default = ScheduledUnpublishing;
  ScheduledUnpublishing.TYPE = "scheduled_unpublishing";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SearchResult.js
var require_SearchResult = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SearchResult extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/search-results",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 20,
        maxLimit: 100
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
  }
  exports.default = SearchResult;
  SearchResult.TYPE = "search_result";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Environment.js
var require_Environment = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Environment extends BaseResource_1.default {
    fork(environmentId, body, queryParams) {
      return this.rawFork(Utils.toId(environmentId), Utils.serializeRequestBody(body, {
        id: Utils.toId(environmentId),
        type: "environment",
        attributes: [],
        relationships: []
      }), queryParams).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawFork(environmentId, body, queryParams) {
      return this.client.request({
        method: "POST",
        url: `/environments/${environmentId}/fork`,
        body,
        queryParams
      });
    }
    promote(environmentId) {
      return this.rawPromote(Utils.toId(environmentId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawPromote(environmentId) {
      return this.client.request({
        method: "PUT",
        url: `/environments/${environmentId}/promote`
      });
    }
    rename(environmentId, body) {
      return this.rawRename(Utils.toId(environmentId), Utils.serializeRequestBody(body, {
        id: Utils.toId(environmentId),
        type: "environment",
        attributes: [],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawRename(environmentId, body) {
      return this.client.request({
        method: "PUT",
        url: `/environments/${environmentId}/rename`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/environments"
      });
    }
    find(environmentId) {
      return this.rawFind(Utils.toId(environmentId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(environmentId) {
      return this.client.request({
        method: "GET",
        url: `/environments/${environmentId}`
      });
    }
    destroy(environmentId) {
      return this.rawDestroy(Utils.toId(environmentId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(environmentId) {
      return this.client.request({
        method: "DELETE",
        url: `/environments/${environmentId}`
      });
    }
  }
  exports.default = Environment;
  Environment.TYPE = "environment";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/MaintenanceMode.js
var require_MaintenanceMode = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class MaintenanceMode extends BaseResource_1.default {
    find() {
      return this.rawFind().then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind() {
      return this.client.request({
        method: "GET",
        url: "/maintenance-mode"
      });
    }
    activate(queryParams) {
      return this.rawActivate(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivate(queryParams) {
      return this.client.request({
        method: "PUT",
        url: "/maintenance-mode/activate",
        queryParams
      });
    }
    deactivate() {
      return this.rawDeactivate().then((body) => Utils.deserializeResponseBody(body));
    }
    rawDeactivate() {
      return this.client.request({
        method: "PUT",
        url: "/maintenance-mode/deactivate"
      });
    }
  }
  exports.default = MaintenanceMode;
  MaintenanceMode.TYPE = "maintenance_mode";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Webhook.js
var require_Webhook2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Webhook extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "webhook",
        attributes: [
          "name",
          "url",
          "custom_payload",
          "headers",
          "events",
          "http_basic_user",
          "http_basic_password",
          "enabled",
          "payload_api_version",
          "nested_items_in_payload",
          "auto_retry"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/webhooks",
        body
      });
    }
    update(webhookId, body) {
      return this.rawUpdate(Utils.toId(webhookId), Utils.serializeRequestBody(body, {
        id: Utils.toId(webhookId),
        type: "webhook",
        attributes: [
          "name",
          "url",
          "custom_payload",
          "headers",
          "events",
          "http_basic_user",
          "http_basic_password",
          "enabled",
          "payload_api_version",
          "nested_items_in_payload",
          "auto_retry"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(webhookId, body) {
      return this.client.request({
        method: "PUT",
        url: `/webhooks/${webhookId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/webhooks"
      });
    }
    find(webhookId) {
      return this.rawFind(Utils.toId(webhookId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(webhookId) {
      return this.client.request({
        method: "GET",
        url: `/webhooks/${webhookId}`
      });
    }
    destroy(webhookId) {
      return this.rawDestroy(Utils.toId(webhookId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(webhookId) {
      return this.client.request({
        method: "DELETE",
        url: `/webhooks/${webhookId}`
      });
    }
  }
  exports.default = Webhook;
  Webhook.TYPE = "webhook";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/WebhookCall.js
var require_WebhookCall = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class WebhookCall extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/webhook_calls",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 30,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
    find(webhookCallId) {
      return this.rawFind(Utils.toId(webhookCallId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(webhookCallId) {
      return this.client.request({
        method: "GET",
        url: `/webhook_calls/${webhookCallId}`
      });
    }
    resendWebhook(webhookCallId) {
      return this.rawResendWebhook(Utils.toId(webhookCallId));
    }
    rawResendWebhook(webhookCallId) {
      return this.client.request({
        method: "POST",
        url: `/webhook_calls/${webhookCallId}/resend_webhook`
      });
    }
  }
  exports.default = WebhookCall;
  WebhookCall.TYPE = "webhook_call";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/BuildTrigger.js
var require_BuildTrigger = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class BuildTrigger extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/build-triggers"
      });
    }
    find(buildTriggerId) {
      return this.rawFind(Utils.toId(buildTriggerId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(buildTriggerId) {
      return this.client.request({
        method: "GET",
        url: `/build-triggers/${buildTriggerId}`
      });
    }
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "build_trigger",
        attributes: [
          "name",
          "webhook_token",
          "adapter",
          "indexing_enabled",
          "frontend_url",
          "autotrigger_on_scheduled_publications",
          "adapter_settings"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/build-triggers",
        body
      });
    }
    update(buildTriggerId, body) {
      return this.rawUpdate(Utils.toId(buildTriggerId), Utils.serializeRequestBody(body, {
        id: Utils.toId(buildTriggerId),
        type: "build_trigger",
        attributes: [
          "name",
          "adapter",
          "indexing_enabled",
          "frontend_url",
          "autotrigger_on_scheduled_publications",
          "adapter_settings"
        ],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(buildTriggerId, body) {
      return this.client.request({
        method: "PUT",
        url: `/build-triggers/${buildTriggerId}`,
        body
      });
    }
    trigger(buildTriggerId) {
      return this.rawTrigger(Utils.toId(buildTriggerId));
    }
    rawTrigger(buildTriggerId) {
      return this.client.request({
        method: "POST",
        url: `/build-triggers/${buildTriggerId}/trigger`
      });
    }
    abort(buildTriggerId) {
      return this.rawAbort(Utils.toId(buildTriggerId));
    }
    rawAbort(buildTriggerId) {
      return this.client.request({
        method: "DELETE",
        url: `/build-triggers/${buildTriggerId}/abort`
      });
    }
    abortIndexing(buildTriggerId) {
      return this.rawAbortIndexing(Utils.toId(buildTriggerId));
    }
    rawAbortIndexing(buildTriggerId) {
      return this.client.request({
        method: "DELETE",
        url: `/build-triggers/${buildTriggerId}/abort_indexing`
      });
    }
    reindex(buildTriggerId) {
      return this.rawReindex(Utils.toId(buildTriggerId));
    }
    rawReindex(buildTriggerId) {
      return this.client.request({
        method: "PUT",
        url: `/build-triggers/${buildTriggerId}/reindex`
      });
    }
    destroy(buildTriggerId) {
      return this.rawDestroy(Utils.toId(buildTriggerId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(buildTriggerId) {
      return this.client.request({
        method: "DELETE",
        url: `/build-triggers/${buildTriggerId}`
      });
    }
  }
  exports.default = BuildTrigger;
  BuildTrigger.TYPE = "build_trigger";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/ItemTypeFilter.js
var require_ItemTypeFilter = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class ItemTypeFilter extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "item_type_filter",
        attributes: ["name", "filter", "columns", "order_by", "shared"],
        relationships: ["item_type"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/item-type-filters",
        body
      });
    }
    update(itemTypeFilterId, body) {
      return this.rawUpdate(Utils.toId(itemTypeFilterId), Utils.serializeRequestBody(body, {
        id: Utils.toId(itemTypeFilterId),
        type: "item_type_filter",
        attributes: ["name", "columns", "order_by", "shared", "filter"],
        relationships: ["item_type"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(itemTypeFilterId, body) {
      return this.client.request({
        method: "PUT",
        url: `/item-type-filters/${itemTypeFilterId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/item-type-filters"
      });
    }
    find(itemTypeFilterId) {
      return this.rawFind(Utils.toId(itemTypeFilterId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(itemTypeFilterId) {
      return this.client.request({
        method: "GET",
        url: `/item-type-filters/${itemTypeFilterId}`
      });
    }
    destroy(itemTypeFilterId) {
      return this.rawDestroy(Utils.toId(itemTypeFilterId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(itemTypeFilterId) {
      return this.client.request({
        method: "DELETE",
        url: `/item-type-filters/${itemTypeFilterId}`
      });
    }
  }
  exports.default = ItemTypeFilter;
  ItemTypeFilter.TYPE = "item_type_filter";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadFilter.js
var require_UploadFilter = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadFilter extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "upload_filter",
        attributes: ["name", "filter", "shared"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/upload-filters",
        body
      });
    }
    update(uploadFilterId, body) {
      return this.rawUpdate(Utils.toId(uploadFilterId), Utils.serializeRequestBody(body, {
        id: Utils.toId(uploadFilterId),
        type: "upload_filter",
        attributes: ["name", "shared", "filter"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(uploadFilterId, body) {
      return this.client.request({
        method: "PUT",
        url: `/upload-filters/${uploadFilterId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/upload-filters"
      });
    }
    find(uploadFilterId) {
      return this.rawFind(Utils.toId(uploadFilterId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(uploadFilterId) {
      return this.client.request({
        method: "GET",
        url: `/upload-filters/${uploadFilterId}`
      });
    }
    destroy(uploadFilterId) {
      return this.rawDestroy(Utils.toId(uploadFilterId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(uploadFilterId) {
      return this.client.request({
        method: "DELETE",
        url: `/upload-filters/${uploadFilterId}`
      });
    }
  }
  exports.default = UploadFilter;
  UploadFilter.TYPE = "upload_filter";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SiteInvitation.js
var require_SiteInvitation = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SiteInvitation extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "site_invitation",
        attributes: ["email"],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/site-invitations",
        body
      });
    }
    update(siteInvitationId, body) {
      return this.rawUpdate(Utils.toId(siteInvitationId), Utils.serializeRequestBody(body, {
        id: Utils.toId(siteInvitationId),
        type: "site_invitation",
        attributes: [],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(siteInvitationId, body) {
      return this.client.request({
        method: "PUT",
        url: `/site-invitations/${siteInvitationId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/site-invitations"
      });
    }
    find(siteInvitationId) {
      return this.rawFind(Utils.toId(siteInvitationId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(siteInvitationId) {
      return this.client.request({
        method: "GET",
        url: `/site-invitations/${siteInvitationId}`
      });
    }
    destroy(siteInvitationId) {
      return this.rawDestroy(Utils.toId(siteInvitationId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(siteInvitationId) {
      return this.client.request({
        method: "DELETE",
        url: `/site-invitations/${siteInvitationId}`
      });
    }
    resend(siteInvitationId) {
      return this.rawResend(Utils.toId(siteInvitationId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawResend(siteInvitationId) {
      return this.client.request({
        method: "POST",
        url: `/site-invitations/${siteInvitationId}/resend`
      });
    }
  }
  exports.default = SiteInvitation;
  SiteInvitation.TYPE = "site_invitation";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/EditingSession.js
var require_EditingSession = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class EditingSession extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/editing-sessions"
      });
    }
    rawUpdate(editingSessionId, body) {
      return this.client.request({
        method: "PUT",
        url: `/editing-sessions/${editingSessionId}`,
        body
      });
    }
    destroy(editingSessionId) {
      return this.rawDestroy(Utils.toId(editingSessionId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(editingSessionId) {
      return this.client.request({
        method: "DELETE",
        url: `/editing-sessions/${editingSessionId}`
      });
    }
  }
  exports.default = EditingSession;
  EditingSession.TYPE = "editing_session";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SsoGroup.js
var require_SsoGroup = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SsoGroup extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/sso-groups"
      });
    }
    copyRoles(ssoGroupId) {
      return this.rawCopyRoles(Utils.toId(ssoGroupId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawCopyRoles(ssoGroupId) {
      return this.client.request({
        method: "POST",
        url: `/sso-groups/${ssoGroupId}/copy-roles`
      });
    }
    update(ssoGroupId, body) {
      return this.rawUpdate(Utils.toId(ssoGroupId), Utils.serializeRequestBody(body, {
        id: Utils.toId(ssoGroupId),
        type: "sso_group",
        attributes: ["priority"],
        relationships: ["role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(ssoGroupId, body) {
      return this.client.request({
        method: "PUT",
        url: `/sso-groups/${ssoGroupId}`,
        body
      });
    }
    destroy(ssoGroupId) {
      return this.rawDestroy(Utils.toId(ssoGroupId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawDestroy(ssoGroupId) {
      return this.client.request({
        method: "DELETE",
        url: `/sso-groups/${ssoGroupId}`
      });
    }
  }
  exports.default = SsoGroup;
  SsoGroup.TYPE = "sso_group";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/SsoSettings.js
var require_SsoSettings = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class SsoSettings extends BaseResource_1.default {
    find() {
      return this.rawFind().then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind() {
      return this.client.request({
        method: "GET",
        url: "/sso-settings"
      });
    }
    generateToken() {
      return this.rawGenerateToken().then((body) => Utils.deserializeResponseBody(body));
    }
    rawGenerateToken() {
      return this.client.request({
        method: "PUT",
        url: "/sso-settings/generate-token"
      });
    }
    update(body) {
      return this.rawUpdate(Utils.serializeRequestBody(body, {
        type: "sso_settings",
        attributes: ["idp_saml_metadata_url", "idp_saml_metadata_xml"],
        relationships: ["default_role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(body) {
      return this.client.request({
        method: "PUT",
        url: "/sso-settings",
        body
      });
    }
  }
  exports.default = SsoSettings;
  SsoSettings.TYPE = "sso_settings";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/EmojiSuggestions.js
var require_EmojiSuggestions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class EmojiSuggestions extends BaseResource_1.default {
    find(queryParams) {
      return this.rawFind(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/emoji-suggestions",
        queryParams
      });
    }
  }
  exports.default = EmojiSuggestions;
  EmojiSuggestions.TYPE = "emoji_suggestions";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/WhiteLabelSettings.js
var require_WhiteLabelSettings = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class WhiteLabelSettings extends BaseResource_1.default {
    find() {
      return this.rawFind().then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind() {
      return this.client.request({
        method: "GET",
        url: "/white-label-settings"
      });
    }
    update(body) {
      return this.rawUpdate(Utils.serializeRequestBody(body, {
        type: "white_label_settings",
        attributes: ["custom_i18n_messages_template_url"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(body) {
      return this.client.request({
        method: "PUT",
        url: "/white-label-settings",
        body
      });
    }
  }
  exports.default = WhiteLabelSettings;
  WhiteLabelSettings.TYPE = "white_label_settings";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/PublicInfo.js
var require_PublicInfo = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class PublicInfo extends BaseResource_1.default {
    find() {
      return this.rawFind().then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind() {
      return this.client.request({
        method: "GET",
        url: "/public-info"
      });
    }
  }
  exports.default = PublicInfo;
  PublicInfo.TYPE = "public_info";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/DailyUsage.js
var require_DailyUsage = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class DailyUsage extends BaseResource_1.default {
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/daily-site-usages"
      });
    }
  }
  exports.default = DailyUsage;
  DailyUsage.TYPE = "daily_usage";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UsageCounter.js
var require_UsageCounter = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UsageCounter extends BaseResource_1.default {
    find(usageCounterId, queryParams) {
      return this.rawFind(Utils.toId(usageCounterId), queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(usageCounterId, queryParams) {
      return this.client.request({
        method: "GET",
        url: `/usage-log-counters/${usageCounterId}`,
        queryParams
      });
    }
  }
  exports.default = UsageCounter;
  UsageCounter.TYPE = "usage_counter";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadTag.js
var require_UploadTag = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadTag extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/upload-tags",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 50,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "upload_tag",
        attributes: ["name"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/upload-tags",
        body
      });
    }
  }
  exports.default = UploadTag;
  UploadTag.TYPE = "upload_tag";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/UploadSmartTag.js
var require_UploadSmartTag = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class UploadSmartTag extends BaseResource_1.default {
    list(queryParams) {
      return this.rawList(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawList(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/upload-smart-tags",
        queryParams
      });
    }
    listPagedIterator(queryParams, iteratorOptions) {
      return __asyncGenerator(this, arguments, function* listPagedIterator_1() {
        var _a, e_1, _b, _c;
        try {
          for (var _d = true, _e = __asyncValues(this.rawListPagedIterator(queryParams, iteratorOptions)), _f;_f = yield __await(_e.next()), _a = _f.done, !_a; ) {
            _c = _f.value;
            _d = false;
            try {
              const element = _c;
              yield yield __await(Utils.deserializeJsonEntity(element));
            } finally {
              _d = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield __await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    rawListPagedIterator(queryParams, iteratorOptions) {
      Utils.warnOnPageQueryParam(queryParams);
      return Utils.rawPageIterator({
        defaultLimit: 50,
        maxLimit: 500
      }, (page) => this.rawList(Object.assign(Object.assign({}, queryParams), { page })), iteratorOptions);
    }
  }
  exports.default = UploadSmartTag;
  UploadSmartTag.TYPE = "upload_smart_tag";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Site.js
var require_Site = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Site extends BaseResource_1.default {
    find(queryParams) {
      return this.rawFind(queryParams).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(queryParams) {
      return this.client.request({
        method: "GET",
        url: "/site",
        queryParams
      });
    }
    update(body) {
      return this.rawUpdate(Utils.serializeRequestBody(body, {
        type: "site",
        attributes: [
          "no_index",
          "favicon",
          "global_seo",
          "name",
          "theme",
          "locales",
          "timezone",
          "require_2fa",
          "ip_tracking_enabled",
          "force_use_of_sandbox_environments"
        ],
        relationships: ["sso_default_role"]
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(body) {
      return this.client.request({
        method: "PUT",
        url: "/site",
        body
      });
    }
    activateImprovedTimezoneManagement() {
      return this.rawActivateImprovedTimezoneManagement().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedTimezoneManagement() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-timezone-management"
      });
    }
    activateImprovedHexManagement() {
      return this.rawActivateImprovedHexManagement().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedHexManagement() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-hex-management"
      });
    }
    activateImprovedGqlMultilocaleFields() {
      return this.rawActivateImprovedGqlMultilocaleFields().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedGqlMultilocaleFields() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-gql-multilocale-fields"
      });
    }
    activateImprovedGqlVisibilityControl() {
      return this.rawActivateImprovedGqlVisibilityControl().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedGqlVisibilityControl() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-gql-visibility-control"
      });
    }
    activateImprovedBooleanFields() {
      return this.rawActivateImprovedBooleanFields().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedBooleanFields() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-boolean-fields"
      });
    }
    activateDraftModeAsDefault() {
      return this.rawActivateDraftModeAsDefault().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateDraftModeAsDefault() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-draft-mode-as-default"
      });
    }
    activateImprovedValidationAtPublishing() {
      return this.rawActivateImprovedValidationAtPublishing().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedValidationAtPublishing() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-validation-at-publishing"
      });
    }
    activateImprovedExposureOfInlineBlocksInCda() {
      return this.rawActivateImprovedExposureOfInlineBlocksInCda().then((body) => Utils.deserializeResponseBody(body));
    }
    rawActivateImprovedExposureOfInlineBlocksInCda() {
      return this.client.request({
        method: "PUT",
        url: "/site/activate-improved-exposure-of-inline-blocks-in-cda"
      });
    }
    updateAssetsCdnDefaultSettings(body) {
      return this.rawUpdateAssetsCdnDefaultSettings(Utils.serializeRequestBody(body, {
        type: "assets-cdn-default-settings",
        attributes: ["assets_cdn_default_settings"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdateAssetsCdnDefaultSettings(body) {
      return this.client.request({
        method: "PUT",
        url: "/site/assets-cdn-default-settings",
        body
      });
    }
  }
  exports.default = Site;
  Site.TYPE = "site";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/Workflow.js
var require_Workflow = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Utils = __importStar(require_cjs());
  var BaseResource_1 = __importDefault(require_BaseResource());

  class Workflow extends BaseResource_1.default {
    create(body) {
      return this.rawCreate(Utils.serializeRequestBody(body, {
        type: "workflow",
        attributes: ["name", "api_key", "stages"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawCreate(body) {
      return this.client.request({
        method: "POST",
        url: "/workflows",
        body
      });
    }
    update(workflowId, body) {
      return this.rawUpdate(Utils.toId(workflowId), Utils.serializeRequestBody(body, {
        id: Utils.toId(workflowId),
        type: "workflow",
        attributes: ["name", "api_key", "stages"],
        relationships: []
      })).then((body2) => Utils.deserializeResponseBody(body2));
    }
    rawUpdate(workflowId, body) {
      return this.client.request({
        method: "PUT",
        url: `/workflows/${workflowId}`,
        body
      });
    }
    list() {
      return this.rawList().then((body) => Utils.deserializeResponseBody(body));
    }
    rawList() {
      return this.client.request({
        method: "GET",
        url: "/workflows"
      });
    }
    find(workflowId) {
      return this.rawFind(Utils.toId(workflowId)).then((body) => Utils.deserializeResponseBody(body));
    }
    rawFind(workflowId) {
      return this.client.request({
        method: "GET",
        url: `/workflows/${workflowId}`
      });
    }
    destroy(workflowId) {
      return this.rawDestroy(Utils.toId(workflowId));
    }
    rawDestroy(workflowId) {
      return this.client.request({
        method: "DELETE",
        url: `/workflows/${workflowId}`
      });
    }
  }
  exports.default = Workflow;
  Workflow.TYPE = "workflow";
});

// node_modules/@datocms/cma-client/dist/cjs/generated/resources/index.js
var require_resources = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Workflow = exports.Site = exports.UploadSmartTag = exports.UploadTag = exports.UsageCounter = exports.DailyUsage = exports.PublicInfo = exports.WhiteLabelSettings = exports.EmojiSuggestions = exports.SsoSettings = exports.SsoGroup = exports.EditingSession = exports.SiteInvitation = exports.UploadFilter = exports.ItemTypeFilter = exports.BuildTrigger = exports.WebhookCall = exports.Webhook = exports.MaintenanceMode = exports.Environment = exports.SearchResult = exports.ScheduledUnpublishing = exports.ScheduledPublication = exports.UploadTrack = exports.UploadRequest = exports.Upload = exports.ItemVersion = exports.Item = exports.BuildEvent = exports.SubscriptionFeature = exports.SubscriptionLimit = exports.JobResult = exports.Plugin = exports.AccessToken = exports.Session = exports.Fieldset = exports.Field = exports.ItemType = exports.UploadCollection = exports.SchemaMenuItem = exports.MenuItem = exports.AuditLogEvent = exports.SsoUser = exports.User = exports.Role = undefined;
  var Role_1 = require_Role2();
  Object.defineProperty(exports, "Role", { enumerable: true, get: function() {
    return __importDefault(Role_1).default;
  } });
  var User_1 = require_User();
  Object.defineProperty(exports, "User", { enumerable: true, get: function() {
    return __importDefault(User_1).default;
  } });
  var SsoUser_1 = require_SsoUser();
  Object.defineProperty(exports, "SsoUser", { enumerable: true, get: function() {
    return __importDefault(SsoUser_1).default;
  } });
  var AuditLogEvent_1 = require_AuditLogEvent();
  Object.defineProperty(exports, "AuditLogEvent", { enumerable: true, get: function() {
    return __importDefault(AuditLogEvent_1).default;
  } });
  var MenuItem_1 = require_MenuItem();
  Object.defineProperty(exports, "MenuItem", { enumerable: true, get: function() {
    return __importDefault(MenuItem_1).default;
  } });
  var SchemaMenuItem_1 = require_SchemaMenuItem();
  Object.defineProperty(exports, "SchemaMenuItem", { enumerable: true, get: function() {
    return __importDefault(SchemaMenuItem_1).default;
  } });
  var UploadCollection_1 = require_UploadCollection();
  Object.defineProperty(exports, "UploadCollection", { enumerable: true, get: function() {
    return __importDefault(UploadCollection_1).default;
  } });
  var ItemType_1 = require_ItemType();
  Object.defineProperty(exports, "ItemType", { enumerable: true, get: function() {
    return __importDefault(ItemType_1).default;
  } });
  var Field_1 = require_Field();
  Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
    return __importDefault(Field_1).default;
  } });
  var Fieldset_1 = require_Fieldset();
  Object.defineProperty(exports, "Fieldset", { enumerable: true, get: function() {
    return __importDefault(Fieldset_1).default;
  } });
  var Session_1 = require_Session();
  Object.defineProperty(exports, "Session", { enumerable: true, get: function() {
    return __importDefault(Session_1).default;
  } });
  var AccessToken_1 = require_AccessToken();
  Object.defineProperty(exports, "AccessToken", { enumerable: true, get: function() {
    return __importDefault(AccessToken_1).default;
  } });
  var Plugin_1 = require_Plugin();
  Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
    return __importDefault(Plugin_1).default;
  } });
  var JobResult_1 = require_JobResult();
  Object.defineProperty(exports, "JobResult", { enumerable: true, get: function() {
    return __importDefault(JobResult_1).default;
  } });
  var SubscriptionLimit_1 = require_SubscriptionLimit();
  Object.defineProperty(exports, "SubscriptionLimit", { enumerable: true, get: function() {
    return __importDefault(SubscriptionLimit_1).default;
  } });
  var SubscriptionFeature_1 = require_SubscriptionFeature();
  Object.defineProperty(exports, "SubscriptionFeature", { enumerable: true, get: function() {
    return __importDefault(SubscriptionFeature_1).default;
  } });
  var BuildEvent_1 = require_BuildEvent();
  Object.defineProperty(exports, "BuildEvent", { enumerable: true, get: function() {
    return __importDefault(BuildEvent_1).default;
  } });
  var Item_1 = require_Item();
  Object.defineProperty(exports, "Item", { enumerable: true, get: function() {
    return __importDefault(Item_1).default;
  } });
  var ItemVersion_1 = require_ItemVersion();
  Object.defineProperty(exports, "ItemVersion", { enumerable: true, get: function() {
    return __importDefault(ItemVersion_1).default;
  } });
  var Upload_1 = require_Upload();
  Object.defineProperty(exports, "Upload", { enumerable: true, get: function() {
    return __importDefault(Upload_1).default;
  } });
  var UploadRequest_1 = require_UploadRequest();
  Object.defineProperty(exports, "UploadRequest", { enumerable: true, get: function() {
    return __importDefault(UploadRequest_1).default;
  } });
  var UploadTrack_1 = require_UploadTrack();
  Object.defineProperty(exports, "UploadTrack", { enumerable: true, get: function() {
    return __importDefault(UploadTrack_1).default;
  } });
  var ScheduledPublication_1 = require_ScheduledPublication();
  Object.defineProperty(exports, "ScheduledPublication", { enumerable: true, get: function() {
    return __importDefault(ScheduledPublication_1).default;
  } });
  var ScheduledUnpublishing_1 = require_ScheduledUnpublishing();
  Object.defineProperty(exports, "ScheduledUnpublishing", { enumerable: true, get: function() {
    return __importDefault(ScheduledUnpublishing_1).default;
  } });
  var SearchResult_1 = require_SearchResult();
  Object.defineProperty(exports, "SearchResult", { enumerable: true, get: function() {
    return __importDefault(SearchResult_1).default;
  } });
  var Environment_1 = require_Environment();
  Object.defineProperty(exports, "Environment", { enumerable: true, get: function() {
    return __importDefault(Environment_1).default;
  } });
  var MaintenanceMode_1 = require_MaintenanceMode();
  Object.defineProperty(exports, "MaintenanceMode", { enumerable: true, get: function() {
    return __importDefault(MaintenanceMode_1).default;
  } });
  var Webhook_1 = require_Webhook2();
  Object.defineProperty(exports, "Webhook", { enumerable: true, get: function() {
    return __importDefault(Webhook_1).default;
  } });
  var WebhookCall_1 = require_WebhookCall();
  Object.defineProperty(exports, "WebhookCall", { enumerable: true, get: function() {
    return __importDefault(WebhookCall_1).default;
  } });
  var BuildTrigger_1 = require_BuildTrigger();
  Object.defineProperty(exports, "BuildTrigger", { enumerable: true, get: function() {
    return __importDefault(BuildTrigger_1).default;
  } });
  var ItemTypeFilter_1 = require_ItemTypeFilter();
  Object.defineProperty(exports, "ItemTypeFilter", { enumerable: true, get: function() {
    return __importDefault(ItemTypeFilter_1).default;
  } });
  var UploadFilter_1 = require_UploadFilter();
  Object.defineProperty(exports, "UploadFilter", { enumerable: true, get: function() {
    return __importDefault(UploadFilter_1).default;
  } });
  var SiteInvitation_1 = require_SiteInvitation();
  Object.defineProperty(exports, "SiteInvitation", { enumerable: true, get: function() {
    return __importDefault(SiteInvitation_1).default;
  } });
  var EditingSession_1 = require_EditingSession();
  Object.defineProperty(exports, "EditingSession", { enumerable: true, get: function() {
    return __importDefault(EditingSession_1).default;
  } });
  var SsoGroup_1 = require_SsoGroup();
  Object.defineProperty(exports, "SsoGroup", { enumerable: true, get: function() {
    return __importDefault(SsoGroup_1).default;
  } });
  var SsoSettings_1 = require_SsoSettings();
  Object.defineProperty(exports, "SsoSettings", { enumerable: true, get: function() {
    return __importDefault(SsoSettings_1).default;
  } });
  var EmojiSuggestions_1 = require_EmojiSuggestions();
  Object.defineProperty(exports, "EmojiSuggestions", { enumerable: true, get: function() {
    return __importDefault(EmojiSuggestions_1).default;
  } });
  var WhiteLabelSettings_1 = require_WhiteLabelSettings();
  Object.defineProperty(exports, "WhiteLabelSettings", { enumerable: true, get: function() {
    return __importDefault(WhiteLabelSettings_1).default;
  } });
  var PublicInfo_1 = require_PublicInfo();
  Object.defineProperty(exports, "PublicInfo", { enumerable: true, get: function() {
    return __importDefault(PublicInfo_1).default;
  } });
  var DailyUsage_1 = require_DailyUsage();
  Object.defineProperty(exports, "DailyUsage", { enumerable: true, get: function() {
    return __importDefault(DailyUsage_1).default;
  } });
  var UsageCounter_1 = require_UsageCounter();
  Object.defineProperty(exports, "UsageCounter", { enumerable: true, get: function() {
    return __importDefault(UsageCounter_1).default;
  } });
  var UploadTag_1 = require_UploadTag();
  Object.defineProperty(exports, "UploadTag", { enumerable: true, get: function() {
    return __importDefault(UploadTag_1).default;
  } });
  var UploadSmartTag_1 = require_UploadSmartTag();
  Object.defineProperty(exports, "UploadSmartTag", { enumerable: true, get: function() {
    return __importDefault(UploadSmartTag_1).default;
  } });
  var Site_1 = require_Site();
  Object.defineProperty(exports, "Site", { enumerable: true, get: function() {
    return __importDefault(Site_1).default;
  } });
  var Workflow_1 = require_Workflow();
  Object.defineProperty(exports, "Workflow", { enumerable: true, get: function() {
    return __importDefault(Workflow_1).default;
  } });
});

// node_modules/@datocms/cma-client/dist/cjs/generated/Client.js
var require_Client = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = undefined;
  var rest_client_utils_1 = require_cjs();
  var Resources = __importStar(require_resources());

  class Client {
    constructor(config) {
      this.config = config;
      this.roles = new Resources.Role(this);
      this.users = new Resources.User(this);
      this.ssoUsers = new Resources.SsoUser(this);
      this.auditLogEvents = new Resources.AuditLogEvent(this);
      this.menuItems = new Resources.MenuItem(this);
      this.schemaMenuItems = new Resources.SchemaMenuItem(this);
      this.uploadCollections = new Resources.UploadCollection(this);
      this.itemTypes = new Resources.ItemType(this);
      this.fields = new Resources.Field(this);
      this.fieldsets = new Resources.Fieldset(this);
      this.session = new Resources.Session(this);
      this.accessTokens = new Resources.AccessToken(this);
      this.plugins = new Resources.Plugin(this);
      this.jobResults = new Resources.JobResult(this);
      this.subscriptionLimits = new Resources.SubscriptionLimit(this);
      this.subscriptionFeatures = new Resources.SubscriptionFeature(this);
      this.buildEvents = new Resources.BuildEvent(this);
      this.items = new Resources.Item(this);
      this.itemVersions = new Resources.ItemVersion(this);
      this.uploads = new Resources.Upload(this);
      this.uploadRequest = new Resources.UploadRequest(this);
      this.uploadTracks = new Resources.UploadTrack(this);
      this.scheduledPublication = new Resources.ScheduledPublication(this);
      this.scheduledUnpublishing = new Resources.ScheduledUnpublishing(this);
      this.searchResults = new Resources.SearchResult(this);
      this.environments = new Resources.Environment(this);
      this.maintenanceMode = new Resources.MaintenanceMode(this);
      this.webhooks = new Resources.Webhook(this);
      this.webhookCalls = new Resources.WebhookCall(this);
      this.buildTriggers = new Resources.BuildTrigger(this);
      this.itemTypeFilters = new Resources.ItemTypeFilter(this);
      this.uploadFilters = new Resources.UploadFilter(this);
      this.siteInvitations = new Resources.SiteInvitation(this);
      this.editingSessions = new Resources.EditingSession(this);
      this.ssoGroups = new Resources.SsoGroup(this);
      this.ssoSettings = new Resources.SsoSettings(this);
      this.emojiSuggestions = new Resources.EmojiSuggestions(this);
      this.whiteLabelSettings = new Resources.WhiteLabelSettings(this);
      this.publicInfo = new Resources.PublicInfo(this);
      this.dailyUsages = new Resources.DailyUsage(this);
      this.usageCounters = new Resources.UsageCounter(this);
      this.uploadTags = new Resources.UploadTag(this);
      this.uploadSmartTags = new Resources.UploadSmartTag(this);
      this.site = new Resources.Site(this);
      this.workflows = new Resources.Workflow(this);
    }
    get baseUrl() {
      return this.config.baseUrl || Client.defaultBaseUrl;
    }
    request(options) {
      return (0, rest_client_utils_1.request)(Object.assign(Object.assign(Object.assign({}, this.config), options), { logFn: this.config.logFn || console.log, userAgent: "@datocms/cma-client v5.1.24", baseUrl: this.baseUrl, preCallStack: new Error().stack, extraHeaders: Object.assign(Object.assign(Object.assign({}, this.config.extraHeaders || {}), this.config.environment ? { "X-Environment": this.config.environment } : {}), { "X-API-Version": "3" }), fetchJobResult: (jobId) => {
        return this.jobResultsFetcher ? this.jobResultsFetcher(jobId) : (0, rest_client_utils_1.pollJobResult)(() => this.jobResults.find(jobId));
      } }));
    }
    eventsChannelName() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this.cachedEventsChannelName) {
          return this.cachedEventsChannelName;
        }
        const { data: site } = yield this.site.rawFind();
        this.cachedEventsChannelName = this.config.environment ? `private-site-${site.id}-environment-${this.config.environment}` : `private-site-${site.id}`;
        return this.cachedEventsChannelName;
      });
    }
  }
  exports.Client = Client;
  Client.defaultBaseUrl = "https://site-api.datocms.com";
});

// node_modules/@datocms/cma-client/dist/cjs/buildClient.js
var require_buildClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildClient = undefined;
  var Client_1 = require_Client();
  function buildClient(config) {
    return new Client_1.Client(config);
  }
  exports.buildClient = buildClient;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/boolean_radio_group.js
var require_boolean_radio_group = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/color_picker.js
var require_color_picker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/date_picker.js
var require_date_picker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/date_time_picker.js
var require_date_time_picker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/file.js
var require_file = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/float.js
var require_float = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/framed_single_block.js
var require_framed_single_block = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/frameless_single_block.js
var require_frameless_single_block = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/gallery.js
var require_gallery = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/json.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/link_embed.js
var require_link_embed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/link_select.js
var require_link_select = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/links_embed.js
var require_links_embed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/links_select.js
var require_links_select = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/map.js
var require_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/markdown.js
var require_markdown = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/rich_text.js
var require_rich_text = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/seo.js
var require_seo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/single_line.js
var require_single_line = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/slug.js
var require_slug = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/string_checkbox_group.js
var require_string_checkbox_group = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/string_multi_select.js
var require_string_multi_select = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/string_radio_group.js
var require_string_radio_group = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/string_select.js
var require_string_select = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/structured_text.js
var require_structured_text = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/textarea.js
var require_textarea = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/video.js
var require_video = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/wysiwyg.js
var require_wysiwyg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/appearance/index.js
var require_appearance = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_boolean(), exports);
  __exportStar(require_boolean_radio_group(), exports);
  __exportStar(require_color_picker(), exports);
  __exportStar(require_date_picker(), exports);
  __exportStar(require_date_time_picker(), exports);
  __exportStar(require_file(), exports);
  __exportStar(require_float(), exports);
  __exportStar(require_framed_single_block(), exports);
  __exportStar(require_frameless_single_block(), exports);
  __exportStar(require_gallery(), exports);
  __exportStar(require_integer(), exports);
  __exportStar(require_json(), exports);
  __exportStar(require_link_embed(), exports);
  __exportStar(require_link_select(), exports);
  __exportStar(require_links_embed(), exports);
  __exportStar(require_links_select(), exports);
  __exportStar(require_map(), exports);
  __exportStar(require_markdown(), exports);
  __exportStar(require_rich_text(), exports);
  __exportStar(require_seo(), exports);
  __exportStar(require_single_line(), exports);
  __exportStar(require_slug(), exports);
  __exportStar(require_string_checkbox_group(), exports);
  __exportStar(require_string_multi_select(), exports);
  __exportStar(require_string_radio_group(), exports);
  __exportStar(require_string_select(), exports);
  __exportStar(require_structured_text(), exports);
  __exportStar(require_textarea(), exports);
  __exportStar(require_video(), exports);
  __exportStar(require_wysiwyg(), exports);
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/normalizedFieldValues.js
var require_normalizedFieldValues = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.visitNormalizedFieldValuesAsync = exports.visitNormalizedFieldValues = exports.everyNormalizedFieldValueAsync = exports.everyNormalizedFieldValue = exports.someNormalizedFieldValuesAsync = exports.someNormalizedFieldValues = exports.filterNormalizedFieldValuesAsync = exports.filterNormalizedFieldValues = exports.mapNormalizedFieldValuesAsync = exports.mapNormalizedFieldValues = exports.fromNormalizedFieldValueEntries = exports.toNormalizedFieldValueEntries = exports.isLocalizedFieldValue = exports.isLocalized = undefined;
  function isLocalized(field) {
    return "attributes" in field ? field.attributes.localized : field.localized;
  }
  exports.isLocalized = isLocalized;
  function isLocalizedFieldValue(value) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      return false;
    }
    const keys = Object.keys(value);
    if (keys.length === 0) {
      return false;
    }
    const localePattern = /^[A-Za-z]{2,4}(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?$/;
    return keys.every((key) => localePattern.test(key));
  }
  exports.isLocalizedFieldValue = isLocalizedFieldValue;
  function toNormalizedFieldValueEntries(value, field) {
    if (isLocalized(field)) {
      const localizedValue = value;
      return Object.entries(localizedValue).map(([locale, value2]) => ({
        locale,
        value: value2
      }));
    }
    return [{ locale: undefined, value }];
  }
  exports.toNormalizedFieldValueEntries = toNormalizedFieldValueEntries;
  function fromNormalizedFieldValueEntries(entries, field) {
    if (isLocalized(field)) {
      return Object.fromEntries(entries.map(({ locale, value }) => [locale, value]));
    }
    if (entries.length === 0) {
      throw new Error("There must be at least one entry!");
    }
    return entries[0].value;
  }
  exports.fromNormalizedFieldValueEntries = fromNormalizedFieldValueEntries;
  function mapNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, mapFn) {
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    const mappedEntries = entries.map(({ locale, value }) => ({
      locale,
      value: mapFn(locale, value)
    }));
    return fromNormalizedFieldValueEntries(mappedEntries, field);
  }
  exports.mapNormalizedFieldValues = mapNormalizedFieldValues;
  function mapNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, mapFn) {
    return __awaiter(this, undefined, undefined, function* () {
      const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
      const mappedEntries = yield Promise.all(entries.map(({ locale, value }) => __awaiter(this, undefined, undefined, function* () {
        return {
          locale,
          value: yield mapFn(locale, value)
        };
      })));
      return fromNormalizedFieldValueEntries(mappedEntries, field);
    });
  }
  exports.mapNormalizedFieldValuesAsync = mapNormalizedFieldValuesAsync;
  function filterNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, filterFn) {
    var _a;
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    const filteredEntries = entries.filter((entry) => filterFn(entry.locale, entry.value));
    if (isLocalized(field)) {
      return fromNormalizedFieldValueEntries(filteredEntries, field);
    }
    return filteredEntries.length > 0 ? (_a = filteredEntries[0]) === null || _a === undefined ? undefined : _a.value : undefined;
  }
  exports.filterNormalizedFieldValues = filterNormalizedFieldValues;
  function filterNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, filterFn) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
      const results = yield Promise.all(entries.map(({ locale, value }) => __awaiter(this, undefined, undefined, function* () {
        return {
          locale,
          value,
          passed: yield filterFn(locale, value)
        };
      })));
      const filteredEntries = results.filter(({ passed }) => passed).map(({ locale, value }) => ({ locale, value }));
      if (isLocalized(field)) {
        return fromNormalizedFieldValueEntries(filteredEntries, field);
      }
      return filteredEntries.length > 0 ? (_a = filteredEntries[0]) === null || _a === undefined ? undefined : _a.value : undefined;
    });
  }
  exports.filterNormalizedFieldValuesAsync = filterNormalizedFieldValuesAsync;
  function someNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, testFn) {
    const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
    return entries.some(({ locale, value }) => testFn(locale, value));
  }
  exports.someNormalizedFieldValues = someNormalizedFieldValues;
  function someNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, testFn) {
    return __awaiter(this, undefined, undefined, function* () {
      const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
      const results = yield Promise.all(entries.map(({ locale, value }) => testFn(locale, value)));
      return results.some((result) => result);
    });
  }
  exports.someNormalizedFieldValuesAsync = someNormalizedFieldValuesAsync;
  function everyNormalizedFieldValue(localizedOrNonLocalizedFieldValue, field, testFn) {
    return !someNormalizedFieldValues(localizedOrNonLocalizedFieldValue, field, (locale, localeValue) => !testFn(locale, localeValue));
  }
  exports.everyNormalizedFieldValue = everyNormalizedFieldValue;
  function everyNormalizedFieldValueAsync(localizedOrNonLocalizedFieldValue, field, testFn) {
    return __awaiter(this, undefined, undefined, function* () {
      return !(yield someNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, (locale, localeValue) => __awaiter(this, undefined, undefined, function* () {
        return !(yield testFn(locale, localeValue));
      })));
    });
  }
  exports.everyNormalizedFieldValueAsync = everyNormalizedFieldValueAsync;
  function visitNormalizedFieldValues(value, field, visitFn) {
    const entries = toNormalizedFieldValueEntries(value, field);
    for (const { locale, value: value2 } of entries) {
      visitFn(locale, value2);
    }
  }
  exports.visitNormalizedFieldValues = visitNormalizedFieldValues;
  function visitNormalizedFieldValuesAsync(localizedOrNonLocalizedFieldValue, field, visitFn) {
    return __awaiter(this, undefined, undefined, function* () {
      const entries = toNormalizedFieldValueEntries(localizedOrNonLocalizedFieldValue, field);
      yield Promise.all(entries.map(({ locale, value }) => visitFn(locale, value)));
    });
  }
  exports.visitNormalizedFieldValuesAsync = visitNormalizedFieldValuesAsync;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/boolean.js
var require_boolean2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedBooleanFieldValue = exports.isBooleanFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isBooleanFieldValue(value) {
    return typeof value === "boolean" || value === null;
  }
  exports.isBooleanFieldValue = isBooleanFieldValue;
  function isLocalizedBooleanFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isBooleanFieldValue);
  }
  exports.isLocalizedBooleanFieldValue = isLocalizedBooleanFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/color.js
var require_color = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedColorFieldValue = exports.isColorFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isColorFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "object" && value !== null && "red" in value && "green" in value && "blue" in value && "alpha" in value;
  }
  exports.isColorFieldValue = isColorFieldValue;
  function isLocalizedColorFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isColorFieldValue);
  }
  exports.isLocalizedColorFieldValue = isLocalizedColorFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/date.js
var require_date = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedDateFieldValue = exports.isDateFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isDateFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "string" && /^\d{4}-\d{2}-\d{2}$/.test(value);
  }
  exports.isDateFieldValue = isDateFieldValue;
  function isLocalizedDateFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isDateFieldValue);
  }
  exports.isLocalizedDateFieldValue = isLocalizedDateFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/date_time.js
var require_date_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedDateTimeFieldValue = exports.isDateTimeFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isDateTimeFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value);
  }
  exports.isDateTimeFieldValue = isDateTimeFieldValue;
  function isLocalizedDateTimeFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isDateTimeFieldValue);
  }
  exports.isLocalizedDateTimeFieldValue = isLocalizedDateTimeFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/file.js
var require_file2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedFileFieldValueInRequest = exports.isLocalizedFileFieldValue = exports.isFileFieldValueInRequest = exports.isFileFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isFileFieldValue(value) {
    if (value === null)
      return true;
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && "upload_id" in value && "alt" in value && "title" in value && "custom_data" in value && "focal_point" in value;
  }
  exports.isFileFieldValue = isFileFieldValue;
  function isFileFieldValueInRequest(value) {
    if (value === null)
      return true;
    return typeof value === "object" && value !== null && "upload_id" in value;
  }
  exports.isFileFieldValueInRequest = isFileFieldValueInRequest;
  function isLocalizedFileFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isFileFieldValue);
  }
  exports.isLocalizedFileFieldValue = isLocalizedFileFieldValue;
  function isLocalizedFileFieldValueInRequest(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isFileFieldValueInRequest);
  }
  exports.isLocalizedFileFieldValueInRequest = isLocalizedFileFieldValueInRequest;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/float.js
var require_float2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedFloatFieldValue = exports.isFloatFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isFloatFieldValue(value) {
    return typeof value === "number" || value === null;
  }
  exports.isFloatFieldValue = isFloatFieldValue;
  function isLocalizedFloatFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isFloatFieldValue);
  }
  exports.isLocalizedFloatFieldValue = isLocalizedFloatFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/gallery.js
var require_gallery2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedGalleryFieldValueInRequest = exports.isLocalizedGalleryFieldValue = exports.isGalleryFieldValueInRequest = exports.isGalleryFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  var file_1 = require_file2();
  function isGalleryFieldValue(value) {
    return Array.isArray(value) && value.every(file_1.isFileFieldValue);
  }
  exports.isGalleryFieldValue = isGalleryFieldValue;
  function isGalleryFieldValueInRequest(value) {
    return Array.isArray(value) && value.every(file_1.isFileFieldValueInRequest);
  }
  exports.isGalleryFieldValueInRequest = isGalleryFieldValueInRequest;
  function isLocalizedGalleryFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isGalleryFieldValue);
  }
  exports.isLocalizedGalleryFieldValue = isLocalizedGalleryFieldValue;
  function isLocalizedGalleryFieldValueInRequest(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isGalleryFieldValueInRequest);
  }
  exports.isLocalizedGalleryFieldValueInRequest = isLocalizedGalleryFieldValueInRequest;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/integer.js
var require_integer2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedIntegerFieldValue = exports.isIntegerFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isIntegerFieldValue(value) {
    return typeof value === "number" || value === null;
  }
  exports.isIntegerFieldValue = isIntegerFieldValue;
  function isLocalizedIntegerFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isIntegerFieldValue);
  }
  exports.isLocalizedIntegerFieldValue = isLocalizedIntegerFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/json.js
var require_json2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedJsonFieldValue = exports.isJsonFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isJsonFieldValue(value) {
    if (value === null)
      return true;
    if (typeof value !== "string")
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch (_a) {
      return false;
    }
  }
  exports.isJsonFieldValue = isJsonFieldValue;
  function isLocalizedJsonFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isJsonFieldValue);
  }
  exports.isLocalizedJsonFieldValue = isLocalizedJsonFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/lat_lon.js
var require_lat_lon = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedLatLonFieldValue = exports.isLatLonFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isLatLonFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "object" && value !== null && "latitude" in value && "longitude" in value;
  }
  exports.isLatLonFieldValue = isLatLonFieldValue;
  function isLocalizedLatLonFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isLatLonFieldValue);
  }
  exports.isLocalizedLatLonFieldValue = isLocalizedLatLonFieldValue;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version2());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/id.js
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateId = exports.isValidId = undefined;
  var uuid_1 = require_dist2();
  function fromUint8ArrayToUrlSafeBase64(bytes) {
    const base64 = typeof Buffer === "undefined" ? btoa(Array.from(bytes, (byte) => String.fromCharCode(byte)).join("")) : Buffer.from(bytes).toString("base64");
    return base64.replace(/\+/g, "-").replace(/\//g, "_").substring(0, 22);
  }
  function fromUrlSafeBase64toUint8Array(urlSafeBase64) {
    const base64 = urlSafeBase64.replace(/-/g, "+").replace(/_/g, "/");
    return typeof Buffer === "undefined" ? Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)) : new Uint8Array(Buffer.from(base64, "base64"));
  }
  function isValidId(id) {
    if (/^\d+$/.test(id)) {
      const intId = BigInt(id);
      const maxDatoIntegerId = 281474976710655;
      return intId <= maxDatoIntegerId;
    }
    const bytes = fromUrlSafeBase64toUint8Array(id);
    if (bytes.length !== 16) {
      return false;
    }
    const variant = bytes.at(8);
    if ((variant & 192) !== 128) {
      return false;
    }
    const version = bytes.at(6) >> 4;
    if (version !== 4) {
      return false;
    }
    return true;
  }
  exports.isValidId = isValidId;
  function generateId() {
    const bytes = (0, uuid_1.v4)(null, new Uint8Array(16));
    bytes[0] = bytes[0] & 127;
    const base64 = fromUint8ArrayToUrlSafeBase64(bytes);
    return base64;
  }
  exports.generateId = generateId;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/link.js
var require_link = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedLinkFieldValue = exports.isLinkFieldValue = undefined;
  var id_1 = require_id();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isLinkFieldValue(value) {
    return typeof value === "string" && (0, id_1.isValidId)(value) || value === null;
  }
  exports.isLinkFieldValue = isLinkFieldValue;
  function isLocalizedLinkFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isLinkFieldValue);
  }
  exports.isLocalizedLinkFieldValue = isLocalizedLinkFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/links.js
var require_links = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedLinksFieldValue = exports.isLinksFieldValue = undefined;
  var id_1 = require_id();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isLinksFieldValue(value) {
    return Array.isArray(value) && value.every((item) => typeof item === "string" && (0, id_1.isValidId)(item));
  }
  exports.isLinksFieldValue = isLinksFieldValue;
  function isLocalizedLinksFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isLinksFieldValue);
  }
  exports.isLocalizedLinksFieldValue = isLocalizedLinksFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/single_block.js
var require_single_block = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedSingleBlockFieldValueInNestedResponse = exports.isSingleBlockFieldValueInNestedResponse = exports.isLocalizedSingleBlockFieldValueInRequest = exports.isSingleBlockFieldValueInRequest = exports.isLocalizedSingleBlockFieldValue = exports.isSingleBlockFieldValue = exports.isItemWithOptionalMeta = exports.isItemWithOptionalIdAndMeta = exports.isItemId = undefined;
  var id_1 = require_id();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isItemId(input) {
    return typeof input === "string";
  }
  exports.isItemId = isItemId;
  function isItemWithOptionalIdAndMeta(block) {
    return typeof block === "object" && block !== null && "type" in block && block.type === "item" && "attributes" in block && "relationships" in block;
  }
  exports.isItemWithOptionalIdAndMeta = isItemWithOptionalIdAndMeta;
  function isItemWithOptionalMeta(block) {
    return isItemWithOptionalIdAndMeta(block) && "id" in block && typeof block.id === "string";
  }
  exports.isItemWithOptionalMeta = isItemWithOptionalMeta;
  function isSingleBlockFieldValue(value) {
    return typeof value === "string" && (0, id_1.isValidId)(value) || value === null;
  }
  exports.isSingleBlockFieldValue = isSingleBlockFieldValue;
  function isLocalizedSingleBlockFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isSingleBlockFieldValue);
  }
  exports.isLocalizedSingleBlockFieldValue = isLocalizedSingleBlockFieldValue;
  function isSingleBlockFieldValueInRequest(value) {
    if (value === null)
      return true;
    if (isItemId(value))
      return true;
    return isItemWithOptionalIdAndMeta(value);
  }
  exports.isSingleBlockFieldValueInRequest = isSingleBlockFieldValueInRequest;
  function isLocalizedSingleBlockFieldValueInRequest(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isSingleBlockFieldValueInRequest);
  }
  exports.isLocalizedSingleBlockFieldValueInRequest = isLocalizedSingleBlockFieldValueInRequest;
  function isSingleBlockFieldValueInNestedResponse(value) {
    if (value === null)
      return true;
    return isItemWithOptionalMeta(value);
  }
  exports.isSingleBlockFieldValueInNestedResponse = isSingleBlockFieldValueInNestedResponse;
  function isLocalizedSingleBlockFieldValueInNestedResponse(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isSingleBlockFieldValueInNestedResponse);
  }
  exports.isLocalizedSingleBlockFieldValueInNestedResponse = isLocalizedSingleBlockFieldValueInNestedResponse;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/rich_text.js
var require_rich_text2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedRichTextFieldValueInNestedResponse = exports.isRichTextFieldValueInNestedResponse = exports.isLocalizedRichTextFieldValueInRequest = exports.isRichTextFieldValueInRequest = exports.isLocalizedRichTextFieldValue = exports.isRichTextFieldValue = undefined;
  var id_1 = require_id();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  var single_block_1 = require_single_block();
  function isRichTextFieldValue(value) {
    return Array.isArray(value) && value.every((block) => typeof block === "string" && (0, id_1.isValidId)(block));
  }
  exports.isRichTextFieldValue = isRichTextFieldValue;
  function isLocalizedRichTextFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isRichTextFieldValue);
  }
  exports.isLocalizedRichTextFieldValue = isLocalizedRichTextFieldValue;
  function isRichTextFieldValueInRequest(value) {
    if (value === null)
      return true;
    if (!Array.isArray(value))
      return false;
    return value.every((block) => {
      if ((0, single_block_1.isItemId)(block))
        return true;
      return (0, single_block_1.isItemWithOptionalIdAndMeta)(block);
    });
  }
  exports.isRichTextFieldValueInRequest = isRichTextFieldValueInRequest;
  function isLocalizedRichTextFieldValueInRequest(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isRichTextFieldValueInRequest);
  }
  exports.isLocalizedRichTextFieldValueInRequest = isLocalizedRichTextFieldValueInRequest;
  function isRichTextFieldValueInNestedResponse(value) {
    if (!Array.isArray(value))
      return false;
    return value.every((block) => {
      return (0, single_block_1.isItemWithOptionalMeta)(block);
    });
  }
  exports.isRichTextFieldValueInNestedResponse = isRichTextFieldValueInNestedResponse;
  function isLocalizedRichTextFieldValueInNestedResponse(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isRichTextFieldValueInNestedResponse);
  }
  exports.isLocalizedRichTextFieldValueInNestedResponse = isLocalizedRichTextFieldValueInNestedResponse;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/seo.js
var require_seo2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedSeoFieldValue = exports.isSeoFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isSeoFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "object" && value !== null && (("title" in value) || ("description" in value) || ("image" in value) || ("twitter_card" in value) || ("no_index" in value));
  }
  exports.isSeoFieldValue = isSeoFieldValue;
  function isLocalizedSeoFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isSeoFieldValue);
  }
  exports.isLocalizedSeoFieldValue = isLocalizedSeoFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/slug.js
var require_slug2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedSlugFieldValue = exports.isSlugFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isSlugFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "string";
  }
  exports.isSlugFieldValue = isSlugFieldValue;
  function isLocalizedSlugFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isSlugFieldValue);
  }
  exports.isLocalizedSlugFieldValue = isLocalizedSlugFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedStringFieldValue = exports.isStringFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isStringFieldValue(value) {
    return typeof value === "string" || value === null;
  }
  exports.isStringFieldValue = isStringFieldValue;
  function isLocalizedStringFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isStringFieldValue);
  }
  exports.isLocalizedStringFieldValue = isLocalizedStringFieldValue;
});

// node_modules/datocms-structured-text-utils/dist/cjs/definitions.js
var require_definitions = __commonJS((exports) => {
  var _a;
  var _b;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultMarks = exports.allowedAttributes = exports.inlineNodeTypes = exports.allowedChildren = exports.allowedNodeTypes = exports.thematicBreakNodeType = exports.spanNodeType = exports.rootNodeType = exports.paragraphNodeType = exports.listNodeType = exports.listItemNodeType = exports.linkNodeType = exports.itemLinkNodeType = exports.inlineItemNodeType = exports.headingNodeType = exports.codeNodeType = exports.inlineBlockNodeType = exports.blockNodeType = exports.blockquoteNodeType = undefined;
  exports.blockquoteNodeType = "blockquote";
  exports.blockNodeType = "block";
  exports.inlineBlockNodeType = "inlineBlock";
  exports.codeNodeType = "code";
  exports.headingNodeType = "heading";
  exports.inlineItemNodeType = "inlineItem";
  exports.itemLinkNodeType = "itemLink";
  exports.linkNodeType = "link";
  exports.listItemNodeType = "listItem";
  exports.listNodeType = "list";
  exports.paragraphNodeType = "paragraph";
  exports.rootNodeType = "root";
  exports.spanNodeType = "span";
  exports.thematicBreakNodeType = "thematicBreak";
  exports.allowedNodeTypes = [
    exports.blockquoteNodeType,
    exports.blockNodeType,
    exports.inlineBlockNodeType,
    exports.codeNodeType,
    exports.headingNodeType,
    exports.inlineItemNodeType,
    exports.itemLinkNodeType,
    exports.linkNodeType,
    exports.listItemNodeType,
    exports.listNodeType,
    exports.paragraphNodeType,
    exports.rootNodeType,
    exports.spanNodeType,
    exports.thematicBreakNodeType
  ];
  exports.allowedChildren = (_a = {}, _a[exports.blockquoteNodeType] = [exports.paragraphNodeType], _a[exports.blockNodeType] = [], _a[exports.inlineBlockNodeType] = [], _a[exports.codeNodeType] = [], _a[exports.headingNodeType] = "inlineNodes", _a[exports.inlineItemNodeType] = [], _a[exports.itemLinkNodeType] = "inlineNodes", _a[exports.linkNodeType] = "inlineNodes", _a[exports.listItemNodeType] = [exports.paragraphNodeType, exports.listNodeType], _a[exports.listNodeType] = [exports.listItemNodeType], _a[exports.paragraphNodeType] = "inlineNodes", _a[exports.rootNodeType] = [
    exports.blockquoteNodeType,
    exports.codeNodeType,
    exports.listNodeType,
    exports.paragraphNodeType,
    exports.headingNodeType,
    exports.blockNodeType,
    exports.thematicBreakNodeType
  ], _a[exports.spanNodeType] = [], _a[exports.thematicBreakNodeType] = [], _a);
  exports.inlineNodeTypes = [
    exports.spanNodeType,
    exports.linkNodeType,
    exports.itemLinkNodeType,
    exports.inlineItemNodeType,
    exports.inlineBlockNodeType
  ];
  exports.allowedAttributes = (_b = {}, _b[exports.blockquoteNodeType] = ["children", "attribution"], _b[exports.blockNodeType] = ["item"], _b[exports.inlineBlockNodeType] = ["item"], _b[exports.codeNodeType] = ["language", "highlight", "code"], _b[exports.headingNodeType] = ["level", "children", "style"], _b[exports.inlineItemNodeType] = ["item"], _b[exports.itemLinkNodeType] = ["item", "children", "meta"], _b[exports.linkNodeType] = ["url", "children", "meta"], _b[exports.listItemNodeType] = ["children"], _b[exports.listNodeType] = ["style", "children"], _b[exports.paragraphNodeType] = ["children", "style"], _b[exports.rootNodeType] = ["children"], _b[exports.spanNodeType] = ["value", "marks"], _b[exports.thematicBreakNodeType] = [], _b);
  exports.defaultMarks = [
    "strong",
    "code",
    "emphasis",
    "underline",
    "strikethrough",
    "highlight"
  ];
});

// node_modules/datocms-structured-text-utils/dist/cjs/guards.js
var require_guards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmptyDocument = exports.isDocument = exports.isStructuredText = exports.isCdaStructuredTextValue = exports.isNode = exports.isNodeType = exports.isThematicBreak = exports.isInlineItem = exports.isItemLink = exports.isLink = exports.isCode = exports.isInlineBlock = exports.isBlock = exports.isBlockquote = exports.isListItem = exports.isList = exports.isParagraph = exports.isRoot = exports.isSpan = exports.isHeading = exports.isInlineNode = exports.hasChildren = undefined;
  var definitions_1 = require_definitions();
  function hasChildren(node) {
    return "children" in node;
  }
  exports.hasChildren = hasChildren;
  function isInlineNode(node) {
    return definitions_1.inlineNodeTypes.includes(node.type);
  }
  exports.isInlineNode = isInlineNode;
  function isHeading(node) {
    return node.type === definitions_1.headingNodeType;
  }
  exports.isHeading = isHeading;
  function isSpan(node) {
    return node.type === definitions_1.spanNodeType;
  }
  exports.isSpan = isSpan;
  function isRoot(node) {
    return node.type === definitions_1.rootNodeType;
  }
  exports.isRoot = isRoot;
  function isParagraph(node) {
    return node.type === definitions_1.paragraphNodeType;
  }
  exports.isParagraph = isParagraph;
  function isList(node) {
    return node.type === definitions_1.listNodeType;
  }
  exports.isList = isList;
  function isListItem(node) {
    return node.type === definitions_1.listItemNodeType;
  }
  exports.isListItem = isListItem;
  function isBlockquote(node) {
    return node.type === definitions_1.blockquoteNodeType;
  }
  exports.isBlockquote = isBlockquote;
  function isBlock(node) {
    return node.type === definitions_1.blockNodeType;
  }
  exports.isBlock = isBlock;
  function isInlineBlock(node) {
    return node.type === definitions_1.inlineBlockNodeType;
  }
  exports.isInlineBlock = isInlineBlock;
  function isCode(node) {
    return node.type === definitions_1.codeNodeType;
  }
  exports.isCode = isCode;
  function isLink(node) {
    return node.type === definitions_1.linkNodeType;
  }
  exports.isLink = isLink;
  function isItemLink(node) {
    return node.type === definitions_1.itemLinkNodeType;
  }
  exports.isItemLink = isItemLink;
  function isInlineItem(node) {
    return node.type === definitions_1.inlineItemNodeType;
  }
  exports.isInlineItem = isInlineItem;
  function isThematicBreak(node) {
    return node.type === definitions_1.thematicBreakNodeType;
  }
  exports.isThematicBreak = isThematicBreak;
  function isObject(obj) {
    return Boolean(typeof obj === "object" && obj);
  }
  function isNodeType(value) {
    return definitions_1.allowedNodeTypes.includes(value);
  }
  exports.isNodeType = isNodeType;
  function isNode(obj) {
    return Boolean(isObject(obj) && "type" in obj && typeof obj.type === "string" && isNodeType(obj.type));
  }
  exports.isNode = isNode;
  function isCdaStructuredTextValue(obj) {
    return Boolean(isObject(obj) && "value" in obj && isDocument(obj.value));
  }
  exports.isCdaStructuredTextValue = isCdaStructuredTextValue;
  function isStructuredText(obj) {
    return isCdaStructuredTextValue(obj);
  }
  exports.isStructuredText = isStructuredText;
  function isDocument(obj) {
    return Boolean(isObject(obj) && "schema" in obj && "document" in obj && obj.schema === "dast");
  }
  exports.isDocument = isDocument;
  function isEmptyDocument(obj) {
    if (!obj) {
      return true;
    }
    var document2 = isStructuredText(obj) && isDocument(obj.value) ? obj.value : isDocument(obj) ? obj : null;
    if (!document2) {
      throw new Error("Passed object is neither null, a Structured Text value or a DAST document");
    }
    return document2.document.children.length === 1 && document2.document.children[0].type === "paragraph" && document2.document.children[0].children.length === 1 && document2.document.children[0].children[0].type === "span" && document2.document.children[0].children[0].value === "";
  }
  exports.isEmptyDocument = isEmptyDocument;
});

// node_modules/datocms-structured-text-utils/dist/cjs/inspector.js
var require_inspector = __commonJS((exports) => {
  var __spreadArrays = exports && exports.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length;i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0;i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
        r[k] = a[j];
    return r;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatAsTree = exports.inspect = exports.inspectionTreeNodes = undefined;
  var guards_1 = require_guards();
  var DEFAULT_CONFIG = {
    MAX_WIDTH: 80
  };
  function nodeHasChildren(node) {
    return guards_1.hasChildren(node);
  }
  function defaultBlockFormatter(item) {
    return "(item: " + JSON.stringify(item) + ")";
  }
  function extractNode(input) {
    return guards_1.isDocument(input) ? input.document : input;
  }
  function inspectionTreeNodes(input, options) {
    if (options === undefined) {
      options = {};
    }
    var rootNode = extractNode(input);
    var rootTreeNode = buildTreeNode(rootNode, options);
    if (rootTreeNode.nodes && rootTreeNode.nodes.length > 0) {
      if (rootTreeNode.nodes.length === 1) {
        return rootTreeNode.nodes[0];
      }
      return {
        label: "",
        nodes: rootTreeNode.nodes
      };
    }
    return { label: "" };
  }
  exports.inspectionTreeNodes = inspectionTreeNodes;
  function inspect(input, options) {
    if (options === undefined) {
      options = {};
    }
    return formatAsTree(inspectionTreeNodes(input, options));
  }
  exports.inspect = inspect;
  function buildTreeNode(node, options) {
    var _a;
    var _b;
    var maxWidth = (_b = options.maxWidth) !== null && _b !== undefined ? _b : DEFAULT_CONFIG.MAX_WIDTH;
    var availableWidth = Math.max(20, maxWidth - 8);
    var nodeLabel = buildNodeLabel(node, options, availableWidth);
    var treeNode = {
      label: nodeLabel
    };
    if (nodeHasChildren(node)) {
      var children = node.children;
      if (children.length > 0) {
        treeNode.nodes = [];
        for (var _i = 0, children_1 = children;_i < children_1.length; _i++) {
          var child = children_1[_i];
          treeNode.nodes.push(buildTreeNode(child, options));
        }
      }
    }
    if ((guards_1.isBlock(node) || guards_1.isInlineBlock(node)) && options.blockFormatter) {
      var formattedContent = options.blockFormatter(node.item, availableWidth);
      if (typeof formattedContent !== "string") {
        if (!treeNode.nodes) {
          treeNode.nodes = [];
        }
        if (Array.isArray(formattedContent)) {
          (_a = treeNode.nodes).push.apply(_a, formattedContent);
        } else {
          treeNode.nodes.push(formattedContent);
        }
      }
    }
    return treeNode;
  }
  function buildNodeLabel(node, options, availableWidth) {
    var metaInfo = [];
    var content = "";
    if (guards_1.isSpan(node)) {
      if (node.marks && node.marks.length > 0) {
        metaInfo.push("marks: " + node.marks.join(", "));
      }
      content = ' "' + truncateText(node.value, availableWidth) + '"';
    } else if (guards_1.isCode(node)) {
      if (node.language) {
        metaInfo.push('language: "' + node.language + '"');
      }
      content = ' "' + truncateText(node.code, availableWidth) + '"';
    } else if (guards_1.isHeading(node)) {
      metaInfo.push("level: " + node.level);
    } else if (guards_1.isList(node)) {
      metaInfo.push("style: " + node.style);
    } else if (guards_1.isLink(node)) {
      metaInfo.push('url: "' + node.url + '"');
      if (node.meta && node.meta.length > 0) {
        var metaEntries = node.meta.map(function(m) {
          return m.id + '="' + m.value + '"';
        }).join(", ");
        metaInfo.push("meta: {" + metaEntries + "}");
      }
    } else if (guards_1.isItemLink(node)) {
      metaInfo.push('item: "' + node.item + '"');
      if (node.meta && node.meta.length > 0) {
        var metaEntries = node.meta.map(function(m) {
          return m.id + '="' + m.value + '"';
        }).join(", ");
        metaInfo.push("meta: {" + metaEntries + "}");
      }
    } else if (guards_1.isBlock(node) || guards_1.isInlineBlock(node)) {
      var formatter = options.blockFormatter || defaultBlockFormatter;
      var formattedContent = formatter(node.item, availableWidth);
      if (typeof formattedContent === "string") {
        var singleLineContent = formattedContent.replace(/\n/g, " ").trim();
        content = " " + singleLineContent;
      }
    } else if (guards_1.isParagraph(node)) {
      if (node.style) {
        metaInfo.push('style: "' + node.style + '"');
      }
    }
    var metaString = metaInfo.length > 0 ? " (" + metaInfo.join(", ") + ")" : "";
    return "" + node.type + metaString + content;
  }
  function truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }
  function formatAsTree(input) {
    var root = typeof input === "string" ? { label: input } : input;
    var out = [];
    function render(node, ancestorsHasNext, isLast) {
      var label = node.label.trim();
      var children = node.nodes || [];
      if (!label && children.length > 0) {
        children.forEach(function(child, idx) {
          var childIsLast = idx === children.length - 1;
          render(child, ancestorsHasNext, childIsLast);
        });
        return;
      }
      var ancestorPrefix = ancestorsHasNext.map(function(h) {
        return h ? "│ " : "  ";
      }).join("");
      var branch = isLast ? "└" : "├";
      var lines = label.split(`
`);
      out.push("" + ancestorPrefix + branch + " " + lines[0]);
      var contPrefix = ancestorPrefix + (isLast ? "  " : "│ ");
      for (var i = 1;i < lines.length; i++) {
        out.push("" + contPrefix + lines[i]);
      }
      children.forEach(function(child, idx) {
        var childIsLast = idx === children.length - 1;
        render(child, __spreadArrays(ancestorsHasNext, [!isLast]), childIsLast);
      });
    }
    render(root, [], true);
    return out.join(`
`) + `
`;
  }
  exports.formatAsTree = formatAsTree;
});

// node_modules/datocms-structured-text-utils/dist/cjs/manipulation.js
var require_manipulation = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __spreadArrays = exports && exports.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length;i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0;i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
        r[k] = a[j];
    return r;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.everyNodeAsync = exports.everyNode = exports.someNodeAsync = exports.someNode = exports.reduceNodesAsync = exports.reduceNodes = exports.filterNodesAsync = exports.filterNodes = exports.findFirstNodeAsync = exports.findFirstNode = exports.collectNodesAsync = exports.collectNodes = exports.mapNodesAsync = exports.mapNodes = exports.forEachNodeAsync = exports.forEachNode = undefined;
  function isDocument(input) {
    return typeof input === "object" && input !== null && "schema" in input && input.schema === "dast" && "document" in input;
  }
  function extractNode(input) {
    return isDocument(input) ? input.document : input;
  }
  function hasChildren(node) {
    return typeof node === "object" && node !== null && "children" in node && Array.isArray(node.children);
  }
  function forEachNode(input, visitor, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    visitor(node, parent, path);
    if (hasChildren(node)) {
      for (var index = 0;index < node.children.length; index++) {
        var child = node.children[index];
        forEachNode(child, visitor, node, __spreadArrays(path, [
          "children",
          index
        ]));
      }
    }
  }
  exports.forEachNode = forEachNode;
  function forEachNodeAsync(input, visitor, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, index, child;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, visitor(node, parent, path)];
          case 1:
            _a.sent();
            if (!hasChildren(node))
              return [3, 5];
            index = 0;
            _a.label = 2;
          case 2:
            if (!(index < node.children.length))
              return [3, 5];
            child = node.children[index];
            return [4, forEachNodeAsync(child, visitor, node, __spreadArrays(path, [
              "children",
              index
            ]))];
          case 3:
            _a.sent();
            _a.label = 4;
          case 4:
            index++;
            return [3, 2];
          case 5:
            return [2];
        }
      });
    });
  }
  exports.forEachNodeAsync = forEachNodeAsync;
  function mapNodes(input, mapper, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    var transformedNode = mapper(node, parent, path);
    var result;
    if (hasChildren(node) && typeof transformedNode === "object" && transformedNode !== null) {
      var transformedChildren = node.children.map(function(child, index) {
        return extractNode(mapNodes(child, mapper, node, __spreadArrays(path, [
          "children",
          index
        ])));
      });
      result = __assign(__assign({}, transformedNode), { children: transformedChildren });
    } else {
      result = transformedNode;
    }
    if (isDocument(input)) {
      return {
        schema: "dast",
        document: result
      };
    }
    return result;
  }
  exports.mapNodes = mapNodes;
  function mapNodesAsync(input, mapper, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, transformedNode, result, transformedChildren;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, mapper(node, parent, path)];
          case 1:
            transformedNode = _a.sent();
            if (!(hasChildren(node) && typeof transformedNode === "object" && transformedNode !== null))
              return [3, 3];
            return [4, Promise.all(node.children.map(function(child, index) {
              return __awaiter(_this, undefined, undefined, function() {
                var _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _a2 = extractNode;
                      return [4, mapNodesAsync(child, mapper, node, __spreadArrays(path, [
                        "children",
                        index
                      ]))];
                    case 1:
                      return [2, _a2.apply(undefined, [_b.sent()])];
                  }
                });
              });
            }))];
          case 2:
            transformedChildren = _a.sent();
            result = __assign(__assign({}, transformedNode), { children: transformedChildren });
            return [3, 4];
          case 3:
            result = transformedNode;
            _a.label = 4;
          case 4:
            if (isDocument(input)) {
              return [2, {
                schema: "dast",
                document: result
              }];
            }
            return [2, result];
        }
      });
    });
  }
  exports.mapNodesAsync = mapNodesAsync;
  function collectNodes(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var results = [];
    forEachNode(input, function(currentNode, currentParent, currentPath) {
      if (predicate(currentNode, currentParent, currentPath)) {
        results.push({ node: currentNode, path: currentPath });
      }
    }, parent, path);
    return results;
  }
  exports.collectNodes = collectNodes;
  function collectNodesAsync(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var results;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            results = [];
            return [4, forEachNodeAsync(input, function(currentNode, currentParent, currentPath) {
              return __awaiter(_this, undefined, undefined, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, predicate(currentNode, currentParent, currentPath)];
                    case 1:
                      if (_a2.sent()) {
                        results.push({ node: currentNode, path: currentPath });
                      }
                      return [2];
                  }
                });
              });
            }, parent, path)];
          case 1:
            _a.sent();
            return [2, results];
        }
      });
    });
  }
  exports.collectNodesAsync = collectNodesAsync;
  function findFirstNode(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    if (predicate(node, parent, path)) {
      return { node, path };
    }
    if (hasChildren(node)) {
      for (var index = 0;index < node.children.length; index++) {
        var child = node.children[index];
        var result = findFirstNode(child, predicate, node, __spreadArrays(path, ["children", index]));
        if (result) {
          return result;
        }
      }
    }
    return null;
  }
  exports.findFirstNode = findFirstNode;
  function findFirstNodeAsync(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, index, child, result;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, predicate(node, parent, path)];
          case 1:
            if (_a.sent()) {
              return [2, { node, path }];
            }
            if (!hasChildren(node))
              return [3, 5];
            index = 0;
            _a.label = 2;
          case 2:
            if (!(index < node.children.length))
              return [3, 5];
            child = node.children[index];
            return [4, findFirstNodeAsync(child, predicate, node, __spreadArrays(path, ["children", index]))];
          case 3:
            result = _a.sent();
            if (result) {
              return [2, result];
            }
            _a.label = 4;
          case 4:
            index++;
            return [3, 2];
          case 5:
            return [2, null];
        }
      });
    });
  }
  exports.findFirstNodeAsync = findFirstNodeAsync;
  function filterNodes(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    if (!predicate(node, parent, path)) {
      return null;
    }
    var result;
    if (!hasChildren(node)) {
      result = node;
    } else {
      var childrenResults = node.children.map(function(child, index) {
        var childResult = filterNodes(child, predicate, node, __spreadArrays(path, ["children", index]));
        return childResult ? extractNode(childResult) : null;
      });
      var prunedChildren = childrenResults.filter(function(child) {
        return child !== null;
      });
      result = __assign(__assign({}, node), { children: prunedChildren });
    }
    if (isDocument(input)) {
      return {
        schema: "dast",
        document: result
      };
    }
    return result;
  }
  exports.filterNodes = filterNodes;
  function filterNodesAsync(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, result, childrenResults, prunedChildren;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, predicate(node, parent, path)];
          case 1:
            if (!_a.sent()) {
              return [2, null];
            }
            if (!!hasChildren(node))
              return [3, 2];
            result = node;
            return [3, 4];
          case 2:
            return [4, Promise.all(node.children.map(function(child, index) {
              return __awaiter(_this, undefined, undefined, function() {
                var childResult;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, filterNodesAsync(child, predicate, node, __spreadArrays(path, ["children", index]))];
                    case 1:
                      childResult = _a2.sent();
                      return [2, childResult ? extractNode(childResult) : null];
                  }
                });
              });
            }))];
          case 3:
            childrenResults = _a.sent();
            prunedChildren = childrenResults.filter(function(child) {
              return child !== null;
            });
            result = __assign(__assign({}, node), { children: prunedChildren });
            _a.label = 4;
          case 4:
            if (isDocument(input)) {
              return [2, {
                schema: "dast",
                document: result
              }];
            }
            return [2, result];
        }
      });
    });
  }
  exports.filterNodesAsync = filterNodesAsync;
  function reduceNodes(input, reducer, initialValue, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    var accumulator = initialValue;
    forEachNode(node, function(currentNode, currentParent, currentPath) {
      accumulator = reducer(accumulator, currentNode, currentParent, currentPath);
    }, parent, path);
    return accumulator;
  }
  exports.reduceNodes = reduceNodes;
  function reduceNodesAsync(input, reducer, initialValue, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, accumulator;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            accumulator = initialValue;
            return [4, forEachNodeAsync(node, function(currentNode, currentParent, currentPath) {
              return __awaiter(_this, undefined, undefined, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, reducer(accumulator, currentNode, currentParent, currentPath)];
                    case 1:
                      accumulator = _a2.sent();
                      return [2];
                  }
                });
              });
            }, parent, path)];
          case 1:
            _a.sent();
            return [2, accumulator];
        }
      });
    });
  }
  exports.reduceNodesAsync = reduceNodesAsync;
  function someNode(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    if (predicate(node, parent, path)) {
      return true;
    }
    if (hasChildren(node)) {
      for (var index = 0;index < node.children.length; index++) {
        var child = node.children[index];
        if (someNode(child, predicate, node, __spreadArrays(path, [
          "children",
          index
        ]))) {
          return true;
        }
      }
    }
    return false;
  }
  exports.someNode = someNode;
  function someNodeAsync(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node, index, child;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, predicate(node, parent, path)];
          case 1:
            if (_a.sent()) {
              return [2, true];
            }
            if (!hasChildren(node))
              return [3, 5];
            index = 0;
            _a.label = 2;
          case 2:
            if (!(index < node.children.length))
              return [3, 5];
            child = node.children[index];
            return [4, someNodeAsync(child, predicate, node, __spreadArrays(path, [
              "children",
              index
            ]))];
          case 3:
            if (_a.sent()) {
              return [2, true];
            }
            _a.label = 4;
          case 4:
            index++;
            return [3, 2];
          case 5:
            return [2, false];
        }
      });
    });
  }
  exports.someNodeAsync = someNodeAsync;
  function everyNode(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    var node = extractNode(input);
    return !someNode(node, function(currentNode, currentParent, currentPath) {
      return !predicate(currentNode, currentParent, currentPath);
    }, parent, path);
  }
  exports.everyNode = everyNode;
  function everyNodeAsync(input, predicate, parent, path) {
    if (parent === undefined) {
      parent = null;
    }
    if (path === undefined) {
      path = [];
    }
    return __awaiter(this, undefined, undefined, function() {
      var node;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            node = extractNode(input);
            return [4, someNodeAsync(node, function(currentNode, currentParent, currentPath) {
              return __awaiter(_this, undefined, undefined, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, predicate(currentNode, currentParent, currentPath)];
                    case 1:
                      return [2, !_a2.sent()];
                  }
                });
              });
            }, parent, path)];
          case 1:
            return [2, !_a.sent()];
        }
      });
    });
  }
  exports.everyNodeAsync = everyNodeAsync;
});

// node_modules/array-flatten/dist/index.js
var require_dist3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function flatten(array) {
    var result = [];
    $flatten(array, result);
    return result;
  }
  exports.flatten = flatten;
  function $flatten(array, result) {
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        $flatten(value, result);
      } else {
        result.push(value);
      }
    }
  }
});

// node_modules/datocms-structured-text-utils/dist/cjs/render.js
var require_render = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __spreadArrays = exports && exports.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length;i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0;i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
        r[k] = a[j];
    return r;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.render = exports.transformNode = exports.renderRule = exports.RenderError = undefined;
  var array_flatten_1 = require_dist3();
  var guards_1 = require_guards();
  var RenderError = function(_super) {
    __extends(RenderError2, _super);
    function RenderError2(message, node) {
      var _this = _super.call(this, message) || this;
      _this.node = node;
      Object.setPrototypeOf(_this, RenderError2.prototype);
      return _this;
    }
    return RenderError2;
  }(Error);
  exports.RenderError = RenderError;
  var renderRule = function(guard, transform) {
    return {
      appliable: guard,
      apply: function(ctx) {
        return transform(ctx);
      }
    };
  };
  exports.renderRule = renderRule;
  function transformNode(adapter, node, key, ancestors, renderRules) {
    var children = guards_1.hasChildren(node) ? array_flatten_1.flatten(node.children.map(function(innerNode, index) {
      return transformNode(adapter, innerNode, "t-" + index, __spreadArrays([node], ancestors), renderRules);
    }).filter(function(x) {
      return !!x;
    })) : undefined;
    var matchingTransform = renderRules.find(function(transform) {
      return transform.appliable(node);
    });
    if (matchingTransform) {
      return matchingTransform.apply({ adapter, node, children, key, ancestors });
    }
    throw new RenderError(`Don't know how to render a node with type "` + node.type + '". Please specify a custom renderRule for it!', node);
  }
  exports.transformNode = transformNode;
  function render(adapter, structuredTextOrNode, renderRules) {
    if (!structuredTextOrNode) {
      return null;
    }
    var node = guards_1.isStructuredText(structuredTextOrNode) && guards_1.isDocument(structuredTextOrNode.value) ? structuredTextOrNode.value.document : guards_1.isDocument(structuredTextOrNode) ? structuredTextOrNode.document : guards_1.isNode(structuredTextOrNode) ? structuredTextOrNode : undefined;
    if (!node) {
      throw new Error("Passed object is neither null, a Structured Text value, a DAST document or a DAST node");
    }
    var result = transformNode(adapter, node, "t-0", [], renderRules);
    return result;
  }
  exports.render = render;
});

// node_modules/datocms-structured-text-utils/dist/cjs/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/datocms-structured-text-utils/dist/cjs/validate.js
var require_validate2 = __commonJS((exports) => {
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = undefined;
  var definitions_1 = require_definitions();
  function validate(document2) {
    if (document2 === null || document2 === undefined) {
      return { valid: true };
    }
    if (document2.schema !== "dast") {
      return {
        valid: false,
        message: `.schema is not "dast":

 ` + JSON.stringify(document2, null, 2)
      };
    }
    var nodes = [document2.document];
    var node = document2.document;
    var _loop_1 = function() {
      var next = nodes.pop();
      if (!next) {
        return "break";
      }
      node = next;
      var type = node.type, attributes = __rest(node, ["type"]);
      var invalidAttribute = Object.keys(attributes).find(function(attr) {
        return !definitions_1.allowedAttributes[node.type].includes(attr);
      });
      if (invalidAttribute) {
        return { value: {
          valid: false,
          message: '"' + node.type + '" has an invalid attribute "' + invalidAttribute + `":

 ` + JSON.stringify(node, null, 2)
        } };
      }
      if ("meta" in node) {
        if (!Array.isArray(node.meta)) {
          return { value: {
            valid: false,
            message: '"' + node.type + `"'s meta is not an Array:

 ` + JSON.stringify(node, null, 2)
          } };
        }
        var invalidMeta = node.meta.find(function(entry) {
          return typeof entry !== "object" || !("id" in entry) || !("value" in entry) || typeof entry.value !== "string";
        });
        if (invalidMeta) {
          return { value: {
            valid: false,
            message: '"' + node.type + '" has an invalid meta ' + JSON.stringify(invalidMeta) + `:

 ` + JSON.stringify(node, null, 2)
          } };
        }
      }
      if ("marks" in node) {
        if (!Array.isArray(node.marks)) {
          return { value: {
            valid: false,
            message: '"' + node.type + `"'s marks is not an Array:

 ` + JSON.stringify(node, null, 2)
          } };
        }
      }
      if ("children" in node) {
        if (!Array.isArray(node.children)) {
          return { value: {
            valid: false,
            message: '"' + node.type + `"'s children is not an Array:

 ` + JSON.stringify(node, null, 2)
          } };
        }
        if (node.children.length === 0) {
          return { value: {
            valid: false,
            message: '"' + node.type + `"'s children cannot be an empty Array:

 ` + JSON.stringify(node, null, 2)
          } };
        }
        var allowed_1 = definitions_1.allowedChildren[node.type];
        if (typeof allowed_1 === "string" && allowed_1 === "inlineNodes") {
          allowed_1 = definitions_1.inlineNodeTypes;
        }
        var invalidChildIndex = node.children.findIndex(function(child) {
          return !child || !allowed_1.includes(child.type);
        });
        if (invalidChildIndex !== -1) {
          var invalidChild = node.children[invalidChildIndex];
          return { value: {
            valid: false,
            message: '"' + node.type + '" has invalid child "' + (invalidChild ? invalidChild.type : invalidChild) + `":

 ` + JSON.stringify(node, null, 2)
          } };
        }
        for (var i = node.children.length - 1;i >= 0; i--) {
          nodes.push(node.children[i]);
        }
      }
    };
    while (nodes.length > 0) {
      var state_1 = _loop_1();
      if (typeof state_1 === "object")
        return state_1.value;
      if (state_1 === "break")
        break;
    }
    return {
      valid: true
    };
  }
  exports.validate = validate;
});

// node_modules/datocms-structured-text-utils/dist/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_definitions(), exports);
  __exportStar(require_guards(), exports);
  __exportStar(require_inspector(), exports);
  __exportStar(require_manipulation(), exports);
  __exportStar(require_render(), exports);
  __exportStar(require_types3(), exports);
  __exportStar(require_validate2(), exports);
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/structured_text.js
var require_structured_text2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedStructuredTextFieldValueInNestedResponse = exports.isStructuredTextFieldValueInNestedResponse = exports.isLocalizedStructuredTextFieldValueInRequest = exports.isStructuredTextFieldValueInRequest = exports.isLocalizedStructuredTextFieldValue = exports.isStructuredTextFieldValue = undefined;
  var datocms_structured_text_utils_1 = require_cjs2();
  var id_1 = require_id();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  var single_block_1 = require_single_block();
  function validateAllBlockNodes(node, callback) {
    return (0, datocms_structured_text_utils_1.everyNode)(node, (currentNode) => {
      if ((0, datocms_structured_text_utils_1.isBlock)(currentNode) || (0, datocms_structured_text_utils_1.isInlineBlock)(currentNode)) {
        return callback(currentNode);
      }
      return true;
    });
  }
  function isStructuredTextFieldValue(value) {
    if (value === null)
      return true;
    if (!(0, datocms_structured_text_utils_1.isDocument)(value)) {
      return false;
    }
    return validateAllBlockNodes(value.document, (node) => {
      return typeof node.item === "string" && (0, id_1.isValidId)(node.item);
    });
  }
  exports.isStructuredTextFieldValue = isStructuredTextFieldValue;
  function isLocalizedStructuredTextFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isStructuredTextFieldValue);
  }
  exports.isLocalizedStructuredTextFieldValue = isLocalizedStructuredTextFieldValue;
  function isStructuredTextFieldValueInRequest(value) {
    if (value === null)
      return true;
    if (!(0, datocms_structured_text_utils_1.isDocument)(value)) {
      return false;
    }
    return validateAllBlockNodes(value.document, (node) => {
      const item = node.item;
      if ((0, single_block_1.isItemId)(item))
        return true;
      return (0, single_block_1.isItemWithOptionalIdAndMeta)(item);
    });
  }
  exports.isStructuredTextFieldValueInRequest = isStructuredTextFieldValueInRequest;
  function isLocalizedStructuredTextFieldValueInRequest(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isStructuredTextFieldValueInRequest);
  }
  exports.isLocalizedStructuredTextFieldValueInRequest = isLocalizedStructuredTextFieldValueInRequest;
  function isStructuredTextFieldValueInNestedResponse(value) {
    if (value === null)
      return true;
    if (!(0, datocms_structured_text_utils_1.isDocument)(value)) {
      return false;
    }
    return validateAllBlockNodes(value.document, (node) => {
      const item = node.item;
      return (0, single_block_1.isItemWithOptionalMeta)(item);
    });
  }
  exports.isStructuredTextFieldValueInNestedResponse = isStructuredTextFieldValueInNestedResponse;
  function isLocalizedStructuredTextFieldValueInNestedResponse(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isStructuredTextFieldValueInNestedResponse);
  }
  exports.isLocalizedStructuredTextFieldValueInNestedResponse = isLocalizedStructuredTextFieldValueInNestedResponse;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/text.js
var require_text = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedTextFieldValue = exports.isTextFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isTextFieldValue(value) {
    return typeof value === "string" || value === null;
  }
  exports.isTextFieldValue = isTextFieldValue;
  function isLocalizedTextFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isTextFieldValue);
  }
  exports.isLocalizedTextFieldValue = isLocalizedTextFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/date_range.js
var require_date_range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/date_time_range.js
var require_date_time_range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/description_length.js
var require_description_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/extension.js
var require_extension = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/file_size.js
var require_file_size = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/image_aspect_ratio.js
var require_image_aspect_ratio = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/image_dimensions.js
var require_image_dimensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/items_item_type.js
var require_items_item_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/item_item_type.js
var require_item_item_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/length.js
var require_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/number_range.js
var require_number_range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/required_alt_title.js
var require_required_alt_title = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/required_seo_fields.js
var require_required_seo_fields = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/rich_text_blocks.js
var require_rich_text_blocks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/sanitized_html.js
var require_sanitized_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/single_block_blocks.js
var require_single_block_blocks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/size.js
var require_size = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/slug_format.js
var require_slug_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/slug_title_field.js
var require_slug_title_field = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/structured_text_blocks.js
var require_structured_text_blocks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/structured_text_inline_blocks.js
var require_structured_text_inline_blocks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/structured_text_links.js
var require_structured_text_links = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/title_length.js
var require_title_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/unique.js
var require_unique = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/validators/index.js
var require_validators = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_date_range(), exports);
  __exportStar(require_date_time_range(), exports);
  __exportStar(require_description_length(), exports);
  __exportStar(require_enum(), exports);
  __exportStar(require_extension(), exports);
  __exportStar(require_file_size(), exports);
  __exportStar(require_format(), exports);
  __exportStar(require_image_aspect_ratio(), exports);
  __exportStar(require_image_dimensions(), exports);
  __exportStar(require_items_item_type(), exports);
  __exportStar(require_item_item_type(), exports);
  __exportStar(require_length(), exports);
  __exportStar(require_number_range(), exports);
  __exportStar(require_required(), exports);
  __exportStar(require_required_alt_title(), exports);
  __exportStar(require_required_seo_fields(), exports);
  __exportStar(require_rich_text_blocks(), exports);
  __exportStar(require_sanitized_html(), exports);
  __exportStar(require_single_block_blocks(), exports);
  __exportStar(require_size(), exports);
  __exportStar(require_slug_format(), exports);
  __exportStar(require_slug_title_field(), exports);
  __exportStar(require_structured_text_blocks(), exports);
  __exportStar(require_structured_text_inline_blocks(), exports);
  __exportStar(require_structured_text_links(), exports);
  __exportStar(require_title_length(), exports);
  __exportStar(require_unique(), exports);
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/video.js
var require_video2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLocalizedVideoFieldValue = exports.isVideoFieldValue = undefined;
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  function isVideoFieldValue(value) {
    if (value === null)
      return true;
    return typeof value === "object" && value !== null && "provider" in value && "provider_uid" in value && "url" in value;
  }
  exports.isVideoFieldValue = isVideoFieldValue;
  function isLocalizedVideoFieldValue(value) {
    return (0, normalizedFieldValues_1.isLocalizedFieldValue)(value) && Object.values(value).every(isVideoFieldValue);
  }
  exports.isLocalizedVideoFieldValue = isLocalizedVideoFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/fieldTypes/index.js
var require_fieldTypes = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_appearance(), exports);
  __exportStar(require_boolean2(), exports);
  __exportStar(require_color(), exports);
  __exportStar(require_date(), exports);
  __exportStar(require_date_time(), exports);
  __exportStar(require_file2(), exports);
  __exportStar(require_float2(), exports);
  __exportStar(require_gallery2(), exports);
  __exportStar(require_integer2(), exports);
  __exportStar(require_json2(), exports);
  __exportStar(require_lat_lon(), exports);
  __exportStar(require_link(), exports);
  __exportStar(require_links(), exports);
  __exportStar(require_rich_text2(), exports);
  __exportStar(require_seo2(), exports);
  __exportStar(require_single_block(), exports);
  __exportStar(require_slug2(), exports);
  __exportStar(require_string(), exports);
  __exportStar(require_structured_text2(), exports);
  __exportStar(require_text(), exports);
  __exportStar(require_validators(), exports);
  __exportStar(require_video2(), exports);
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/buildBlockRecord.js
var require_buildBlockRecord = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildBlockRecord = undefined;
  var Utils = __importStar(require_cjs());
  var resources_1 = require_resources();
  function buildBlockRecord(body) {
    return Utils.serializeRequestBody(body, {
      type: resources_1.Item.TYPE,
      attributes: "*",
      relationships: ["item_type"]
    }).data;
  }
  exports.buildBlockRecord = buildBlockRecord;
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/nonRecursiveBlocks.js
var require_nonRecursiveBlocks = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nonRecursiveEveryBlockInNonLocalizedFieldValueAsync = exports.nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync = exports.nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync = exports.nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync = exports.nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync = exports.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync = exports.nonRecursiveMapBlocksInNonLocalizedFieldValue = exports.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync = undefined;
  var datocms_structured_text_utils_1 = require_cjs2();
  function iterateBlocksAsync(fieldType, nonLocalizedFieldValue) {
    return __asyncGenerator(this, arguments, function* iterateBlocksAsync_1() {
      if (fieldType === "rich_text") {
        const richTextValue = nonLocalizedFieldValue;
        if (richTextValue) {
          for (let index = 0;index < richTextValue.length; index++) {
            const item = richTextValue[index];
            yield yield __await({ item, path: [index] });
          }
        }
        return yield __await(undefined);
      }
      if (fieldType === "single_block") {
        const singleBlockValue = nonLocalizedFieldValue;
        if (singleBlockValue) {
          yield yield __await({ item: singleBlockValue, path: [] });
        }
        return yield __await(undefined);
      }
      if (fieldType === "structured_text") {
        const structuredTextValue = nonLocalizedFieldValue;
        if (structuredTextValue) {
          const foundNodes = yield __await((0, datocms_structured_text_utils_1.collectNodesAsync)(structuredTextValue.document, (node) => __awaiter(this, undefined, undefined, function* () {
            return node.type === "block" || node.type === "inlineBlock";
          })));
          for (const { node, path } of foundNodes) {
            if (node.type === "block" || node.type === "inlineBlock") {
              yield yield __await({ item: node.item, path });
            }
          }
        }
        return yield __await(undefined);
      }
    });
  }
  function nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, visitor) {
    var _a, e_1, _b, _c;
    return __awaiter(this, undefined, undefined, function* () {
      try {
        for (var _d = true, _e = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _f;_f = yield _e.next(), _a = _f.done, !_a; ) {
          _c = _f.value;
          _d = false;
          try {
            const { item, path } = _c;
            yield visitor(item, path);
          } finally {
            _d = true;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            yield _b.call(_e);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  exports.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync = nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveMapBlocksInNonLocalizedFieldValue(fieldType, nonLocalizedFieldValue, mapper) {
    if (fieldType === "rich_text") {
      const richTextValue = nonLocalizedFieldValue;
      return richTextValue ? richTextValue.map((item, index) => mapper(item, [index])) : richTextValue;
    }
    if (fieldType === "single_block") {
      const singleBlockValue = nonLocalizedFieldValue;
      return singleBlockValue ? mapper(singleBlockValue, []) : null;
    }
    if (fieldType === "structured_text") {
      const structuredTextValue = nonLocalizedFieldValue;
      if (!structuredTextValue) {
        return null;
      }
      return {
        schema: "dast",
        document: (0, datocms_structured_text_utils_1.mapNodes)(structuredTextValue.document, (node, _parent, path) => {
          if (node.type === "block" || node.type === "inlineBlock") {
            return Object.assign(Object.assign({}, node), { item: mapper(node.item, path) });
          }
          return node;
        })
      };
    }
    return nonLocalizedFieldValue;
  }
  exports.nonRecursiveMapBlocksInNonLocalizedFieldValue = nonRecursiveMapBlocksInNonLocalizedFieldValue;
  function nonRecursiveMapBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, mapper) {
    return __awaiter(this, undefined, undefined, function* () {
      if (fieldType === "rich_text") {
        const richTextValue = nonLocalizedFieldValue;
        return richTextValue ? yield Promise.all(richTextValue.map((item, index) => mapper(item, [index]))) : richTextValue;
      }
      if (fieldType === "single_block") {
        const singleBlockValue = nonLocalizedFieldValue;
        return singleBlockValue ? yield mapper(singleBlockValue, []) : null;
      }
      if (fieldType === "structured_text") {
        const structuredTextValue = nonLocalizedFieldValue;
        if (!structuredTextValue) {
          return null;
        }
        return {
          schema: "dast",
          document: yield (0, datocms_structured_text_utils_1.mapNodesAsync)(structuredTextValue.document, (node, _parent, path) => __awaiter(this, undefined, undefined, function* () {
            if (node.type === "block" || node.type === "inlineBlock") {
              return Object.assign(Object.assign({}, node), { item: yield mapper(node.item, path) });
            }
            return node;
          }))
        };
      }
      return nonLocalizedFieldValue;
    });
  }
  exports.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync = nonRecursiveMapBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, predicate) {
    var _a, e_2, _b, _c;
    return __awaiter(this, undefined, undefined, function* () {
      const results = [];
      try {
        for (var _d = true, _e = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _f;_f = yield _e.next(), _a = _f.done, !_a; ) {
          _c = _f.value;
          _d = false;
          try {
            const { item, path } = _c;
            if (yield predicate(item, path)) {
              results.push({ item, path });
            }
          } finally {
            _d = true;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            yield _b.call(_e);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return results;
    });
  }
  exports.nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync = nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, predicate) {
    var _a, e_3, _b, _c, _d, e_4, _e, _f;
    return __awaiter(this, undefined, undefined, function* () {
      if (fieldType === "rich_text") {
        const filteredItems = [];
        try {
          for (var _g = true, _h = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _j;_j = yield _h.next(), _a = _j.done, !_a; ) {
            _c = _j.value;
            _g = false;
            try {
              const { item, path } = _c;
              if (yield predicate(item, path)) {
                filteredItems.push(item);
              }
            } finally {
              _g = true;
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (!_g && !_a && (_b = _h.return))
              yield _b.call(_h);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return filteredItems;
      }
      if (fieldType === "single_block") {
        try {
          for (var _k = true, _l = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _m;_m = yield _l.next(), _d = _m.done, !_d; ) {
            _f = _m.value;
            _k = false;
            try {
              const { item, path } = _f;
              if (yield predicate(item, path)) {
                return item;
              }
            } finally {
              _k = true;
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (!_k && !_d && (_e = _l.return))
              yield _e.call(_l);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return null;
      }
      if (fieldType === "structured_text") {
        const structuredTextValue = nonLocalizedFieldValue;
        if (!structuredTextValue) {
          return null;
        }
        const filteredDocument = yield (0, datocms_structured_text_utils_1.filterNodesAsync)(structuredTextValue.document, (node, _parent, path) => __awaiter(this, undefined, undefined, function* () {
          if (node.type === "block" || node.type === "inlineBlock") {
            return yield predicate(node.item, path);
          }
          return true;
        }));
        return filteredDocument ? {
          schema: "dast",
          document: filteredDocument
        } : null;
      }
      return nonLocalizedFieldValue;
    });
  }
  exports.nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync = nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, reducer, initialValue) {
    var _a, e_5, _b, _c;
    return __awaiter(this, undefined, undefined, function* () {
      let accumulator = initialValue;
      try {
        for (var _d = true, _e = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _f;_f = yield _e.next(), _a = _f.done, !_a; ) {
          _c = _f.value;
          _d = false;
          try {
            const { item, path } = _c;
            accumulator = yield reducer(accumulator, item, path);
          } finally {
            _d = true;
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            yield _b.call(_e);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return accumulator;
    });
  }
  exports.nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync = nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, predicate) {
    var _a, e_6, _b, _c;
    return __awaiter(this, undefined, undefined, function* () {
      try {
        for (var _d = true, _e = __asyncValues(iterateBlocksAsync(fieldType, nonLocalizedFieldValue)), _f;_f = yield _e.next(), _a = _f.done, !_a; ) {
          _c = _f.value;
          _d = false;
          try {
            const { item, path } = _c;
            if (yield predicate(item, path)) {
              return true;
            }
          } finally {
            _d = true;
          }
        }
      } catch (e_6_1) {
        e_6 = { error: e_6_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            yield _b.call(_e);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      return false;
    });
  }
  exports.nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync = nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync;
  function nonRecursiveEveryBlockInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, predicate) {
    return __awaiter(this, undefined, undefined, function* () {
      return !(yield nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync(fieldType, nonLocalizedFieldValue, (item, path) => __awaiter(this, undefined, undefined, function* () {
        return !(yield predicate(item, path));
      })));
    });
  }
  exports.nonRecursiveEveryBlockInNonLocalizedFieldValueAsync = nonRecursiveEveryBlockInNonLocalizedFieldValueAsync;
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/recursiveBlocks.js
var require_recursiveBlocks = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapBlocksInNonLocalizedFieldValue = exports.everyBlockInNonLocalizedFieldValue = exports.someBlocksInNonLocalizedFieldValue = exports.reduceBlocksInNonLocalizedFieldValue = exports.filterBlocksInNonLocalizedFieldValue = exports.findAllBlocksInNonLocalizedFieldValue = exports.visitBlocksInNonLocalizedFieldValue = undefined;
  var fieldTypes_1 = require_fieldTypes();
  var nonRecursiveBlocks_1 = require_nonRecursiveBlocks();
  function visitBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, visitor, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        yield visitor(block, [...path, ...innerPath]);
        if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return;
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        for (const field of fields) {
          yield visitBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, visitor, [...path, ...innerPath, "attributes", field.attributes.api_key]);
        }
      }));
    });
  }
  exports.visitBlocksInNonLocalizedFieldValue = visitBlocksInNonLocalizedFieldValue;
  function findAllBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      const results = [];
      const directMatches = yield (0, nonRecursiveBlocks_1.nonRecursiveFindAllBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        return yield predicate(block, [...path, ...innerPath]);
      }));
      results.push(...directMatches.map(({ item, path: innerPath }) => ({
        item,
        path: [...path, ...innerPath]
      })));
      yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return;
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        for (const field of fields) {
          const nestedResults = yield findAllBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, [...path, ...innerPath, "attributes", field.attributes.api_key]);
          results.push(...nestedResults);
        }
      }));
      return results;
    });
  }
  exports.findAllBlocksInNonLocalizedFieldValue = findAllBlocksInNonLocalizedFieldValue;
  function filterBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, options = {}, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      const { traversalDirection = "top-down" } = options;
      const mapperFunc = (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        const blockPath = [...path, ...innerPath];
        if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return block;
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        if (traversalDirection === "top-down") {
          const blockCopy2 = Object.assign(Object.assign({}, block), { attributes: Object.assign({}, block.attributes) });
          for (const field of fields) {
            blockCopy2.attributes[field.attributes.api_key] = yield filterBlocksInNonLocalizedFieldValue(blockCopy2.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, options, [...blockPath, "attributes", field.attributes.api_key]);
          }
          return blockCopy2;
        }
        const blockCopy = Object.assign(Object.assign({}, block), { attributes: Object.assign({}, block.attributes) });
        for (const field of fields) {
          blockCopy.attributes[field.attributes.api_key] = yield filterBlocksInNonLocalizedFieldValue(blockCopy.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, options, [...blockPath, "attributes", field.attributes.api_key]);
        }
        return blockCopy;
      });
      const mappedValue = yield (0, nonRecursiveBlocks_1.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, mapperFunc);
      return (0, nonRecursiveBlocks_1.nonRecursiveFilterBlocksInNonLocalizedFieldValueAsync)(fieldType, mappedValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        const blockPath = [...path, ...innerPath];
        return yield predicate(block, blockPath);
      }));
    });
  }
  exports.filterBlocksInNonLocalizedFieldValue = filterBlocksInNonLocalizedFieldValue;
  function reduceBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, reducer, initialValue, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      let accumulator = yield (0, nonRecursiveBlocks_1.nonRecursiveReduceBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (acc, block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        return yield reducer(acc, block, [...path, ...innerPath]);
      }), initialValue);
      yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return;
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        for (const field of fields) {
          accumulator = yield reduceBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, reducer, accumulator, [...path, ...innerPath, "attributes", field.attributes.api_key]);
        }
      }));
      return accumulator;
    });
  }
  exports.reduceBlocksInNonLocalizedFieldValue = reduceBlocksInNonLocalizedFieldValue;
  function someBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      const directMatch = yield (0, nonRecursiveBlocks_1.nonRecursiveSomeBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        return yield predicate(block, [...path, ...innerPath]);
      }));
      if (directMatch) {
        return true;
      }
      let found = false;
      yield (0, nonRecursiveBlocks_1.nonRecursiveVisitBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        if (found || !(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return;
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        for (const field of fields) {
          if (found)
            break;
          const nestedMatch = yield someBlocksInNonLocalizedFieldValue(block.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, predicate, [...path, ...innerPath, "attributes", field.attributes.api_key]);
          if (nestedMatch) {
            found = true;
          }
        }
      }));
      return found;
    });
  }
  exports.someBlocksInNonLocalizedFieldValue = someBlocksInNonLocalizedFieldValue;
  function everyBlockInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, predicate, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      return !(yield someBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, (item, path2) => __awaiter(this, undefined, undefined, function* () {
        return !(yield predicate(item, path2));
      }), path));
    });
  }
  exports.everyBlockInNonLocalizedFieldValue = everyBlockInNonLocalizedFieldValue;
  function mapBlocksInNonLocalizedFieldValue(nonLocalizedFieldValue, fieldType, schemaRepository, mapper, options = {}, path = []) {
    return __awaiter(this, undefined, undefined, function* () {
      const { traversalDirection = "top-down" } = options;
      return (0, nonRecursiveBlocks_1.nonRecursiveMapBlocksInNonLocalizedFieldValueAsync)(fieldType, nonLocalizedFieldValue, (block, innerPath) => __awaiter(this, undefined, undefined, function* () {
        const blockPath = [...path, ...innerPath];
        if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(block)) {
          return yield mapper(block, blockPath);
        }
        const itemType = yield schemaRepository.getRawItemTypeById(block.relationships.item_type.data.id);
        const fields = yield schemaRepository.getRawItemTypeFields(itemType);
        if (traversalDirection === "top-down") {
          const newBlock = yield mapper(block, blockPath);
          if (!(0, fieldTypes_1.isItemWithOptionalIdAndMeta)(newBlock)) {
            return newBlock;
          }
          for (const field of fields) {
            newBlock.attributes[field.attributes.api_key] = yield mapBlocksInNonLocalizedFieldValue(newBlock.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, mapper, options, [...blockPath, "attributes", field.attributes.api_key]);
          }
          return newBlock;
        }
        const blockCopy = Object.assign({}, block);
        for (const field of fields) {
          blockCopy.attributes[field.attributes.api_key] = yield mapBlocksInNonLocalizedFieldValue(blockCopy.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, mapper, options, [...blockPath, "attributes", field.attributes.api_key]);
        }
        return yield mapper(blockCopy, blockPath);
      }));
    });
  }
  exports.mapBlocksInNonLocalizedFieldValue = mapBlocksInNonLocalizedFieldValue;
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/duplicateBlockRecord.js
var require_duplicateBlockRecord = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.duplicateBlockRecord = undefined;
  var recursiveBlocks_1 = require_recursiveBlocks();
  function duplicateBlockRecord(existingBlock, schemaRepository) {
    return __awaiter(this, undefined, undefined, function* () {
      const { __itemTypeId, type, attributes, relationships } = existingBlock;
      const itemType = yield schemaRepository.getRawItemTypeById(existingBlock.relationships.item_type.data.id);
      const newBlock = {
        __itemTypeId,
        type,
        relationships,
        attributes
      };
      const fields = yield schemaRepository.getRawItemTypeFields(itemType);
      for (const field of fields) {
        newBlock.attributes[field.attributes.api_key] = yield (0, recursiveBlocks_1.mapBlocksInNonLocalizedFieldValue)(newBlock.attributes[field.attributes.api_key], field.attributes.field_type, schemaRepository, (block, path) => {
          if (typeof block === "string") {
            throw new Error(`Block cannot be duplicated as it contains nested block at ${path.join(".")} that is expressed as ID (${block}) instead of full object!`);
          }
          if ("id" in block) {
            const { id, meta: meta2 } = block, blockWithoutIdAndMeta = __rest(block, ["id", "meta"]);
            return blockWithoutIdAndMeta;
          }
          const { meta } = block, blockWithoutMeta = __rest(block, ["meta"]);
          return blockWithoutMeta;
        });
      }
      return newBlock;
    });
  }
  exports.duplicateBlockRecord = duplicateBlockRecord;
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/fieldsContainingReferences.js
var require_fieldsContainingReferences = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blockModelIdsReferencedInField = exports.modelIdsReferencedInField = undefined;
  function modelIdsReferencedInField(field) {
    const attributes = "attributes" in field ? field.attributes : field;
    switch (attributes.field_type) {
      case "link": {
        return attributes.validators.item_item_type.item_types;
      }
      case "links": {
        return attributes.validators.items_item_type.item_types;
      }
      case "structured_text": {
        return attributes.validators.structured_text_links.item_types;
      }
      default: {
        return [];
      }
    }
  }
  exports.modelIdsReferencedInField = modelIdsReferencedInField;
  function blockModelIdsReferencedInField(field) {
    const attributes = "attributes" in field ? field.attributes : field;
    switch (attributes.field_type) {
      case "single_block": {
        return attributes.validators.single_block_blocks.item_types;
      }
      case "rich_text": {
        return attributes.validators.rich_text_blocks.item_types;
      }
      case "structured_text": {
        return [
          ...attributes.validators.structured_text_blocks.item_types,
          ...attributes.validators.structured_text_inline_blocks ? attributes.validators.structured_text_inline_blocks.item_types : []
        ];
      }
      default: {
        return [];
      }
    }
  }
  exports.blockModelIdsReferencedInField = blockModelIdsReferencedInField;
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/inspectItem.js
var require_inspectItem = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inspectItem = undefined;
  var Utils = __importStar(require_cjs());
  var datocms_structured_text_utils_1 = require_cjs2();
  var fieldTypes_1 = require_fieldTypes();
  var resources_1 = require_resources();
  var normalizedFieldValues_1 = require_normalizedFieldValues();
  var fieldTypeHandlers = [
    { guard: fieldTypes_1.isBooleanFieldValue, inspect: booleanInspectionTreeNodes },
    { guard: fieldTypes_1.isFloatFieldValue, inspect: floatInspectionTreeNodes },
    { guard: fieldTypes_1.isIntegerFieldValue, inspect: integerInspectionTreeNodes },
    { guard: fieldTypes_1.isColorFieldValue, inspect: colorInspectionTreeNodes },
    { guard: fieldTypes_1.isDateFieldValue, inspect: dateInspectionTreeNodes },
    { guard: fieldTypes_1.isDateTimeFieldValue, inspect: dateTimeInspectionTreeNodes },
    { guard: fieldTypes_1.isGalleryFieldValue, inspect: galleryInspectionTreeNodes },
    { guard: fieldTypes_1.isGalleryFieldValueInRequest, inspect: galleryInspectionTreeNodes },
    { guard: fieldTypes_1.isFileFieldValue, inspect: fileInspectionTreeNodes },
    { guard: fieldTypes_1.isFileFieldValueInRequest, inspect: fileInspectionTreeNodes },
    { guard: fieldTypes_1.isJsonFieldValue, inspect: jsonInspectionTreeNodes },
    { guard: fieldTypes_1.isSlugFieldValue, inspect: slugInspectionTreeNodes },
    { guard: fieldTypes_1.isStringFieldValue, inspect: stringInspectionTreeNodes },
    { guard: fieldTypes_1.isTextFieldValue, inspect: textInspectionTreeNodes },
    { guard: fieldTypes_1.isLatLonFieldValue, inspect: latLonInspectionTreeNodes },
    { guard: fieldTypes_1.isLinkFieldValue, inspect: linkInspectionTreeNodes },
    { guard: fieldTypes_1.isLinksFieldValue, inspect: linksInspectionTreeNodes },
    { guard: fieldTypes_1.isSeoFieldValue, inspect: seoFieldInspectionTreeNodes },
    { guard: fieldTypes_1.isVideoFieldValue, inspect: videoFieldInspectionTreeNodes },
    {
      guard: fieldTypes_1.isStructuredTextFieldValue,
      inspect: structuredTextInspectionTreeNodes
    },
    {
      guard: fieldTypes_1.isStructuredTextFieldValueInRequest,
      inspect: structuredTextInspectionTreeNodes
    },
    {
      guard: fieldTypes_1.isStructuredTextFieldValueInNestedResponse,
      inspect: structuredTextInspectionTreeNodes
    },
    { guard: fieldTypes_1.isSingleBlockFieldValue, inspect: singleBlockInspectionTreeNodes },
    {
      guard: fieldTypes_1.isSingleBlockFieldValueInRequest,
      inspect: singleBlockInspectionTreeNodes
    },
    {
      guard: fieldTypes_1.isSingleBlockFieldValueInNestedResponse,
      inspect: singleBlockInspectionTreeNodes
    },
    { guard: fieldTypes_1.isRichTextFieldValue, inspect: richTextInspectionTreeNodes },
    {
      guard: fieldTypes_1.isRichTextFieldValueInRequest,
      inspect: richTextInspectionTreeNodes
    },
    {
      guard: fieldTypes_1.isRichTextFieldValueInNestedResponse,
      inspect: richTextInspectionTreeNodes
    }
  ];
  function createChildNode(attributeName, inspectResult) {
    if (typeof inspectResult === "string") {
      return { label: `${attributeName}: ${inspectResult}` };
    }
    if (Array.isArray(inspectResult)) {
      return {
        label: attributeName,
        nodes: inspectResult
      };
    }
    return {
      label: attributeName,
      nodes: [inspectResult]
    };
  }
  function inspectFieldValue(value, options) {
    if ((0, normalizedFieldValues_1.isLocalizedFieldValue)(value)) {
      for (const handler of fieldTypeHandlers) {
        if (Object.values(value).every((localeValue) => handler.guard(localeValue))) {
          const localeEntries = Object.entries(value).sort(([a], [b]) => a.localeCompare(b));
          return localeEntries.map(([locale, localeValue]) => {
            const inspectResult = handler.inspect(localeValue, options);
            if (typeof inspectResult === "string") {
              return { label: `${locale}: ${inspectResult}` };
            }
            if (Array.isArray(inspectResult)) {
              return {
                label: locale,
                nodes: inspectResult
              };
            }
            return {
              label: locale,
              nodes: [inspectResult]
            };
          });
        }
      }
    }
    for (const handler of fieldTypeHandlers) {
      if (handler.guard(value)) {
        return handler.inspect(value, options);
      }
    }
    return `UNKNOWN: ${JSON.stringify(value)}`;
  }
  function normalizeItem(item) {
    if ("attributes" in item) {
      return item;
    }
    const { __itemTypeId } = item, itemWithoutItemTypeId = __rest(item, ["__itemTypeId"]);
    return Utils.serializeRequestBody(itemWithoutItemTypeId, {
      type: resources_1.Item.TYPE,
      attributes: "*",
      relationships: ["item_type", "creator"]
    }).data;
  }
  function inspectItem(item, options) {
    return (0, datocms_structured_text_utils_1.formatAsTree)(itemInspectionTreeNodes(item, options));
  }
  exports.inspectItem = inspectItem;
  function itemInspectionTreeNodes(item, options) {
    var _a, _b;
    let itemTypeId;
    const normalizedItem = normalizeItem(item);
    if ("relationships" in normalizedItem && normalizedItem.relationships) {
      const relationships = normalizedItem.relationships;
      if ((_b = (_a = relationships.item_type) === null || _a === undefined ? undefined : _a.data) === null || _b === undefined ? undefined : _b.id) {
        itemTypeId = relationships.item_type.data.id;
      }
    }
    const rootLabel = [
      "Item",
      "id" in item ? JSON.stringify(normalizedItem.id) : null,
      itemTypeId ? `(item_type: ${JSON.stringify(itemTypeId)})` : null
    ].filter(Boolean).join(" ");
    const nodes = [];
    if ("attributes" in normalizedItem) {
      for (const [attributeName, attributeValue] of Object.entries(normalizedItem.attributes)) {
        const inspectResult = inspectFieldValue(attributeValue, options);
        nodes.push(createChildNode(attributeName, inspectResult));
      }
    }
    return {
      label: rootLabel,
      nodes: nodes.length > 0 ? nodes : undefined
    };
  }
  function structuredTextInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return (0, datocms_structured_text_utils_1.inspectionTreeNodes)(value, {
      maxWidth: (options === null || options === undefined ? undefined : options.maxWidth) || 80,
      blockFormatter: (block, maxWidth) => {
        if (typeof block === "string") {
          return JSON.stringify(block);
        }
        return itemInspectionTreeNodes(block, options);
      }
    });
  }
  function singleBlockInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    if (typeof value === "string")
      return JSON.stringify(value);
    return itemInspectionTreeNodes(value, options);
  }
  function richTextInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return value.map((item, index) => {
      const result = singleBlockInspectionTreeNodes(item, options);
      if (typeof result === "string") {
        return { label: `[${index}] ${result}` };
      }
      result.label = `[${index}] ${result.label}`;
      return result;
    });
  }
  function booleanInspectionTreeNodes(value) {
    return JSON.stringify(value);
  }
  function colorInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    const { red, green, blue, alpha } = value;
    const hex = `#${red.toString(16).padStart(2, "0").toUpperCase()}${green.toString(16).padStart(2, "0").toUpperCase()}${blue.toString(16).padStart(2, "0").toUpperCase()}`;
    if (alpha === 255) {
      return hex;
    }
    const alphaPercent = Math.round(alpha / 255 * 100);
    return `${hex} ${alphaPercent}%`;
  }
  function dateInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return value;
  }
  function dateTimeInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return value;
  }
  function fileInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    const nodes = [];
    nodes.push({ label: `upload_id: ${JSON.stringify(value.upload_id)}` });
    if (value.alt) {
      nodes.push({
        label: `alt: ${JSON.stringify(truncate2(value.alt, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
      });
    }
    if (value.title) {
      nodes.push({
        label: `title: ${JSON.stringify(truncate2(value.title, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
      });
    }
    if (value.custom_data && Object.keys(value.custom_data).length > 0) {
      nodes.push({
        label: `custom_data: ${truncate2(JSON.stringify(value.custom_data), (options === null || options === undefined ? undefined : options.maxWidth) || 80)}`
      });
    }
    if (value.focal_point) {
      const x = value.focal_point.x * 100;
      const y = value.focal_point.y * 100;
      nodes.push({ label: `focal_point: x=${x}% y=${y}%` });
    }
    return nodes;
  }
  function floatInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return value.toString();
  }
  function galleryInspectionTreeNodes(value, options) {
    if (!value || value.length === 0)
      return "[]";
    const itemNodes = value.map((item, index) => {
      const nodes = [];
      nodes.push({
        label: `upload_id: ${JSON.stringify(item.upload_id)}`
      });
      if (item.alt) {
        nodes.push({
          label: `alt: ${JSON.stringify(truncate2(item.alt, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
        });
      }
      if (item.title) {
        nodes.push({
          label: `title: ${JSON.stringify(truncate2(item.title, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
        });
      }
      if (item.custom_data && Object.keys(item.custom_data).length > 0) {
        nodes.push({
          label: `custom_data: ${truncate2(JSON.stringify(item.custom_data), (options === null || options === undefined ? undefined : options.maxWidth) || 80)}`
        });
      }
      if (item.focal_point) {
        const x = item.focal_point.x * 100;
        const y = item.focal_point.y * 100;
        nodes.push({ label: `focal_point: x=${x}% y=${y}%` });
      }
      return {
        label: `[${index}]`,
        nodes
      };
    });
    return itemNodes;
  }
  function integerInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return value.toString();
  }
  function jsonInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return truncate2(JSON.stringify(JSON.parse(value)), (options === null || options === undefined ? undefined : options.maxWidth) || 80);
  }
  function latLonInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return [
      { label: `latitude: ${value.latitude}` },
      { label: `longitude: ${value.longitude}` }
    ];
  }
  function linkInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return JSON.stringify(value);
  }
  function linksInspectionTreeNodes(value) {
    if (value === null)
      return "null";
    return value.map((itemId, index) => ({
      label: `[${index}]: ${JSON.stringify(itemId)}`
    }));
  }
  function seoFieldInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    const nodes = [];
    if (value.title) {
      nodes.push({
        label: `title: ${JSON.stringify(truncate2(value.title, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
      });
    }
    if (value.description) {
      nodes.push({
        label: `description: ${JSON.stringify(truncate2(value.description, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
      });
    }
    if (value.image) {
      nodes.push({
        label: `image: ${value.image}`
      });
    }
    if (value.twitter_card) {
      nodes.push({
        label: `twitter_card: ${value.twitter_card}`
      });
    }
    if (value.no_index !== undefined) {
      nodes.push({
        label: `no_index: ${value.no_index}`
      });
    }
    return nodes;
  }
  function slugInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return JSON.stringify(truncate2(value, (options === null || options === undefined ? undefined : options.maxWidth) || 80));
  }
  function stringInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return JSON.stringify(truncate2(value, (options === null || options === undefined ? undefined : options.maxWidth) || 80));
  }
  function textInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    return JSON.stringify(truncate2(value, (options === null || options === undefined ? undefined : options.maxWidth) || 80));
  }
  function videoFieldInspectionTreeNodes(value, options) {
    if (value === null)
      return "null";
    const nodes = [];
    nodes.push({ label: `provider: ${value.provider}` });
    nodes.push({ label: `provider_uid: ${value.provider_uid}` });
    nodes.push({ label: `url: ${value.url}` });
    nodes.push({ label: `size: ${value.width}⨯${value.height}px` });
    nodes.push({ label: `thumbnail_url: ${value.thumbnail_url}` });
    if (value.title) {
      nodes.push({
        label: `title: ${JSON.stringify(truncate2(value.title, (options === null || options === undefined ? undefined : options.maxWidth) || 80))}`
      });
    }
    return nodes;
  }
  function truncate2(text, maxWidth) {
    if (text.length <= maxWidth)
      return text;
    return `${text.slice(0, maxWidth - 3)}...`;
  }
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/itemDefinition.js
var require_itemDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@datocms/cma-client/dist/cjs/utilities/schemaRepository.js
var require_schemaRepository = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SchemaRepository = undefined;
  var rest_client_utils_1 = require_cjs();
  var fieldsContainingReferences_1 = require_fieldsContainingReferences();

  class SchemaRepository {
    constructor(client) {
      this.itemTypesPromise = null;
      this.itemTypesByApiKey = new Map;
      this.itemTypesById = new Map;
      this.fieldsByItemType = new Map;
      this.fieldsetsByItemType = new Map;
      this.pluginsPromise = null;
      this.pluginsById = new Map;
      this.pluginsByPackageName = new Map;
      this.prefetchPromise = null;
      this.client = client;
    }
    loadItemTypes() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.itemTypesPromise) {
          this.itemTypesPromise = (() => __awaiter(this, undefined, undefined, function* () {
            const { data: itemTypes } = yield this.client.itemTypes.rawList();
            for (const itemType of itemTypes) {
              this.itemTypesByApiKey.set(itemType.attributes.api_key, itemType);
              this.itemTypesById.set(itemType.id, itemType);
            }
            return itemTypes;
          }))();
        }
        return this.itemTypesPromise;
      });
    }
    getAllItemTypes() {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getAllRawItemTypes();
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getAllRawItemTypes() {
      return __awaiter(this, undefined, undefined, function* () {
        const itemTypes = yield this.loadItemTypes();
        return itemTypes;
      });
    }
    getAllModels() {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getAllRawModels();
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getAllRawModels() {
      return __awaiter(this, undefined, undefined, function* () {
        const itemTypes = yield this.loadItemTypes();
        return itemTypes.filter((it) => !it.attributes.modular_block);
      });
    }
    getAllBlockModels() {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getAllRawBlockModels();
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getAllRawBlockModels() {
      return __awaiter(this, undefined, undefined, function* () {
        const itemTypes = yield this.loadItemTypes();
        return itemTypes.filter((it) => it.attributes.modular_block);
      });
    }
    getItemTypeByApiKey(apiKey) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawItemTypeByApiKey(apiKey);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawItemTypeByApiKey(apiKey) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.loadItemTypes();
        const itemType = this.itemTypesByApiKey.get(apiKey);
        if (!itemType) {
          throw new Error(`Item type with API key '${apiKey}' not found`);
        }
        return itemType;
      });
    }
    getItemTypeById(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawItemTypeById(id);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawItemTypeById(id) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.loadItemTypes();
        const itemType = this.itemTypesById.get(id);
        if (!itemType) {
          throw new Error(`Item type with ID '${id}' not found`);
        }
        return itemType;
      });
    }
    getItemTypeFields(itemType) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawItemTypeFields(itemType);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawItemTypeFields(itemType) {
      return __awaiter(this, undefined, undefined, function* () {
        const cachedFields = this.fieldsByItemType.get(itemType.id);
        if (cachedFields) {
          return cachedFields;
        }
        const { data: fields } = yield this.client.fields.rawList(itemType.id);
        this.fieldsByItemType.set(itemType.id, fields);
        return fields;
      });
    }
    getItemTypeFieldsets(itemType) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawItemTypeFieldsets(itemType);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawItemTypeFieldsets(itemType) {
      return __awaiter(this, undefined, undefined, function* () {
        const cachedFieldsets = this.fieldsetsByItemType.get(itemType.id);
        if (cachedFieldsets) {
          return cachedFieldsets;
        }
        const { data: fieldsets } = yield this.client.fieldsets.rawList(itemType.id);
        this.fieldsetsByItemType.set(itemType.id, fieldsets);
        return fieldsets;
      });
    }
    loadPlugins() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.pluginsPromise) {
          this.pluginsPromise = (() => __awaiter(this, undefined, undefined, function* () {
            const { data: plugins } = yield this.client.plugins.rawList();
            for (const plugin of plugins) {
              this.pluginsById.set(plugin.id, plugin);
              if (plugin.attributes.package_name) {
                this.pluginsByPackageName.set(plugin.attributes.package_name, plugin);
              }
            }
            return plugins;
          }))();
        }
        return this.pluginsPromise;
      });
    }
    getAllPlugins() {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getAllRawPlugins();
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getAllRawPlugins() {
      return __awaiter(this, undefined, undefined, function* () {
        const plugins = yield this.loadPlugins();
        return plugins;
      });
    }
    getPluginById(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawPluginById(id);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawPluginById(id) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.loadPlugins();
        const plugin = this.pluginsById.get(id);
        if (!plugin) {
          throw new Error(`Plugin with ID '${id}' not found`);
        }
        return plugin;
      });
    }
    getPluginByPackageName(packageName) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawPluginByPackageName(packageName);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
    getRawPluginByPackageName(packageName) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.loadPlugins();
        const plugin = this.pluginsByPackageName.get(packageName);
        if (!plugin) {
          throw new Error(`Plugin with package name '${packageName}' not found`);
        }
        return plugin;
      });
    }
    prefetchAllModelsAndFields() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this.prefetchPromise) {
          return this.prefetchPromise;
        }
        const prefetch = () => __awaiter(this, undefined, undefined, function* () {
          const { included } = yield this.client.site.rawFind({
            include: "item_types,item_types.fields"
          });
          if (!included) {
            throw new Error("This should not happen");
          }
          const allItemTypes = included.filter((item) => item.type === "item_type");
          const allFields = included.filter((item) => item.type === "field");
          this.itemTypesPromise = Promise.resolve(allItemTypes);
          for (const itemType of allItemTypes) {
            this.itemTypesByApiKey.set(itemType.attributes.api_key, itemType);
            this.itemTypesById.set(itemType.id, itemType);
          }
          const fieldsByItemTypeId = new Map;
          for (const field of allFields) {
            const itemTypeId = field.relationships.item_type.data.id;
            if (!fieldsByItemTypeId.has(itemTypeId)) {
              fieldsByItemTypeId.set(itemTypeId, []);
            }
            fieldsByItemTypeId.get(itemTypeId).push(field);
          }
          for (const [itemTypeId, fields] of fieldsByItemTypeId) {
            this.fieldsByItemType.set(itemTypeId, fields);
          }
        });
        this.prefetchPromise = prefetch();
        return this.prefetchPromise;
      });
    }
    getRawModelsEmbeddingBlocks(blocks) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.prefetchAllModelsAndFields();
        const allItemTypes = yield this.getAllRawItemTypes();
        const blockIds = new Set(blocks.map((block) => block.id));
        const embeddingModels = [];
        const modelPointsToBlocks = (itemType, alreadyExplored = new Set) => __awaiter(this, undefined, undefined, function* () {
          if (alreadyExplored.has(itemType.id)) {
            return false;
          }
          alreadyExplored.add(itemType.id);
          const fields = yield this.getRawItemTypeFields(itemType);
          for (const field of fields) {
            const referencedBlockIds = (0, fieldsContainingReferences_1.blockModelIdsReferencedInField)(field);
            if (referencedBlockIds.some((id) => blockIds.has(id))) {
              return true;
            }
            const referencedBlocks = referencedBlockIds.map((id) => allItemTypes.find((it) => it.id === id));
            for (const linkedBlock of referencedBlocks) {
              if (yield modelPointsToBlocks(linkedBlock, new Set(alreadyExplored))) {
                return true;
              }
            }
          }
          return false;
        });
        for (const itemType of allItemTypes) {
          if (yield modelPointsToBlocks(itemType)) {
            embeddingModels.push(itemType);
          }
        }
        return embeddingModels;
      });
    }
    getModelsEmbeddingBlocks(blocks) {
      return __awaiter(this, undefined, undefined, function* () {
        const rawResult = yield this.getRawModelsEmbeddingBlocks(blocks);
        return (0, rest_client_utils_1.deserializeResponseBody)({
          data: rawResult
        });
      });
    }
  }
  exports.SchemaRepository = SchemaRepository;
});

// node_modules/@datocms/cma-client/dist/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Resources = exports.Client = exports.TimeoutError = exports.LogLevel = exports.ApiError = undefined;
  var rest_client_utils_1 = require_cjs();
  Object.defineProperty(exports, "ApiError", { enumerable: true, get: function() {
    return rest_client_utils_1.ApiError;
  } });
  Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function() {
    return rest_client_utils_1.LogLevel;
  } });
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return rest_client_utils_1.TimeoutError;
  } });
  __exportStar(require_buildClient(), exports);
  __exportStar(require_fieldTypes(), exports);
  var Client_1 = require_Client();
  Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
    return Client_1.Client;
  } });
  exports.Resources = __importStar(require_resources());
  __exportStar(require_buildBlockRecord(), exports);
  __exportStar(require_duplicateBlockRecord(), exports);
  __exportStar(require_fieldsContainingReferences(), exports);
  __exportStar(require_id(), exports);
  __exportStar(require_inspectItem(), exports);
  __exportStar(require_itemDefinition(), exports);
  __exportStar(require_normalizedFieldValues(), exports);
  __exportStar(require_recursiveBlocks(), exports);
  __exportStar(require_schemaRepository(), exports);
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return `
` + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split(`
`);
            var controlLines = control.stack.split(`
`);
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return `

Check the render method of \`` + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = `

Check the top-level render call using <` + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0;i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. " + "You are likely explicitly calling React.jsxs or React.jsxDEV. " + "Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error(`A props object containing a "key" prop is being spread into JSX:
` + `  let props = %s;
` + `  <%s {...props} />
` + `React keys must be passed directly to JSX without using spread:
` + `  let props = %s;
` + "  <%s key={someKey} {...props} />", beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development(), 1);
  if (false) {} else {
    module.exports = react_jsx_dev_runtime_development;
  }
});

// src/utils/markdown-truncate.ts
var markdownTruncate = (text = "", options = { limit: 1, ellipsis: false }) => {
  const { limit, ellipsis } = options || {};
  if (text.length <= limit) {
    return text;
  }
  let outputText = replaceFormatMarkersWithPlaceholders(text);
  outputText = truncate(outputText, limit, ellipsis);
  outputText = replaceFormatPlaceholdersWithMarkers(outputText);
  return outputText;
};
var ASTERISK_ITALIC = "*";
var UNDERSCORE_ITALIC = "_";
var ASTERISK_BOLD = "**";
var UNDERSCORE_BOLD = "__";
var ESCAPED_UNDERSCORE = "\\_";
var ESCAPED_ASTERISK = "\\*";
var ESCAPED_ASTERISK_REGEXP = /\\\*/g;
var ASTERISK_PLACEHOLDER_REGEXP = /ASTERISKPLACEHOLDER/gm;
var ESCAPED_UNDERSCORE_REGEXP = /\\_/g;
var UNDERSCORE_PLACEHOLDER_REGEXP = /UNDERSCOREPLACEHOLDER/gm;
var UNDERSCORE_BOLD_PLACEHOLDER_REGEXP = /UNDERSCOREBOLDPLACEHOLDER/gm;
var UNDERSCORE_BOLD_REGEXP = /(__)(.*?)(__)/g;
var ASTERISK_BOLD_PLACEHOLDER_REGEXP = /ASTERISKBOLDPLACEHOLDER/gm;
var ASTERISK_BOLD_REGEXP = /(\*\*)(.*?)(\*\*)/g;
var UNDERSCORE_ITALIC_PLACEHOLDER_REGEXP = /UNDERSCOREITALICPLACEHOLDER/gm;
var UNDERSCORE_ITALIC_REGEXP = /(_)(.*?)(_)/g;
var ASTERISK_ITALIC_PLACEHOLDER_REGEXP = /ASTERISKITALICPLACEHOLDER/gm;
var ASTERISK_ITALIC_REGEXP = /(\*)(.*?)(\*)/g;
var HYPERLINK = /^\[([^[]+)\]\(([^)]+)\)/;
var replaceFormatMarkersWithPlaceholders = (text) => text.replace(ESCAPED_UNDERSCORE_REGEXP, UNDERSCORE_PLACEHOLDER_REGEXP.source).replace(ESCAPED_ASTERISK_REGEXP, ASTERISK_PLACEHOLDER_REGEXP.source).replace(UNDERSCORE_BOLD_REGEXP, `${UNDERSCORE_BOLD_PLACEHOLDER_REGEXP.source}$2${UNDERSCORE_BOLD_PLACEHOLDER_REGEXP.source}`).replace(ASTERISK_BOLD_REGEXP, `${ASTERISK_BOLD_PLACEHOLDER_REGEXP.source}$2${ASTERISK_BOLD_PLACEHOLDER_REGEXP.source}`).replace(UNDERSCORE_ITALIC_REGEXP, `${UNDERSCORE_ITALIC_PLACEHOLDER_REGEXP.source}$2${UNDERSCORE_ITALIC_PLACEHOLDER_REGEXP.source}`).replace(ASTERISK_ITALIC_REGEXP, `${ASTERISK_ITALIC_PLACEHOLDER_REGEXP.source}$2${ASTERISK_ITALIC_PLACEHOLDER_REGEXP.source}`);
var replaceFormatPlaceholdersWithMarkers = (text) => text.replace(UNDERSCORE_PLACEHOLDER_REGEXP, ESCAPED_UNDERSCORE).replace(ASTERISK_PLACEHOLDER_REGEXP, ESCAPED_ASTERISK).replace(UNDERSCORE_BOLD_PLACEHOLDER_REGEXP, UNDERSCORE_BOLD).replace(ASTERISK_BOLD_PLACEHOLDER_REGEXP, ASTERISK_BOLD).replace(UNDERSCORE_ITALIC_PLACEHOLDER_REGEXP, UNDERSCORE_ITALIC).replace(ASTERISK_ITALIC_PLACEHOLDER_REGEXP, ASTERISK_ITALIC);
var formatMarkers = [
  ASTERISK_BOLD_PLACEHOLDER_REGEXP.source,
  UNDERSCORE_BOLD_PLACEHOLDER_REGEXP.source,
  ASTERISK_ITALIC_PLACEHOLDER_REGEXP.source,
  UNDERSCORE_ITALIC_PLACEHOLDER_REGEXP.source
];
var formatPlaceholdersMap = {
  [UNDERSCORE_PLACEHOLDER_REGEXP.source]: ESCAPED_UNDERSCORE.length,
  [ASTERISK_PLACEHOLDER_REGEXP.source]: ESCAPED_ASTERISK.length
};
var findFormatPlaceholderAhead = (text) => {
  const formatPlaceholders = Object.keys(formatPlaceholdersMap);
  for (let i = 0, l = formatPlaceholders.length;i < l; i++) {
    if (text.startsWith(formatPlaceholders[i])) {
      return formatPlaceholders[i];
    }
  }
  return null;
};
var findFormatMarkerAhead = (text, formatStack) => {
  for (let i = 0, l = formatMarkers.length;i < l; i++) {
    if (text.startsWith(formatMarkers[i])) {
      if (formatStack[formatStack.length - 1] === formatMarkers[i]) {
        formatStack.pop();
      } else {
        formatStack.push(formatMarkers[i]);
      }
      return formatMarkers[i];
    }
  }
  return null;
};
var truncate = (text, limit, ellipsis) => {
  let count = 0;
  const truncateString = (text2) => {
    let formatStack = [];
    let skipCountIncrement = false;
    let outputText2 = "";
    let index = 0;
    while (count < limit && index < text2.length) {
      const formatMarker = findFormatMarkerAhead(text2.substring(index), formatStack);
      if (formatMarker) {
        outputText2 += formatMarker;
        index += formatMarker.length;
        skipCountIncrement = true;
      }
      const formatPlaceholder = findFormatPlaceholderAhead(text2.substring(index));
      if (formatPlaceholder) {
        outputText2 += formatPlaceholder;
        index += formatPlaceholder.length;
        skipCountIncrement = true;
        count += formatPlaceholdersMap[formatPlaceholder];
      }
      const hyperlinkAheadRegexp = new RegExp(HYPERLINK);
      const hyperlinkMatch = hyperlinkAheadRegexp.exec(text2.substring(index));
      if (hyperlinkMatch) {
        const hyperlinkText = hyperlinkMatch[1];
        const hyperlinkUrl = hyperlinkMatch[2];
        outputText2 += `[${truncateString(hyperlinkText)}](${hyperlinkUrl})`;
        index += hyperlinkMatch[0].length;
        skipCountIncrement = true;
      }
      if (!formatMarker && !hyperlinkMatch) {
        outputText2 += text2[index];
        index++;
      }
      if (!skipCountIncrement) {
        count++;
      }
      skipCountIncrement = false;
    }
    outputText2 = outputText2.trimEnd();
    while (formatStack.length > 0) {
      outputText2 += formatStack.pop();
    }
    return outputText2;
  };
  let outputText = truncateString(text);
  if (ellipsis && outputText.length < text.length) {
    outputText += "...";
  }
  return outputText;
};
var markdown_truncate_default = markdownTruncate;

// src/server-actions/index.ts
var import_headers = __toESM(require_headers2(), 1);
var import_navigation = __toESM(require_navigation(), 1);
var import_cache = __toESM(require_cache(), 1);
"use server";
async function disableDraftMode(pathname) {
  (await import_headers.draftMode()).disable();
  import_navigation.redirect(pathname ?? `/`);
}
async function revalidateTag(tag) {
  Array.isArray(tag) ? tag.forEach((t) => import_cache.revalidateTag(t)) : import_cache.revalidateTag(tag);
}
async function revalidatePath(path) {
  Array.isArray(path) ? path.forEach((p) => import_cache.revalidatePath(p)) : import_cache.revalidatePath(path);
}

// src/utils/iterate-object.ts
function iterateObject(obj, fn) {
  let i = 0, keys = [];
  if (Array.isArray(obj)) {
    for (;i < obj.length; ++i) {
      if (fn(obj[i], i, obj) === false)
        break;
    }
  } else if (typeof obj === "object" && obj !== null) {
    keys = Object.keys(obj);
    for (;i < keys.length; ++i) {
      if (fn(obj[keys[i]], keys[i], obj) === false)
        break;
    }
  }
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/utils/postmark.ts
var postmark = __toESM(require_dist(), 1);
async function sendPostmarkEmail({ to, subject, html, text, template, templateData }) {
  try {
    if (!process.env.POSTMARK_API_TOKEN)
      throw new Error("POSTMARK_API_TOKEN is not set");
    if (!process.env.POSTMARK_FROM_EMAIL)
      throw new Error("POSTMARK_FROM_EMAIL is not set");
    if (!process.env.POSTMARK_FROM_NAME)
      throw new Error("POSTMARK_FROM_NAME is not set");
    const isTemplateEmail = typeof template === "string";
    try {
      if (!isTemplateEmail) {
        z.string().min(1).parse(subject);
        z.string().min(1).parse(text);
      }
    } catch (e) {
      throw new Error("Missing subject or text field");
    }
    try {
      if (to) {
        z.string().email().parse(to);
      }
    } catch (e) {
      throw new Error("Invalid To e-mail address");
    }
    const postmarkClient = new postmark.ServerClient(process.env.POSTMARK_API_TOKEN);
    const res = isTemplateEmail ? await postmarkClient.sendEmailWithTemplate({
      From: process.env.POSTMARK_FROM_EMAIL,
      To: to || process.env.POSTMARK_FROM_EMAIL,
      TemplateAlias: template,
      TemplateModel: templateData ?? {}
    }) : await postmarkClient.sendEmail({
      From: process.env.POSTMARK_FROM_EMAIL,
      To: to || process.env.POSTMARK_FROM_EMAIL,
      Subject: subject,
      HtmlBody: html,
      TextBody: text
    });
    if (res.ErrorCode) {
      throw new Error(`There was an error sending the email. (${res.ErrorCode}) ${res.Message}`);
    }
    return { success: true };
  } catch (error) {
    console.error(error);
    return { success: false, error: error instanceof Error ? error.message : error };
  }
}

// src/utils/utilities.ts
var import_cma_client = __toESM(require_cjs3(), 1);
var isServer = typeof window === "undefined";
var chunkArray = (array, chunkSize) => {
  const newArr = [];
  for (let i = 0;i < array.length; i += chunkSize)
    newArr.push(array.slice(i, i + chunkSize));
  return newArr;
};
var parseDatoError = (err) => {
  const errors = err.errors.map(({ attributes: { code, details } }) => ({
    code,
    field: details?.field,
    message: details?.message,
    detailsCode: details?.code,
    errors: Array.isArray(details?.errors) ? details?.errors.join(". ") : undefined
  }));
  return errors.map(({ code, field, message, detailsCode, errors: errors2 }) => `${code} ${field ? `(${field})` : ""} ${message || ""} ${detailsCode || ""} ${errors2 ? `(${errors2})` : ""}`).join(`
`);
};
var parseDatoCMSApiError = (e) => {
  if (e instanceof import_cma_client.ApiError === false)
    return typeof e === "string" ? e : e.message || e.toString();
  const err = new import_cma_client.ApiError(e);
  return err.errors.map((e2) => {
    let code = `${e2.attributes.code}`;
    let errors = [];
    if (Array.isArray(e2.attributes.details?.errors)) {
      e2.attributes.details.errors.forEach((e3) => {
        errors.push(Object.keys(e3).map((k) => `${k}: ${e3[k]}`).join(", "));
      });
    }
    return `${code}${errors.length ? `: ${errors.join(". ")}` : ""}`;
  }).join(`
`);
};
var isEmpty = (obj) => Object.keys(obj).filter((k) => obj[k] !== undefined).length === 0;
var capitalize = (str, lower = false) => {
  return (lower ? str.toLowerCase() : str).replace(/(?:^|\s|["'([{])+\S/g, (match) => match.toUpperCase());
};
var sleep = (ms) => new Promise((resolve, refject) => setTimeout(resolve, ms));
var rInt = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
var truncateParagraph = (s, sentances = 1, ellipsis = true, minLength = 200) => {
  if (!s || s.length < minLength)
    return s;
  let dotIndex = s.split(".")?.slice(0, sentances + 1).join(".").lastIndexOf(".");
  let qIndex = s.split("? ")?.slice(0, sentances + 1).join("? ").lastIndexOf("? ");
  const isQuestion = qIndex !== -1 && qIndex < dotIndex || dotIndex === -1 && qIndex > -1;
  if (dotIndex === -1 && qIndex === -1) {
    dotIndex = minLength - 1;
    ellipsis = true;
  }
  let str = s.substring(0, isQuestion ? qIndex : dotIndex);
  return `${str}${ellipsis ? "..." : isQuestion ? "?" : "."}`;
};
var truncateWords = (text, maxLength) => {
  if (text.length <= maxLength)
    return text;
  var truncatedText = text.substring(0, maxLength);
  var lastSpaceIndex = truncatedText.lastIndexOf(" ");
  if (lastSpaceIndex !== -1) {
    truncatedText = truncatedText.substr(0, lastSpaceIndex);
  }
  return truncatedText + "...";
};
var sortSwedish = (arr, key) => {
  const sorter = new Intl.Collator("sv", { usage: "sort" });
  return arr.sort((a, b) => sorter.compare(a[key], b[key]));
};
var awaitElement = async (selector, ms = 1000) => {
  const cleanSelector = function(selector2) {
    (selector2.match(/(#[0-9][^\s:,]*)/g) || []).forEach(function(n) {
      selector2 = selector2.replace(n, '[id="' + n.replace("#", "") + '"]');
    });
    return selector2;
  };
  const retry = 30;
  for (let t = 0;t < ms; t += retry) {
    const el = document.querySelector(cleanSelector(selector));
    if (el)
      return el;
    await sleep(retry);
  }
  return null;
};
// src/components/draft-mode/index.tsx
var import_headers2 = __toESM(require_headers2(), 1);

// src/components/draft-mode/DraftModeClient.module.scss
var DraftModeClient_module_default = "../../../DraftModeClient.module-etb9xmnn.scss";

// src/components/draft-mode/DraftModeClient.tsx
var import_navigation2 = __toESM(require_navigation(), 1);
var import_react = __toESM(require_react(), 1);
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
"use client";
function DraftMode({ enabled, draftUrl, tag, path, actions }) {
  const pathname = import_navigation2.usePathname();
  const [loading, startTransition] = import_react.useTransition();
  const listener = import_react.useRef(null);
  const tags = tag ? Array.isArray(tag) ? tag : [tag] : [];
  const paths = path ? Array.isArray(path) ? path : [path] : [];
  import_react.useEffect(() => {
    if (!draftUrl || !enabled || listener?.current)
      return;
    const connect = () => {
      console.log("connecting to channel");
      let updates = 0;
      listener.current = new EventSource(draftUrl);
      listener.current.addEventListener("open", () => {
        console.log("connected to channel!");
      });
      listener.current.addEventListener("update", async (event) => {
        if (++updates <= 1)
          return;
        console.log(event);
        startTransition(() => {
          if (tags)
            actions.revalidateTag(tags);
          if (paths)
            actions.revalidatePath(paths);
        });
      });
      listener.current.addEventListener("channelError", (err) => {
        console.log("channel error");
        console.log(err);
      });
      const statusCheck = setInterval(async () => {
        if (listener.current?.readyState === 2) {
          console.log("channel closed");
          clearInterval(statusCheck);
          await disconnect();
          connect();
        }
      }, 1000);
    };
    const disconnect = async () => {
      if (listener.current) {
        listener.current.close();
        listener.current = null;
      }
      await sleep(1000);
    };
    connect();
    return () => {
      disconnect();
    };
  }, [draftUrl, tag, path, enabled]);
  if (!enabled)
    return null;
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
    className: DraftModeClient_module_default.draftMode,
    children: [
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
        className: DraftModeClient_module_default.label,
        children: [
          /* @__PURE__ */ jsx_dev_runtime.jsxDEV("img", {
            className: loading ? DraftModeClient_module_default.loading : undefined,
            width: "20",
            height: "20"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
            children: "Draft mode"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
        className: DraftModeClient_module_default.button,
        children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV("button", {
          onClick: () => startTransition(() => actions.disableDraftMode(pathname)),
          children: "Exit"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/components/draft-mode/index.tsx
var jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
"use server";
async function DraftMode2({ url, tag, path }) {
  if (!url || !tag && !path)
    return null;
  const enabled = (await import_headers2.draftMode()).isEnabled;
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(DraftMode, {
    enabled,
    draftUrl: url,
    tag,
    path,
    actions: { revalidateTag, revalidatePath, disableDraftMode }
  }, undefined, false, undefined, this);
}
export {
  DraftMode2 as default
};
